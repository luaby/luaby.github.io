<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>exe注册为windows服务</title>
      <link href="/2025/05/13/exe%E6%B3%A8%E5%86%8C%E4%B8%BAwindows%E6%9C%8D%E5%8A%A1/"/>
      <url>/2025/05/13/exe%E6%B3%A8%E5%86%8C%E4%B8%BAwindows%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<ol><li>在 <a href="https://nssm.cc/download">https://nssm.cc/download</a> 下载最新版本的 <code>nssm</code>；</li><li>在解压后的文件夹内按住 Shift 并右击空白处，选择“在此处打开 Powershell 窗口”；</li><li>在弹出的窗口中输入 <code>.\nssm.exe install alist</code>；</li><li>Path 选择 alist.exe 的路径，如 <code>D:\alist\alist.exe</code>，Arguments 填 <code>server</code>；</li><li>Details 选项卡中可以自定义标题和描述，可以选择服务的自启动模式（自动|延迟启动|手动|禁用）；</li><li>在 I&#x2F;O 选项卡为 Output (stdout) 和 Output (stderr) 各自指定一个日志文件的路径，如 <code>D:\alist\stdout.log</code>，文件本身（<code>stdout.log</code>）可以不存在，但是指定的目录（<code>D:\alist</code>）必须存在；</li><li>点击“Install Service”即可。</li></ol><p>此后可以直接在服务中启动 <code>alist</code></p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.UE4物体移动</title>
      <link href="/2025/04/13/UE4_2_operation/"/>
      <url>/2025/04/13/UE4_2_operation/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>此教程根据 UE 自带第三人称游戏模板，若不知如何新建项目请看上一文章，第三人称的Maps文件夹在ThirdPersonBP下</p><p>推荐先学习视角移动操作，<a href="https://www.bilibili.com/video/BV11N411o7g9/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=b08a44d7e2c93f0136d624b6f99857e5">视频链接</a></p><p>此文档参考哔哩哔哩视频制作：<a href="https://www.bilibili.com/video/BV1b741147fb?spm_id_from=333.788.player.switch&vd_source=b08a44d7e2c93f0136d624b6f99857e5&p=5">视口</a></p><h2 id="1-移动物体"><a href="#1-移动物体" class="headerlink" title="1.移动物体"></a>1.移动物体</h2><p><img src="https://image.buretuzi.online/ue4/2_%E8%A7%86%E5%8F%A3/Snipaste_2025-04-13_10-52-55.png" title="移动物体"></p><font color=rebeccapurple>我们此时选中移动，鼠标放置在黄色轴，鼠标变为移动图标</font><p><img src="https://image.buretuzi.online/ue4/2_%E8%A7%86%E5%8F%A3/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250413110145.jpg" title="移动物体"></p><font color=rebeccapurple>单击不松手变为小手图标，并移动鼠标即可移动物体，如下图</font><p><img src="https://image.buretuzi.online/ue4/2_%E8%A7%86%E5%8F%A3/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250413110156.jpg" title="移动物体"></p><h2 id="2-旋转物体"><a href="#2-旋转物体" class="headerlink" title="2.旋转物体"></a>2.旋转物体</h2><font color=rebeccapurple>旋转物体如同移动物体，此操作不做过多赘述</font><p><img src="https://image.buretuzi.online/ue4/2_%E8%A7%86%E5%8F%A3/Snipaste_2025-04-13_10-55-52.png" title="移动物体"></p><h2 id="3-缩放物体"><a href="#3-缩放物体" class="headerlink" title="3.缩放物体"></a>3.缩放物体</h2><font color=rebeccapurple>缩放物体可根据某一坐标缩放，也可整体缩放，具体如下：</font><p><img src="https://image.buretuzi.online/ue4/2_%E8%A7%86%E5%8F%A3/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250413111310.jpg" title="移动物体"><br><img src="https://image.buretuzi.online/ue4/2_%E8%A7%86%E5%8F%A3/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250413111317.jpg" title="移动物体"><br><img src="https://image.buretuzi.online/ue4/2_%E8%A7%86%E5%8F%A3/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250413111320.jpg" title="移动物体"></p>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE4基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.UE4基础操作</title>
      <link href="/2025/04/11/UE4_1_operation/"/>
      <url>/2025/04/11/UE4_1_operation/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>此文档参考哔哩哔哩视频制作：<a href="https://www.bilibili.com/video/BV1b741147fb?spm_id_from=333.788.player.switch&vd_source=b08a44d7e2c93f0136d624b6f99857e5&p=5">基础</a></p><h2 id="1-新建项目，这里选择游戏，然后下一步"><a href="#1-新建项目，这里选择游戏，然后下一步" class="headerlink" title="1.新建项目，这里选择游戏，然后下一步"></a>1.新建项目，这里选择游戏，然后下一步</h2><p><img src="https://image.buretuzi.online/ue4/1_%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/Snipaste_2025-04-11_21-56-26.png" title="创建项目"></p><h2 id="2-选择载具类模板，下一步"><a href="#2-选择载具类模板，下一步" class="headerlink" title="2.选择载具类模板，下一步"></a>2.选择载具类模板，下一步</h2><p><img src="https://image.buretuzi.online/ue4/1_%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/Snipaste_2025-04-11_21-56-34.png" title="创建项目"></p><h2 id="3-可以更改任意项目名，创建项目"><a href="#3-可以更改任意项目名，创建项目" class="headerlink" title="3.可以更改任意项目名，创建项目"></a>3.可以更改任意项目名，创建项目</h2><p><img src="https://image.buretuzi.online/ue4/1_%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/Snipaste_2025-04-11_21-57-33.png" title="创建项目"></p><h2 id="4-创建后先展开项目目录"><a href="#4-创建后先展开项目目录" class="headerlink" title="4.创建后先展开项目目录"></a>4.创建后先展开项目目录</h2><p><img src="https://image.buretuzi.online/ue4/1_%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/Snipaste_2025-04-11_21-58-58.png" title="创建项目"></p><h2 id="5-按下图目录展开，并双击背景色为黄色的模型"><a href="#5-按下图目录展开，并双击背景色为黄色的模型" class="headerlink" title="5.按下图目录展开，并双击背景色为黄色的模型"></a>5.按下图目录展开，并双击背景色为黄色的模型</h2><p><img src="https://image.buretuzi.online/ue4/1_%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/Snipaste_2025-04-11_21-59-38.png" title="创建项目"></p><h2 id="6-此时场景已加载出来，点击运行，然后鼠标点击场景即可开始游玩"><a href="#6-此时场景已加载出来，点击运行，然后鼠标点击场景即可开始游玩" class="headerlink" title="6.此时场景已加载出来，点击运行，然后鼠标点击场景即可开始游玩"></a>6.此时场景已加载出来，点击运行，然后鼠标点击场景即可开始游玩</h2><p><img src="https://image.buretuzi.online/ue4/1_%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/Snipaste_2025-04-11_22-01-08.png" title="创建项目"></p><h2 id="7-W前行，S后退，AD控制方向"><a href="#7-W前行，S后退，AD控制方向" class="headerlink" title="7.W前行，S后退，AD控制方向"></a>7.W前行，S后退，AD控制方向</h2><p><img src="https://image.buretuzi.online/ue4/1_%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/Snipaste_2025-04-11_22-01-31.png" title="创建项目"></p>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE4基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 搭建KMS</title>
      <link href="/2023/11/10/Linux%20%E6%90%AD%E5%BB%BAKMS/"/>
      <url>/2023/11/10/Linux%20%E6%90%AD%E5%BB%BAKMS/</url>
      
        <content type="html"><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>kms:</p><blockquote><p>Kms（Key Management Service）: 是微软官方认可的一种系统激活方式。这个激活方式主要用于企业批量激活计算机的windows和office</p></blockquote><p>vlmcsd:</p><blockquote><p>vlmcsd：’vlmcsd’是一个开源项目，它是一个 KMS（Key Management Service）的仿真器。KMS 是 Microsoft 为批量激活 Windows 和 Office 产品提供的服务，而 ‘vlmcsd’ 则可以模拟这种服务。具体来说，vlmcsd 可以接受kms请求并返回激活数据，这使得你可以在没有直接从 microsoft 获取授权的情况下激活windows 或office。</p></blockquote><h2 id="1、下载vlmcsd进行配置"><a href="#1、下载vlmcsd进行配置" class="headerlink" title="1、下载vlmcsd进行配置"></a>1、下载vlmcsd进行配置</h2><p>#下载vlmcsd压缩包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Wind4/vlmcsd/releases/download/svn1113/binaries.tar.gz</span><br></pre></td></tr></table></figure><p> #解压到当前目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar  xf  binaries.tar.gz</span><br></pre></td></tr></table></figure><p>#将vlmcsd复制到&#x2F;usr&#x2F;bin目录下,并更名为kms</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /root/binaries/Linux/intel/static/vlmcsd-x64-musl-static  /usr/bin/kms</span><br></pre></td></tr></table></figure><p>#运行kms</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/kms</span><br></pre></td></tr></table></figure><p>#查看kms是否运行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef |grep kms</span><br></pre></td></tr></table></figure><p>#查看kms端口是否正常</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ss -lntup | grep kms</span><br></pre></td></tr></table></figure><p>#创建服务文件，方便通过systemctl管理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/kms.service</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=KMS Server By vlmcsd</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/run/kms.pid</span><br><span class="line">ExecStart=/usr/bin/kms -p /run/kms.pid</span><br><span class="line">ExecStop=/bin/kill -HUP $MAINPID</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>#结束kms进程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pkill kms</span><br></pre></td></tr></table></figure><p>#重新加载配置文件 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>#设置开机自启</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl  enable kms.service</span><br></pre></td></tr></table></figure><p>#启动服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl  start  kms.service</span><br></pre></td></tr></table></figure><p>#查看kms是否运行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef |grep kms</span><br></pre></td></tr></table></figure><p>#查看kms端口是否正常</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ss -lntup | grep kms</span><br></pre></td></tr></table></figure><p>2、防火墙放行端口，关闭selinux<br>setenforce  0  #临时关闭selinux<br>firewall-cmd –zone&#x3D;public –add-port&#x3D;1688&#x2F;tcp –permanent #永久放行1688端口<br>firewall-cmd –reload #防火墙配置重新加载<br>#直接关闭防火墙也可以<br>systemctl stop firewalld<br>3、在window10上进行测试<br>附：bat脚本直接运行即可</p><p>链接：<a href="https://pan.baidu.com/s/19DxzXB373dOJM6FxEyr85Q?pwd=tsgw">https://pan.baidu.com/s/19DxzXB373dOJM6FxEyr85Q?pwd=tsgw</a> 提取码：tsgw</p><p>#以管理员身份运行cmd<br>C:\Windows\system32&gt; slmgr &#x2F;upk  | slmgr &#x2F;skms 10.0.0.55 | slmgr &#x2F;ipk NPPR9-FWDCX-D2C8J-H872K-2YT43 | slmgr &#x2F;ato     （Windows10企业版）</p><h3 id="x2F-upk：卸载秘钥"><a href="#x2F-upk：卸载秘钥" class="headerlink" title="&#x2F;upk：卸载秘钥"></a>&#x2F;upk：卸载秘钥</h3><h3 id="x2F-skms：设置kms服务器的地址或域名"><a href="#x2F-skms：设置kms服务器的地址或域名" class="headerlink" title="&#x2F;skms：设置kms服务器的地址或域名"></a>&#x2F;skms：设置kms服务器的地址或域名</h3><h3 id="x2F-ipk：安装（指定）密钥"><a href="#x2F-ipk：安装（指定）密钥" class="headerlink" title="&#x2F;ipk：安装（指定）密钥"></a>&#x2F;ipk：安装（指定）密钥</h3><h3 id="x2F-ato：执行激活"><a href="#x2F-ato：执行激活" class="headerlink" title="&#x2F;ato：执行激活"></a>&#x2F;ato：执行激活</h3><p>#查看激活信息的cmd命令<br>C:\Windows\system32&gt; slmgr &#x2F;xpr     #查看激活后的到期时间<br>​<br>C:\Windows\system32&gt; slmgr &#x2F;dli     #查看详细激活信息<br>​<br>C:\Windows\system32&gt;slmgr &#x2F;dlv      #查看详细的产品密钥许可信息</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 搭建OpenVPN</title>
      <link href="/2023/11/10/Linux%20%E6%90%AD%E5%BB%BAOpenVPN/"/>
      <url>/2023/11/10/Linux%20%E6%90%AD%E5%BB%BAOpenVPN/</url>
      
        <content type="html"><![CDATA[<body class="post-template-default single single-post postid-14 single-format-standard logged-in admin-bar single-author singular two-column left-sidebar customize-support">        <div id="page" class="hfeed">            <div id="main">                <div id="primary">                    <div id="content" role="main">                        <article id="post-14" class="post-14 post type-post status-publish format-standard hentry category-18">                            <header class="entry-header">                                <h1 class="entry-title">Linux 搭建OpenVPN服务器和客户端（一）——最简配置</h1>                            </header>                            <div class="entry-content"><p>项目需要能够远程控制树莓派。说到远程控制，肯定想到ssh。但是呢，树莓派是用3G流量上网的，分配到的是内网IP地址。那么如何让另一个设备能够连接到处于内网的设备呢？我想到了VPN。在VPN中，所有设备都好像在一个局域网中，如果服务器适当配置一下，那么VPN客户端之间就能互相访问。</p><p>VPN有很多种，包括PPTP、IPSec、OpenVPN等等。PPTP的数据包特征太明显，在国内的网络环境中很可能直接被拦截掉了。另外，由于树莓派使用的是3G流量，其链路可能功能有限，IPSec使用的是Cisco自己设计的协议，可能会被丢弃（未考证）。综合考虑，还是OpenVPN功能最强大，因为它是基于TCP或者UDP的，而且数据包特征不太明显，另外可配置项也很多。</p><p>OpenVPN的配置还是比较复杂的，尤其是对于新手而言，如果一开始上来就是什么创建证书、公钥、密钥，会很打击信心。所以我决定先来一个最最简单的版本，然后循序渐进。</p><p>=================阶段一：服务器端最简配置===============</p><p>一、下载OpenVPN：</p><pre>sudo apt-get install openvpn</pre><p>二、证书、公钥、密钥和Diffie-Hellman参数 ：</p><p>OpenVPN服务器需要四个文件ca.crt、server.crt、server.key和dh1024.pem。这四个文件都与加密有关，具体含义我至今不太清楚。。。OpenVPN自带了示例文件。这四个文件分别可以如下获得：</p><p>ca.crt：</p><pre>&nbsp;sudo cp /usr/share/doc/openvpn/examples/sample-keys/ca.crt /etc/openvpn</pre><p>server.crt：</p><pre>sudo gunzip -c /usr/share/doc/openvpn/examples/sample-keys/server.crt.gz &gt; /tmp/server.crtsudo mv /tmp/server.crt /etc/openvpn/</pre><p>server.key：</p><pre>sudo cp /usr/share/doc/openvpn/examples/sample-keys/server.key /etc/openvpn/</pre><p>dh1024.pem：</p><pre>sudo cp /usr/share/doc/openvpn/examples/sample-keys/dh1024.pem /etc/openvpn</pre><p>于是/etc/openvpn目录下就有这四个文件了。</p><p>三、编写服务器配置文件：</p><p>编写服务器端配置文件/etc/openvpn/server.conf，内容如下：</p><pre>port 1194proto udpdev tunca ca.crtcert server.crtkey server.keydh dh1024.pemserver 10.8.0.0 255.255.255.0keepalive 10 120user nobodygroup nogrouppersist-keypersist-tunverb 3</pre><p>其实该文件也可以由/usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz解压得到。每一行具体的意思可以查看其中的注释。</p><p>四、启动OpenVPN服务器：</p><p>现在，/etc/openvpn目录下有5个文件：ca.crt、server.crt、server.key、dh1024.pem和server.conf。</p><pre>cd /etc/openvpnsudo openvpn --config server.conf</pre><p>执行该命令的窗口不能关闭（至少openvpn进程不能结束）。</p><p>此时，如果执行</p><pre>ifconfig</pre><p>可以看到一个tun0网络接口，IP地址是10.8.0.1：</p><p><img src="http://chartbed.buretuzi.online/i/article/Linux%20%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF/OpenVPN1.jpg"></p><p>这说明服务器启动成功。</p><p>=================阶段二：客户端最简配置================</p><p>一、下载OpenVPN：</p><pre>sudo apt-get install openvpn</pre><p>二、证书与密钥：</p><p>OpenVPN客户端需要3个文件：ca.crt、client.crt和client.key。为了保证一致性，最好从服务器上复制过来。这三个文件在服务器上可以如下获得：</p><p>ca.crt：</p><pre>sudo cp /usr/share/doc/openvpn/examples/sample-keys/ca.crt ~</pre><p>必须与服务器的ca.crt保持一致。</p><p>client.crt：</p><pre>sudo gunzip -c /usr/share/doc/openvpn/examples/sample-keys/client.crt.gz &gt; ~/client.crt</pre><p>client.key：</p><pre>sudo cp /usr/share/doc/openvpn/examples/sample-keys/client.key ~</pre><p>把这三个文件拷贝到客户端的/etc/openvpn目录下。</p><p>三、编写客户端配置文件：</p><p>在客户端的/etc/openvpn下创建文件client.conf，编写内容如下：</p><pre>clientdev tunproto udpremote 192.168.1.100 1194ca ca.crtcert client.crtkey client.keyuser nobodygroup nogrouppersist-keypersist-tunverb 3</pre><p>其中第4行的IP地址需要根据改为你的服务器的IP地址。</p><p>其实该文件也可以由/usr/share/doc/openvpn/examples/sample-config-files/client.conf得到。每一行具体的意思可以查看其中的注释。</p><p>现在，/etc/openvpn目录下有4个文件：ca.crt、client.crt、client.key和client.conf。</p><pre>cd /etc/openvpnsudo openvpn --config client.conf</pre><p>执行该命令的窗口不能关闭（至少openvpn进程不能结束）。</p><p>如果输出“Initialization Sequence Completed”字样，说明OpenVPN成功连接：</p><p><img src="http://chartbed.buretuzi.online/i/article/Linux%20%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF/OpenVPN2.jpg"></p><p>此时，如果执行</p><pre>ifconfig</pre><p>可以看到一个tun0网络接口，IP地址是10.8.0.6（也可能是别的）：</p><p><img src="http://chartbed.buretuzi.online/i/article/Linux%20%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF/OpenVPN3.jpg"></p><p>如果执行命令：</p><pre>ping 10.8.0.1</pre><p>能够ping通的话，那么说明OpenVPN连接成功了～</p><p>这么一来，“OpenVPN配置很复杂“的传说就被破除啦！！</p><pre><code>        ﻿&lt;/div&gt;                    &lt;/article&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;footer id=&quot;colophon&quot; role=&quot;contentinfo&quot;&gt;            &lt;div id=&quot;site-generator&quot;&gt;&lt;/div&gt;            &lt;script src=&quot;../../../footer.js&quot;&gt;&lt;/script&gt;        &lt;/footer&gt;    &lt;/div&gt;</code></pre></body>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GHO还原系统</title>
      <link href="/2023/09/11/GHO%E8%BF%98%E5%8E%9F%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/09/11/GHO%E8%BF%98%E5%8E%9F%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><font color=#399ab2>完美解决 开机无法启动 提示0xc000000e</font></p><p><font color=#42b983>注：昨天装系统碰到这个问题，这个方法说的较详细，我的是WIN7系统，开机提示引导文件错误，代码为0xc000000e 无法进入系统，使用PE进入后，在运行里输入CMD，然后按下文红字开始操作</font><br>完美解决 开机无法启动 提示0xc000000e 问题</p><p>摘要：本文提供0xc000000e问题的解决方法和原理解释，保证完美修复启动菜单，启动菜单不会变成英文还是中文，且所有启动项都可以正常使用。</p><p>关键词：Windows Vista SP1 Ghost 开机 0xc000000e 无法 启动 不了</p><p>问题描述：</p><p>用 Ghost 还原镜像文件到C盘，第一次开机正常，重启后却出现黑底白字，提示语为：</p><p>File: \Windows\system32\winload.exe</p><p>Status: 0xc000000e</p><p>Info: The selected entry could not be loaded because the application is missing or corrupt.</p><p>解决方法：</p><p>注意：千万不要按提示用 Windows Vista SP1 的系统碟修复，不然启动菜单会变成英文，且无法改变成中文。而且只能修复 Windows Vista 这个启动项，不能修复 Windows XP 和 一键Ghost 等启动项。</p><p>　　用 Ghost 还原镜像文件到 C 盘后，如果第一次启动就进入 WinPE 的 CMD 输入“bcdedit &#x2F;v”，会显示“找不到配置文件”。应该启动一次系统，一切很正常，重启后就会出现 0xc000000e 错误提示，再使用WinPE光盘启动电脑，笔者使用雨林木风 Ghost XP 的光盘中的 WinPE 系统。具体操作：将光盘放入光驱，按Ctrl + Alt + Delete，重启电脑。如果默认情况下系统自动提示 Boot from CD&#x2F;DVD … ，请赶紧按回车键，出现的菜单选[B] WinPE，就进入到 WinPE。</p><p>WinPE 其实就是光盘版的 Windows XP。在桌面有一个CMD，双击进入后：<br><font color=#42b983>（1）输入“C:”，按回车键，转到C:盘。（注：不包含双引号，下同）</font></p><p><font color=#42b983>（2）输入“cd Windows”，转到C:\Windows。</font></p><p><font color=#42b983>（3）输入“cd system32”，转到C:\Windows\system32。</font></p><p><font color=#42b983>（4）输入“bcdedit &#x2F;v”，显示如下：</font></p><p>——————————————————————————————</p><p>Windows 启动管理器</p><hr><p>标识符              {9dea862c-5cdd-4e70-acc1-f32b344d4795}</p><p>device                  unknown</p><p>description             Windows Boot Manager</p><p>locale                  zh-CN</p><p>inherit                 {7ea2e1ac-2e61-4728-aaa3-896d9d0a9f0e}</p><p>default                 {6a0582e8-26b5-11de-aa82-fab9790f0327}</p><p>resumeobject            {6a0582e9-26b5-11de-aa82-fab9790f0327}</p><p>displayorder            {6a0582e8-26b5-11de-aa82-fab9790f0327}</p><pre><code>        &#123;dd4acb15-26b7-11de-920a-001f3c63388c&#125;</code></pre><p>toolsdisplayorder       {b2721d73-1db4-4c62-bf78-c548a880142d}</p><p>timeout                 2</p><p>Windows 启动加载器</p><hr><p>标识符              {6a0582e8-26b5-11de-aa82-fab9790f0327}</p><p>device                  unknown</p><p>path                    \Windows\system32\winload.exe</p><p>description             Microsoft Windows Vista</p><p>locale                  zh-CN</p><p>loadoptions             DDISABLE_INTEGRITY_CHECKS</p><p>inherit                 {6efb52bf-1766-41db-a6b3-0ee5eff72bd7}</p><p>osdevice                unknown</p><p>systemroot              \Windows</p><p>resumeobject            {6a0582e9-26b5-11de-aa82-fab9790f0327}</p><p>nx                      OptIn</p><p>vga                     No</p><p>quietboot               No</p><p>sos                     No</p><p>实模式启动扇区</p><hr><p>标识符              {dd4acb15-26b7-11de-920a-001f3c63388c}</p><p>device                  unknown</p><p>path                    \ghldr.mbr</p><p>description             一键GHOST v2008.08.08 奥运版</p><p>——————————————————————————————</p><p>注意看红色的“unknown”，我们要将这些“unknown”都更改成“partition&#x3D;C:”。操作如下：<br><font color=#42b983>（5）输入“bcdedit &#x2F;set {bootmgr} device partition&#x3D;C:”，按回车键，提示修改成功。</font></p><p><font color=#42b983>（6）输入“bcdedit &#x2F;set {default} device partition&#x3D;C:”，按回车键，提示修改成功。</font></p><p><font color=#42b983>（7）输入“bcdedit &#x2F;set {default} osdevice partition&#x3D;C:”，按回车键，提示修改成功。</font></p><p><font color=#42b983>（8）输入“bcdedit &#x2F;set {dd4acb15-26b7-11de-920a-001f3c63388c} device partition&#x3D;C:”，按回车键，提示修改成功。</font></p><p>（9）重启就可以正常进入系统了。</p><p>（10）网友 ryanxiao 提供：如有必要，加多一步修复引导。输入“BOOTSECT &#x2F;NT60 C:”，按回车键，提示修改成功。（本人还未亲自验证）</p><p>（注：昨天我也只是按照教材操作到第九步就可以了，第十步并没有操作）</p><p>原理解释：</p><p>　　导致问题的原因：使用了别的硬盘Ghost下来的镜像文件，导致bcdedit里面该赋值为“Partition&#x3D;C:”的全部变成了“unknown”</p><p>　　解决问题的方法：使用bcdedit &#x2F;set 设置命令，后加 {标识符} ，这里{boomgr}指的是“Windows 启动管理器”，{default}指的是默认的“Windows 启动加载器 Microsoft Windows Vista”， {dd4acb15-26b7-11de-920a-001f3c63388c}指的是“ 一键GHOST v2008.08.08 奥运版”（注：这个长符号按照自己的电脑上显示的输入），再加“device”或“osdevice”变量名，表示要给这个变量赋值，最后加 “Partition&#x3D;C:”，赋值。例如：“bcdedit &#x2F;set {bootmgr} device partition&#x3D;C:”</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>宝塔部署php项目</title>
      <link href="/2023/05/04/%E5%AE%9D%E5%A1%94%E9%83%A8%E7%BD%B2php%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/05/04/%E5%AE%9D%E5%A1%94%E9%83%A8%E7%BD%B2php%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="宝塔PHP网站数据迁移"><a href="#宝塔PHP网站数据迁移" class="headerlink" title="宝塔PHP网站数据迁移"></a>宝塔PHP网站数据迁移</h3><h4 id="第一步：进入网站管理界面"><a href="#第一步：进入网站管理界面" class="headerlink" title="第一步：进入网站管理界面"></a>第一步：进入网站管理界面</h4><p><img src="https://image.buretuzi.online/blog/article/linux/BT/php3.png"></p><h4 id="第二步：查看网站绑定的域名"><a href="#第二步：查看网站绑定的域名" class="headerlink" title="第二步：查看网站绑定的域名"></a>第二步：查看网站绑定的域名</h4><p><img src="https://image.buretuzi.online/blog/article/linux/BT/php5.jpg"></p><h4 id="第三步：进入域名DNS服务商（此处为腾讯云）"><a href="#第三步：进入域名DNS服务商（此处为腾讯云）" class="headerlink" title="第三步：进入域名DNS服务商（此处为腾讯云）"></a>第三步：进入域名DNS服务商（此处为腾讯云）</h4><p><img src="https://image.buretuzi.online/blog/article/linux/BT/php1.png"></p><p>在腾讯云对应域名下添加A记录（若为服务器迁移则更改对应域名记录指定的IP地址即可）</p><p><font color=red>说明：</font></p><p><font color=red>A记录: 解析地址为IP地址</font></p><p><font color=red>CNAME记录: 解析的地址为另一个域名，即: 域名 -&gt; 域名 -&gt; IP地址 （可多级嵌套）</font></p><p><img src="https://image.buretuzi.online/blog/article/linux/BT/php2.png"></p><h4 id="第四步：进入网站根目录（-x2F-www-x2F-wwwroot-）"><a href="#第四步：进入网站根目录（-x2F-www-x2F-wwwroot-）" class="headerlink" title="第四步：进入网站根目录（ &#x2F;www&#x2F;wwwroot ）"></a>第四步：进入网站根目录（ &#x2F;www&#x2F;wwwroot ）</h4><p><img src="https://image.buretuzi.online/blog/article/linux/BT/php4.png"></p><p>将对应网站目录右键压缩，下载，然后部署到新服务器网站根目录下(&#x2F;www&#x2F;wwwroot)</p><h4 id="第五步：数据库迁移"><a href="#第五步：数据库迁移" class="headerlink" title="第五步：数据库迁移"></a>第五步：数据库迁移</h4><p>将数据库备份，并下载到本地</p><p><img src="https://image.buretuzi.online/blog/article/linux/BT/php6.png"></p><p>在新服务器上进入phpMyAdmin</p><p><img src="https://image.buretuzi.online/blog/article/linux/BT/php7.png"></p><p>创建对应数据库（相同数据库名）</p><p>进入刚创建的数据库下，右侧SQL，将本地下载的数据库备份文件 xxx.sql 中内容复制粘贴并 执行</p><h4 id="第六步：添加对应站点"><a href="#第六步：添加对应站点" class="headerlink" title="第六步：添加对应站点"></a>第六步：添加对应站点</h4><p><img src="https://image.buretuzi.online/blog/article/linux/BT/php8.jpg"></p><p>域名为在DNS服务商处添加的记录：xxx.域名<br>xxx 为记录名<br>配置数据根目录后网站迁移完毕</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宝塔Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM调优案例分析(4)</title>
      <link href="/2022/08/18/JVM%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90(4)/"/>
      <url>/2022/08/18/JVM%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90(4)/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>前面三篇介绍了处理Java虚拟机内存问题的知识与工具，在处理实际项目的问题 时，除了知识与工具外，经验也是一个很重要的因素。因此本章将与读者分享几个比较 有代表性的实际案例。考虑到虚拟机故障处理和调优主要面向各类服务端应用，而大部 分Java程序员较少有机会直接接触生产环境的服务器，因此本章还准备了一个所有开发人员都能够进行“亲身实战”的练习，希望通过实践使读者获得故障处理和调优的经验。</p><h1 id="2-案例分析"><a href="#2-案例分析" class="headerlink" title="2. 案例分析"></a>2. 案例分析</h1><p>本章中的案例大部分来源于处理过的一些问题，还有一小部分来源于网上有特色和代表性的案例总结。出于对客户商业信息保护的目的，在不影响前后逻辑的前提 下，笔者对实际环境和用户业务做了一些屏蔽和精简。</p><h2 id="2-1-高性能硬件上的程序部署策略"><a href="#2-1-高性能硬件上的程序部署策略" class="headerlink" title="2.1 高性能硬件上的程序部署策略"></a>2.1 高性能硬件上的程序部署策略</h2><p>一个15万PV&#x2F;天左右的在线文档类型网站最近更换了硬件系统，新的硬件为4个CPU、16GB物理内存，操作系统为64位CentOS 5.4, Resin作为Web服务器。整个 服务器暂时没有部署别的应用，所有硬件资源都可以提供给访问量并不算太大的网站使 用。管理员为了尽量利用硬件资源选用了 64位的JDK 1.5,并通过-Xmx和-Xms参数 将Java堆固定在12GB。使用一段时间后发现使用效果并不理想，网站经常不定期出现 长时间没有响应的现象。</p><p>  监控服务器运行状况后发现网站没有响应是由GC停顿导致的，虚拟机运行在 Server模式，默认使用吞吐量优先收集器，回收12GB的堆，一次Full GC的停顿时间 高达14秒。并且由于程序设计的关系，访问文档时要把文档从磁盘提取到内存中，导 致内存中出现很多由文档序列化产生的大对象，这些大对象很多都进入了老年代，没有 在Minor GC中清理掉。这种情况下即使有12GB的堆，内存也很快会被消耗殆尽，由 此导致每隔十几分钟出现十几秒的停顿，令网站开发人员和管理员感到很沮丧。</p><p>  这里先不延伸讨论程序代码问题，程序部署上的主要问题显然是过大的堆内存进行 回收时带来的长时间的停顿。硬件升级前使用32位系统1.5GB的堆，用户只感到访问 网站比较缓慢，但不会发生十分明显的停顿，因此才考虑升级硬件提升程序效能，如果 重新缩小给Java堆分配的内存，那么硬件上的投资就浪费了。</p><p>  在高性能硬件上部署程序，目前主要有两种方式：</p><ul><li>通过64位JDK来使用大内存。</li><li>使用若干个32位虚拟机建立逻辑集群来利用硬件资源。</li></ul><p>  此案例中的管理员采用了第一种部署方式。对于用户交互性强、对停顿时间敏感的 系统，可以给Java虚拟机分配超大堆的前提是有把握把应用程序的Full GC频率控制得足够低，至少要低到不会影响用户使用，譬如十几个小时乃至一天才出现一次Full GC, 这样可以通过在深夜执行定时任务的方式触发Full GC甚至自动重启应用服务器来将内存可用空间保持在一个稳定的水平。</p><p>  控制Full GC频率的关键是看应用中绝大多数对象能否符合“朝生夕灭”的原则， 即大多数对象的生存时间不应当太长，尤其是不能产生成批量的、长生存时间的大对 象，这样才能保障老年代空间的稳定。</p><p>  在大多数网站形式的应用里，主要对象的生存周期都应该是请求级或页面级的， 会话级和全局级的长生命对象相对很少。只要代码写得合理，应当都能实现在超大堆中正常使用而没有Full GC,这样的话，使用超大堆内存时，网站响应的速度才比较有保证。除此之外，如果计划使用64位JDK来管理大内存，还需要考虑下面可能面临的问题：</p><ul><li>内存回收导致的长时间停顿</li><li>现阶段，64位JDK的性能测试接结果普遍低于32位JDK</li><li>需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快 照（因为要产生十几GB乃至更大的dump文件），哪怕产生了快照也几乎无法进 行分析。</li><li>相同的程序在64位JDK中消耗的内存一般比32位JDK大，这是由指针膨胀及数据类型对齐补白等因素导致的。</li></ul><p>  上面的问题听起来有点吓人，所以现阶段不少管理员还是选择第二种方式：使用若 干个32位虚拟机建立逻辑集群来利用硬件资源。具体做法是在一台物理机器上启动多 个应用服务器进程，给每个服务器进程分配不同的端口，然后在前端搭建一个负载均衡 器，以反向代理的方式来分配访问请求。读者不需要太在意均衡器转发所消耗的性能, 即使使用64位JDK,许多应用也不止有一台服务器，因此在许多应用中前端的均衡器 总是要存在的。</p><p>  考虑到在一台物理机器上建立逻辑集群的目的仅仅是尽可能地利用硬件资源，并不 需要关心状态保留、热转移之类的高可用性需求，也不需要保证每个虚拟机进程有绝对 准确的均衡负载，因此使用无Session复制的亲合式集群是一个相当不错的选择。我们 仅仅需要保障集群具备亲和性，也就是均衡器按一定的规则算法（一般根据SessionlD 分配）将一个固定的用户请求永远分配到固定的一个集群节点进行处理即可，这样程序开发阶段就基本不用为集群环境做什么特别的考虑。</p><p>  当然，很少有没有缺点的方案，如果读者计划使用逻辑集群的方式来部署程序，可 能会遇到下面一些问题：</p><ul><li>尽量避免节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问 某个磁盘文件的话（尤其是并发写操作容易出现问题），很容易导致IO异常。</li><li>很难最高效率地利用某些资源池，譬如连接池，一般都是在各个节点建立自己 独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余。尽管可以使用集中式的JNDI,但这有一定的复杂性并且可能带来额外的 性能代价。</li><li>大量使用本地缓存（如大量使用HashMap作为K&#x2F;V缓存）的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点上都有一份緩存，这时可以考虑把 本地缓存改为集中式缓存。</li><li>各个节点仍然不可避免地受到32位的内存限制，在32位Windows平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆一般最多只能开到1.5GB。在某些Linux, Unix系统（如Solaris）中，可以提升到3GB乃至接近4GB的内存，但32位中仍然受最高4GB （232）内存的限制。</li></ul><p>  介绍完这两种部署方式，再重新回到这个案例之中，最后的部署方案调整为建立5个32位JDK的逻辑集群，每个进程按2GB内存计算（其中堆固定为1.5GB）,占用了 10GB的内存。另外建立一个Apache服务作为前端均衡代理访问门户。考虑到用户对响 应速度比较关心，并且文档服务的主要压力集中在磁盘和内存访问上，CPU资源敏感度 较低，因此改为CMS收集器进行垃圾回收。部署方式调整后，服务再没有出现长时间 停顿，速度比硬件升级前有较大提升。</p><h2 id="2-2-集群间同步导致的内存溢出"><a href="#2-2-集群间同步导致的内存溢出" class="headerlink" title="2.2 集群间同步导致的内存溢出"></a>2.2 集群间同步导致的内存溢出</h2><p>  一个基于B&#x2F;S的MIS系统，硬件为两台2个CPU、8GB内存的HP小型机，服务器 是WebLogic 9.2,每台机器启动了 3个WebLogic实例，构成一个6个节点的亲合式集 群。由于是亲合式集群，节点之间没有进行Session同步，但是有一些需求要实现部分 数据在各个节点间共享。开始这些数据存放在数据库中，但由于读写频繁竞争很激烈， 对性能的影响较大，后面使用JBossCache构建了一个全局缓存。全局缓存启用后，服务 正常使用了较长的一段时间。但最近不定期地多次出现内存溢出问题。</p><p>  在不出现内存溢出异常的时候，服务内存回收状况一直正常，每次内存回收后都能 恢复到一个稳定的可用空间，开始怀疑是程序的某些不常用的代码路径中存在内存泄 漏，但管理员反映最近程序并未更新或升级过，也没有进行什么特别的操作。只好让服 务带着-XX:+HeapDumpOnOutOfMemoryEiror参数运行了一段时间。在最近一次溢出之 后，管理员发回了 heapdump文件，发现里面存在着大量的org.jgroups.protocols.pbcast. NAKACK 对象。</p><p>  JBossCache是基于自家的JGroups进行集群间的数据通信，JGroups使用协议栈的方式来实现收发数据包的各种所需特性的自由组合，数据包接收和发送时要经过每层协议栈的up（）和down（）方法，其中的NAKACK栈用于保障各个包的有效顺序及重发，JBossCache的协议栈如图5-1所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90(4)%EF%BC%881%EF%BC%89.png"></p><p>  由于信息有传输失败需要重发的可能性，在确认所有注册在GMS (Group Membership Service)的节点都收到正确的信息前，发送的信息必须在内存中保留。而 此MIS的服务端中有一个负责安全校验的全局Filter,每当接收到请求时，均会更新一 次最后的操作时间，并且将这个时间同步到所有的节点中，使得一个用户在一段时间内 不能在多台机器上登录。在服务使用过程中，往往一个页面会产生数次乃至数十次的请 求，因此这个过滤器导致集群各个节点之间的网络交互非常频繁。当网络情况不能满足 传输要求时，重发数据在内存中不断地堆积，很快就产生了内存溢出。</p><p>  这个案例中的问题，既有JBossCache的缺陷，也有MIS系统实现方式上的缺陷。 JBossCache官方的maillist中讨论过很多次类似的内存溢出异常问题，据说后续版本有 了改进。而更重要的缺陷是这一类被集群共享的数据如果要使用类似JBossCache这种集群缓存来同步的话，可以允许读操作频繁，因为数据在本地内存有一份副本，读取的动 作不会耗费多少资源，但不应当有过于频繁的写操作，这会带来很大的网络同步的开销。</p><h2 id="2-3-堆外内存导致的溢出错误"><a href="#2-3-堆外内存导致的溢出错误" class="headerlink" title="2.3 堆外内存导致的溢出错误"></a>2.3 堆外内存导致的溢出错误</h2><p>这是一个学校的小型项目：基于B&#x2F;S的电子考试系统，为了实现客户端能实时地从服务端接收考试数据，系统使用了逆向AJAX技术（也成为Comet或Server Side Push），选用CometD 1.1.1 作为服务器推送框架，服务器是jetty 7.4.1，硬件为一台普通PC机，Core i5 CPU，4GB内存，运行32位Windows操作系统。</p><p>  测试期间发现服务端不定时拋出内存溢出异常，服务器不一定每次都会出现异常， 但假如正式考试时崩溃一次，那估计整场电子考试都会乱套，网站管理员尝试过把堆开 到最大，32位系统最多到1.6GB基本无法再加大了，而且开大了也基本没效果，抛出内 存溢出异常好像更加频繁了。加入-XXi+HeapDumpOnOutOfMemoryError,居然也没有 任何反应，抛出内存溢出异常时什么文件都没有产生。无奈之下只好挂着jstat使劲盯屏 幕，发现GC并不频繁，Eden区、Survivor区、老年代及永久代内存全部都表示“情绪 稳定，压力不大”，但照样不停地抛出内存溢出异常，管理员压力很大。最后，在内存 溢出后从系统日志中找到异常堆栈，如代码清单5-1所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90(4)%EF%BC%882%EF%BC%89.png"></p><p>  如果认真阅读过本书的第2章，看到异常堆栈就应该清楚这个内存溢出异常是怎么回事了。大家知道操作系统对每个进程能管理的内存是有限制的，这台服务器使用 的32位Windows平台的限制是2GB,其中给了 Java堆1.6GB,而Direct Memory并不算在1.6GB的堆之内，因此它只能在剩余的0.4GB空间中分出一部分。在此应用中导致溢出的关键是：垃圾收集进行时，虚拟机虽然会对Direct Memory进行回收，但 是Direct Memory却不能像新生代和老年代那样，发现空间不足了就通知收集器进行 垃圾回收，它只能等待老年代满了后Full GC,然后“顺便地”帮它清理掉内存的废弃 对象。否则，它只能等到抛出内存溢出异常时，先catch掉，再在catch块里面“大喊” 一声：“System.gc。！ ”。要是虚拟机还是不听(譬如打开了-XX:+DisableExplicitGC 开关)，那就只能眼睁睁地看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异 常了。而本案例中使用的CometD 1.1.1框架，正好有大量的NIO操作需要用到Direct Memory。</p><p>  从实践的角度来讲，除了Java堆和永久代之外，我们注意到下面这些区域还会占用较多的内存，这里所有的内存总和会受到操作系统进程最大内存的限制。</p><ul><li>Direct Memory :可通过-XX:MaxDirectMemorySize调整大小，内存不足时抛出 OutOfMemoryError 或 OutOfMemoryError: Direct buffer memory „</li><li>线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError (纵向无 法分配，即无法分配新的栈帧)或 OutOfMemoryError: unable to create new native thread (横向无法分配，即无法建立新的线程)。</li><li>Socket缓存区：每个Socket连接都Receive和Send两个缓存区，分别占大约 37KB和25KB的内存，连接多的话这块内存占用也比较可观。如果无法分配， 则可能会抛出 lOException: Too many open files 异常。</li><li>JNI代码：如果代码中使用JNI调用本地库，那本地库使用的内存也不在堆中。</li><li>虚拟机和GC：虚拟机和GC的代码执行也要消耗一定的内存。</li></ul><h2 id="2-4-外部命令导致系统缓慢"><a href="#2-4-外部命令导致系统缓慢" class="headerlink" title="2.4 外部命令导致系统缓慢"></a>2.4 外部命令导致系统缓慢</h2><p>这是一个来自网络的案例：一个数字校园应用系统，运行在一台4个CPU的 Solaris 10操作系统上，中间件为GlassFish服务器。系统在进行大并发压力测试的时 候，发现请求响应时间比较慢，通过操作系统的mpstat 工具发现CPU使用率很高，并 且占用绝大多数CPU资源的程序并不是应用系统本身。这是个不正常的现象，通常情况 下用户应用的CPU占用率应该占主要地位，才能说明系统是正常工作的。</p><p>  通过Solaris 10的Dtrace脚本可以査看当前情况下哪些系统调用花费了最多的CPU 资源，Dtrace运行后发现最消耗CPU资源的竟然是“fork”系统调用。众所周知，“fork” 系统调用是Linux用来产生新进程的，在Java虚拟机中，用户编写的Java代码最多只 有线程的概念，不应当有进程的产生。</p><p>  这是个非常异常的现象。通过本系统的开发人员最终找到了答案：每个用户请求的 处理都需要执行一个外部shell脚本来获得系统的一些信息。执行这个shell脚本是通过 Java的Runtime.getRuntime().exec()方法来调用的。这种调用方式可以达到目的，但是 它在Java虚拟机中非常消耗资源，即使外部命令本身能很快执行完毕，频繁调用时创 建进程的开销也非常可观。Java虚拟机执行这个命令的过程是：首先克隆一个和当前虚 拟机拥有一样环境变量的进程，再用这个新的进程去执行外部命令，最后再退出这个进程。如果频繁执行这个操作，系统的消耗会很大，不仅是CPU,内存的负担也很重。用户根据建议去掉这个shell脚本执行的语句，改为使用Java的API去获取这些信息后，系统很快就恢复了正常。</p><h2 id="2-5-服务器JVM进程崩溃"><a href="#2-5-服务器JVM进程崩溃" class="headerlink" title="2.5 服务器JVM进程崩溃"></a>2.5 服务器JVM进程崩溃</h2><p>一个基于B&#x2F;S的MIS系统，硬件为两台2个CPU、8GB内存的HP系统，服务器是 WebLogic 9.2 (就是第二个案例中的那套系统)。正常运行一段时间后，最近发现在运行 期间频繁出现集群节点的虚拟机进程自动关闭的现象，留下了一个hs_err_pid###.log文 件后，进程就消失了，两台物理机器里的每个节点都出现过进程崩溃的现象。从系统日 志中注意到，每个节点的虚拟机进程在崩溃前不久，都发生过大量相同的异常，见代码 清单5-2。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90(4)%EF%BC%883%EF%BC%89.png"></p><p>  这是一个远端断开连接的异常，通过系统管理员了解到系统最近与一个OA门户做了集成，在MIS系统工作流的待办事项变化时，要通过Web服务通知OA门户系 统，把待办事项的变化同步到OA门户之中。通过SoapUI测试了一下同步待办事项的 几个Web服务，发现调用后竟然需要长达3分钟才能返回，并且返回的结果都是连接 中断。</p><p>  由于MIS系统的用户多，待办事项变化很快，为了不被OA系统的速度拖累，使用了异步的方式调用Web服务，但由于两边服务的速度完全不对等，时间越长就累积了越多Web服务没有调用完成，导致在等待的线程和Socket连接越来越多，最终超过虚拟 机的承受能力后使得虚拟机进程崩潰。通知OA门户方修复无法使用的集成接口，并将异步调用改为生产者&#x2F;消费者模式的消息队列实现后，系统恢复正常。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM虚拟机性能监控与故障处理工具(3)</title>
      <link href="/2022/08/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)/"/>
      <url>/2022/08/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>经过前面两章对于虚拟机内存分配与回收技术各方面的介绍，相信读者已经建立了 一个比较完整的理论基础。理论总是作为指导实践的工具，能把这些知识投入到实际工 作中才是我们的最终目的。接下来的两章，我们将从实践的角度去了解虚拟机内存管理 的世界。</p><p>  给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用 知识处理数据的手段。这里说的数据包括：运行日志、异常堆栈、GC日志、线程快照 (threaddump &#x2F; javacore文件)、堆转储快照(heapdump &#x2F; hprof文件)等。经常使用适当 的虚拟机监控和分析的工具可以加快我们分析数据和定位解决问题的速度，但我们在学 习工具前，也应当意识到工具永远都是知识技能的一层包装，没有什么工具是“秘密武 器”，学会了就能包治百病。</p><h1 id="2-JDK的命令行工具"><a href="#2-JDK的命令行工具" class="headerlink" title="2. JDK的命令行工具"></a>2. JDK的命令行工具</h1><p>  Java开发人员肯定都知道JDK的bin目录中有“java.exe”和“javac.exe”这两个</p><p>  命令行工具，但并非所有程序员都了解过JDK的bin目录之中其他命令行程序的作用。 每逢JDK更新版本之时，bin目录下命令行工具的数量和功能总会不知不觉地增加和增 强，bin目录的内容如图4-1所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%881%EF%BC%89.png"></p><center>图 4-1</center><p>  在本章中，笔者将介绍这些工具的其中一部分，主要是用于监视虚拟机和故障处理的工具。这些故障处理工具被Sun公司作为“礼物”附赠给JDK的使用者，在软件的使用说明中把它们声明为“没有技术支持并且是实验性质的”(unsupported and experimental) ®的产品，但事实上这些工具都非常稳定而且功能强大，能在处理应用程序性能问题、定位故障时发挥很大的作用。</p><p>  说起JDK的工具，读者如果比较细心的话，可能会注意到这些工具的程序体积都异常的小。假如以前没注意到，现在不妨再看看图4-1中的最后一列“大小”，各个工具的 体积基本上都稳定在27KB左右。并非JDK开发团队刻意把它们制作得如此精炼来炫耀。</p><p>  假如读者使用的是Linux版本的JDK,还会发现这些工具中很多甚至就是由Shell 脚本直接写成的，可以用vim直接打开它们。</p><p>  JDK开发团队选择采用Java代码来实现这些监控工具是有特别用意的:当应用程序部署到生产环境后，无论是直接接触物理服务器还是远程Telnet到服务器上都可能会受到限制。借助tools.jar类库里面的接口，我们可以直接在应用程序中实现功能强大的监控分析功能。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%882%EF%BC%89.png"></p><p>  需要特别说明的是，本章介绍的工具全部基于Windows平台下的JDK 1.6 ,如果JDK版本、操作系统不同，工具所支持的功能可能会有较大差别。大部分工具在JDK 1.5中就已经提供，但为了避免运行环境带来的差异和兼容性问题，建议使用JDK 1.6来验证本章介绍的内容，因为JDK 1.6的工具可以正常兼容运行于 JDK 1.5的虚拟机之上的程序，反之则不一定。表4-1中列举了 JDK主要命令行监控 工具的用途。</p><p>  注意 如果读者在工作中需要监控运行于JDK 1.5的虚拟机之上的程序，在程序启动时 请添加参数”-Dcom.sun.management.jmxremote”开启JMX管理功能，否则由于部分工具都是基于JMX的(包括下一节的可视化工具)，因此它们都将会无法使用，如果被监控程序运行于JDK 1.6的虚拟机之上，那JMX管理默认是开启的，虚拟机启动时无须再添加任何参数。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%883%EF%BC%89.png"></p><h2 id="2-1-jps-虚拟机进程状况工具"><a href="#2-1-jps-虚拟机进程状况工具" class="headerlink" title="2.1 jps :虚拟机进程状况工具"></a>2.1 jps :虚拟机进程状况工具</h2><p>JDK的很多小工具的名字都参考了 Unix命令的命名方式，jps (JVM Process Status Tool)是其中的典型。除了名字像Unix的ps命令之外，它的功能也和ps命令类似：可 以列出正在运行的虚拟机进程，并显示虚拟机执行主类(Main Class, main。函数所在 的类)的名称，以及这些进程的本地虚拟机的唯一 ID (LVMID, Local Virtual Machine Identifier)。虽然功能比较单一,但它是使用频率最高的JDK命令行工具，因为其他的 JDK工具大多须要输入它査询到的LVMID来确定要监控的是哪一个虚拟机进程。对于 本地虚拟机进程来说，LVMID与操作系统的进程ID (PID, Process Identifier)是一致的，</p><p>  使用Windows的任务管理器或Unix的ps命令也可以査询到虚拟机进程的LVMID,但 如果同时启动了多个虚拟机进程，无法根据进程名称定位时，那就只能依赖jps命令显示主类的功能才能区分了。  </p><p>  jps [ options ] [ hostid ]</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%884%EF%BC%89.png"></p><p>  jps可以通过RMI协议査询开启了 RMI服务的远程虚拟机进程状态，hostid为RMI 注册表中注册的主机名。jps的其他常用选项见表4-2。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%885%EF%BC%89.png"></p><h2 id="2-2-jstat-虚拟机统计信息监视工具"><a href="#2-2-jstat-虚拟机统计信息监视工具" class="headerlink" title="2.2 jstat:虚拟机统计信息监视工具"></a>2.2 jstat:虚拟机统计信息监视工具</h2><p>jstat (JVM Statistics Monitoring Tool)是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或远程’虚拟机进程中的类装载、内存、垃圾收集、JIT编译等 运行数据,在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。</p><p>  jstat命令格式为：</p><p>  jstat [ option vmid [interval[s|ms] [count]]]</p><p>  对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程， VMID与LVMID是一致的，如果是远程虚拟机进程，那VMID的格式应当是：</p><p>  [protocol:）[&#x2F;&#x2F;]Ivmid[@hostname[:port]&#x2F;servername]</p><p>参数interval和count代表査询间隔和次数，如果省略这两个参数，说明只査询一 次。假设需要每250毫秒査询一次进程2764垃圾收集的状况，一共査询20次，那命令应当是：</p><p>  jstat -gc 2764 250 20</p><p>  选项option代表着用户希望査询的虚拟机信息，主要分为3类：类装载、垃圾收集和运行期编译状况，具体选项及作用请参考表4-3中的描述。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%886%EF%BC%89.png"></p><p>  jstat监视选项众多，由于版面原因无法逐一演示，这里仅举一例监视一台刚刚启动 的GlassFish v3服务器的内存状况的例子来演示如何査看监视结果。监视参数与输出结 果如代码清单4-1所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%887%EF%BC%89.png"></p><p>  査询结果表明：这台服务器的新生代Eden区（E,表示Eden）使用了 6.2%的空间，两个Survivor区（S0、S1,表示Survivor0. Survivor1）里面都是空的，老年代（O, 表示Old）和永久代（P,表示Permanent）则分别使用了 41.42%和47.20%的空间。程序运行以来共发生Minor GC （YGC,表示Young GC） 16次，总耗时0.105秒，发生 Full GC （FGC,表示 Full GC） 3 次，Full GC 总耗时（FGCT,表示 Full GC Time）为 0.472秒，所有GC总耗时（GCT,表示GC Time）为0.577秒。</p><p>  使用jstat工具在纯文本状态下监视虚拟机状态的变化，确实不如后面将会提到的 VisualVM等可视化的监视工具直接以图表展现的那样直观。但许多服务器管理员都习惯了在文本控制台中工作，直接在控制台中使用jstat命令依然是一种常用的监控 方式。</p><h2 id="2-3-jinfo-Java配置信息工具"><a href="#2-3-jinfo-Java配置信息工具" class="headerlink" title="2.3 jinfo : Java配置信息工具"></a>2.3 jinfo : Java配置信息工具</h2><p>jinfo （Configuration Info for Java）的作用是实时地査看和调整虚拟机的各项参数。 使用jps命令的-V参数可以査看虚拟机启动时显式指定的参数列表，但如果想知道未被 显式指定的参数的系统默认值，除了去找资料外，就只能使用jinfo的-flag选项进行査 询了（如果只限于JDK 1.6或以上版本的话，使用java -XX:+PrintFlagsFinal査看参数 默认值也是一个很好的选择），jinfo还可以使用-sysprops选项把虚拟机进程的System. getProperties（）的内容打印出来。这个命令在JDK 1.5时期已经随着Linux版的JDK发 布，当时只提供了信息査询的功能，JDK 1.6之后，jinfo在Windows和Linux平台都有 提供，并且加入了运行期修改参数的能力，可以使用-flag [+|-]name或-flag name&#x3D;value 修改一部分运行期可写的虚拟机参数值。JDK 1.6中，jinfo对于Windows平台的功能仍 然有较大的限制，只提供了最基本的-flag选项。</p><p>  jinfo命令格式：</p><p>  jinfo [ option ] pid</p><p>  执行样例：査询 CMSInitiatingOccupancyFraction 参数值。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%888%EF%BC%89.png"></p><h2 id="2-4-jmap-Java内存映像工具"><a href="#2-4-jmap-Java内存映像工具" class="headerlink" title="2.4 jmap : Java内存映像工具"></a>2.4 jmap : Java内存映像工具</h2><p>jmap （Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或 dump文件）。如果不使用jmap命令，要想获取Java堆转储快照还有一些比较“暴力”</p><p>  的手段：譬如在第2章中用过的-XX:+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，通过-XX:+HeapDumpOnCtrlBreak参 数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件，又或者在Linux系统下通过 Kill -3命令发送进程退出信号“恐吓” 一下虚拟机，也能拿到dump文件。</p><p>  jmap的作用并不仅仅是为了获取dump文件，它还可以査询finalize执行队列，Java 堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。</p><p>  和jinfo命令一样，jmap有不少功能在Windows平台下都是受限的，除了生成 dump文件的-dump选项和用于査看每个类的实例、空间占用统计的-histo选项所有操 作系统都提供之外，其余选项都只能在Linux &#x2F; Solaris下使用。</p><p>  jmap命令格式：</p><p>  jmap [ option ] vmid</p><p>  option选项的合法值与具体含义如表4-4所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%889%EF%BC%89.png"></p><p>  代码清单4-2是使用jmap生成一个正在运行的Eclipse的dump快照文件的例子, 例子中的3500是通过jps命令査询到的LVMID.</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8810%EF%BC%89.png"></p><h2 id="2-5-jhat：虚拟机堆转储快照分析工具"><a href="#2-5-jhat：虚拟机堆转储快照分析工具" class="headerlink" title="2.5 jhat：虚拟机堆转储快照分析工具"></a>2.5 jhat：虚拟机堆转储快照分析工具</h2><p>Sun JDK 提供 jhat (JVM Heap Analysis Tool)命令与 jmap 搭配使用，来分析 jmap 生成的堆转储快照。jhat内置了一个微型的https&#x2F;HTML服务器，生成dump文件的分析结果后，可以在浏览器中査看。不过实事求是地说，在实际工作中，除非笔者手上真 的没有别的工具可用，否则一般都不会去直接使用jhat命令来分析dump文件，主要原 因有二：一是一般不会在部署应用程序的服务器上直接分析dump文件，即使可以这样 做，也会尽量将dump文件拷贝到其他机器’上进行分析，因为分析工作是一个耗时而 且消耗硬件资源的过程，既然都要在其他机器上进行，就没必要受到命令行工具的限制 To另外一个原因是jhat的分析功能相对来说比较简陋，后文将会介绍到的VisualVM, 以及专业用于分析 dump 文件的 Eclipse Memory Analyzer, IBM HeapAnalyzer®等工具， 都能实现比jhat更强大更专业的分析功能。代码清单4-3演示了使用jhat分析上一节采 用jmap生成的Eclipse IDE的内存快照文件。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8811%EF%BC%89.png"></p><p>  屏幕显示Server is ready.的提示后,用户在浏览器中键入<a href="https://localhost:7000/">https://localhost:7000/</a> 就可以看到分析结果，如图4-3所示。</p><p>  分析结果默认以包为单位进行分组显示，分析内存泄漏问题主要会使用到其中的 “Heap Histogram”(与jmap-histo功能一样)与OQL页签的功能，前者可以找到内存中总容量最大的对象，后者是标准的对象査询语言，使用类似SQL的语法对内存中的对象 进行査询统计。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8812%EF%BC%89.png"></p><h2 id="2-6-jstack-Java堆栈跟踪工具"><a href="#2-6-jstack-Java堆栈跟踪工具" class="headerlink" title="2.6 jstack : Java堆栈跟踪工具"></a>2.6 jstack : Java堆栈跟踪工具</h2><p>jstack (Stack Trace for Java)命令用于生成虚拟机当前时刻的线程快照(一般称为 threaddump或javacore文件)。线程快照就是当前虚拟机内每一条线程正在执行的方法 堆栈的集合,生成线程快照的主要目的是定位线程出现长时间停顿的原因,如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。 线程出现停顿的时候通过jstack来査看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源。</p><p>  jstack命令格式：</p><p>  jstack [option ] vmid</p><p>  option选项的合法值与具体含义如表4-5所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8813%EF%BC%89.png"></p><p>  代码清单4-4是使用jstack査看Eclipse线程堆栈的例子，例子中的3500是通过jps 命令査询到的LVMID</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8814%EF%BC%89.png"></p><p>  在 JDK 1.5 中，java.lang.Thread 类新增了一个 getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码就完成jstack的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来査看线程堆栈，如代码清单4-5所示，这是笔者的一个小经验。<br> <br><img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8815%EF%BC%89.png"></p><h1 id="3-JDK的可视化工具"><a href="#3-JDK的可视化工具" class="headerlink" title="3. JDK的可视化工具"></a>3. JDK的可视化工具</h1><p>  JDK中除了提供大量的命令行工具外，还有两个功能强大的可视化工具：JConsole 和VisualVM,这两个工具是JDK的正式成员，没有被贴上”unsupported and experimental”的标签。</p><p>  其中JConsole是在JDK 1.5时期就已经提供的虚拟机监控工具，而VisualVM在 JDK 1.6 Update7中才首次发布，现在已经成为Sun (Oracle)主力推动的多合一故障处理工具。并且已经从JDK中分离出来成为可以独立发展的开源项目。</p><p>  为了避免本节的讲解成为对软件说明文档的简单翻译，笔者准备了一些代码样例， 都是笔者特意编写的反面教材。后面将会使用两款工具去监控和分析这几段代码存在的 问题，算是本节简单的实战分析。可以把在可视化工具上观察到的数据和现象与前面两章中讲解的理论知识互相印证。</p><h2 id="3-1-JConsole-Java监视与管理控制台"><a href="#3-1-JConsole-Java监视与管理控制台" class="headerlink" title="3.1 JConsole : Java监视与管理控制台"></a>3.1 JConsole : Java监视与管理控制台</h2><p>JConsole (Java Monitoring and Management Console)是一款基于 JMX 的可视化监视和管理的工具。它管理部分的功能是针对JMX MBean进行管理，由于MBean可以使用代码、中间件服务器的管理控制台或者所有符合JMX规范的软件进行访问，所以本 节中将会着重介绍JConsole监视部分的功能。</p><h3 id="（1）启动-JConsole"><a href="#（1）启动-JConsole" class="headerlink" title="（1）启动 JConsole"></a>（1）启动 JConsole</h3><p>通过JDK&#x2F;bin目录下的“jconsole.exe”启动JConsole后，将自动搜索出本机运行的 所有虚拟机进程，不需要用户自己再使用jps来査询了，如图4-4所示。双击选择其中 一个进程即可开始监控，也可以使用下面的“远程进程”功能来连接远程服务器，对远 程虚拟机进行监控。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8816%EF%BC%89.png"></p><center>图 4-4</center><p>  从图4-4中可以看到笔者的机器现在运行了一共三个本地虚拟机进程。双击任意一个进入JConsole主界面，可以看到主界面里共包括“概述”、’‘内存”、”线程”、 “类”、-VM摘要”和“MBean”六个页签，如图4-5所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8817%EF%BC%89.png"></p><center>图 4-5</center><p>  “概述”页签显示的是整个虚拟机主要运行数据的概览，其中包括“堆内存使用情 况”、’‘线程”、”类”、“CPU使用情况”四项信息的曲线图，这些曲线图是后面“内存”、“线程”、”类”页签的信息汇总，具体内容将在后面介绍。</p><h3 id="（2）内存监控"><a href="#（2）内存监控" class="headerlink" title="（2）内存监控"></a>（2）内存监控</h3><p>“内存”页签相当于可视化的jstat命令，用于监视受收集器管理的虚拟机内存 （Java堆和永久代）的变化趋势。我们通过运行代码清单4-6中的代码来体验一下它的 监视功能。运行时设置的虚拟机参数为：-Xms100m -Xmx100  m -XX:+UseSerialGC,这 段代码的作用是以64KB&#x2F;50毫秒的速度往Java堆中填充数据，一共填充1000次，使用 JConsole的“内存”页签进行监视，观察曲线和柱状指示图的变化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] placeholder = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">64</span>*<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fillHeap</span><span class="params">(<span class="type">int</span> nun)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nun; i++)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">OOMObject</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        fillHeap(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  程序运行后，在“内存”页签中可以看到内存池Eden区的运行趋势呈现折线状， 如图4-6所示。而监视范围扩大至整个堆后，会发现曲线是一条向上增长的平滑曲线。 并且从柱状图可以看到，在1000次循环执行结束，运行了 System.gc()后，虽然整个新生代Eden和Survivor区都基本被清空了，但是代表老年代的柱状图仍然保持峰值状态， 说明被填充进堆中的数据在System.gc()方法执行之后仍然存活着。分析就到此为止，提两个小问题思考一下。</p><ul><li>虚拟机启动参数只限制了 Java堆为100MB,没有指定-Xmn参数，能否从监控图中估计出新生代有多大？</li><li>为何执行了 System.gc()之后，图4-6中代表老年代的柱状图仍然显示为峰值状 态，代码需要如何调整才能让System.gc()回收掉填充到堆中的对象？</li></ul><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8818%EF%BC%89.png"></p><center>图 4-6</center><p>  问题1的答案：图4-6显示Eden空间为27328KB,因为没有设置-XX:SurvivorRadio 参数，所以Eden与Survivor空间比例为默认值8： 1,因此整个新生代空间大约为 27,328KB X 125%&#x3D;34,160KB。</p><p>  问题2的答案：System.gc()之后，空间未能回收是因为List<OOMObject> list对象_仍然存活着,_fiUHeap()方法仍然没有退出，因此list对象在执行System.gc()时仍然处于作用域之内。如果把System.gc()移动到fillHeap()方法外，调用就可以回收掉全部 内存。</p><h3 id="（3）线程监控"><a href="#（3）线程监控" class="headerlink" title="（3）线程监控"></a>（3）线程监控</h3><p>如果上面的“内存”页签相当于可视化的jstat命令的话，“线程”页签的功能则相当于可视化的jstack命令，遇到线程停顿的时候可以使用这个页签进行监控分析。前面 讲解jstack命令的时候提到过线程长时间停顿的主要原因有：等待外部资源（数据库连 接、网络资源、设备资源等）、死循环、锁等待（活锁和死锁）。通过代码清单4-7分别 演示一下这几种情况。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createBusyThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;testBusyThread&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createLockThread</span><span class="params">(<span class="keyword">final</span> Object lock)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;testLockThread&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        bufferedReader.readLine();</span><br><span class="line">        createBusyThread();</span><br><span class="line">        bufferedReader.readLine();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        createLockThread(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  程序运行后，首先在“线程”页签中选择main线程，如图4-7所示。堆栈追踪显示 BufferedReader在readBytes方法中等待System.in的键盘输入，这时候线程为Runnable 状态，Runnable状态的进程会被分配运行时间，但readBytes方法检査到流没有更新时 会立刻归还执行令牌，这种等待只消耗很小的CPU资源。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8819%EF%BC%89.png"></p><p>  接着监控testBusyThread线程，如图4-8所示，testBusyThread线程一直在执行空循 环，从堆栈追踪中可以看到一直停留在FinalizeEscapeGC.java代码的12行，12行为while (true)„这时候线程为Runnable状态，而目.没有归还线程执行令牌的动作，会在空循环上用尽全部执行时间直到线程切换，这种等待会消耗较多的CPU资源。</p><p>  图4-9显示testLockThread线程在等待着lock对象的notify或notifyAll方法的出 现，线程这时候处在WAITING状态，在被唤醒前不会被分配执行时间。</p><p>  testLockThread线程正处于正常的活锁等待状态，只要lock对象的notify()或 notifyAlR)方法被调用，这个线程便能激活以继续执行。代码清单4-8演示了一个无法 再被激活的死锁等待。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8820%EF%BC%89.png"></p><center>图 4-8</center><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8821%EF%BC%89.png"></p><center>图 4-9</center><p>  代码清单4-8死锁代码样例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalizeEscapeGC</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Integer.valueOf(a))&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.valueOf(b))&#123;</span><br><span class="line">                System.out.println(a+b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">FinalizeEscapeGC</span>(<span class="number">1</span>,<span class="number">2</span>)).start();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">FinalizeEscapeGC</span>(<span class="number">2</span>,<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这段代码开了 200个线程分别去计算1+2及2+1的值，其实for循环是可省略的， 两个线程也可能会导致死锁，不过那样概率太小，需要尝试运行很多次才能看到效果。 如果运气不是特别差的话，带for循环的版本最多运行2~3次就会遇到线程死锁，程序无法结束。造成死锁的原因是Integer.valueOf()方法基于减少对象创建次数和节省内 存的考虑，［-128,127］之间的数字会被缓存。当valueOf()方法在这个范围之内传入参 数，将直接返回缓存中的对象。也就是说代码中调用了 200次Integer.valueOf()方法一 共就只返回了两个不同的对象。假如在某个线程的两个synchronized块之间发生了一次线程切换，就会出现线程A等着被线程B持有的Integer.valueOf(1),线程B又等着被线 程A持有的Integer.valueOf(2),结果大家都跑不下去的情景。</p><p>  出现线程死锁之后，点击JConsole线程面板的“检测到死锁”的按钮，将出现一个 新的”死锁”页签，如图4-10所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8822%EF%BC%89.png"></p><center>图 4-10</center><p>  图中很清晰地显示线程Thread-127在等待一个被线程Thread-158持有Integer对象， 而点击线程Thread-58则显示它也在等待一个Integer对象，被线程Thread-127持有，这样两个线程就互相卡住，都不存在等到锁释放的希望了。</p><h2 id="3-2-VisualVM-多合一故障处理工具"><a href="#3-2-VisualVM-多合一故障处理工具" class="headerlink" title="3.2  VisualVM :多合一故障处理工具"></a>3.2  VisualVM :多合一故障处理工具</h2><p>VisualVM （All-in-One Java Troubleshooting Tool）是到目前为止，随 JDK 发布的功能最强大的运行监视和故障处理程序，并且可以预见在未来一段时间内都是官方主力发展的虚拟机故障处理工具。官方在VisualVM的软件说明中写上了 “All-in-One”的描述 字样，预示着它除了运行监视、故障处理外，还提供了很多其他方面的功能。如性能分析（Profiling）, VisualVM的性能分析功能甚至比起JProfiler、YourKit等专业且收费的 Profiling 工具都不会逊色多少，而且VisualVM的还有一个很大优点：不需要被监视的 程序基于特殊Agent运行，因此它对应用程序的实际性能的影响很小，使得它可以直接 应用在生产环境中。这个优点是JProfiler、YourKit等工具无法与之媲美的。</p><h3 id="（1）VisualVM兼容范围与插件安装"><a href="#（1）VisualVM兼容范围与插件安装" class="headerlink" title="（1）VisualVM兼容范围与插件安装"></a>（1）VisualVM兼容范围与插件安装</h3><p>VisualVM基于NetBeans平台开发，因此它一开始就具备了插件扩展功能的特性， 通过插件扩展支持，VisualVM可以做到：</p><ul><li>显示虚拟机进程及进程的配置和环境信息（jps、jinfo）。</li><li>监视应用程序的CPU、GC、堆、方法区及线程的信息（jstat、jstack）。</li><li>dump及分析堆转储快照（jmap、jhat）。</li><li>方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。</li><li>离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个 快照，可以将快照发送开发者处进行Bug反馈。</li><li>其他plugins的无限的可能性……</li></ul><p>  VisualVM在JDK 1.6 update 7中才首次出现，但并不意味着它只能监控运行于JDK 1.6上的程序，它具备很强的向下兼容能力，甚至能向下兼容至近10年前发布的JDK 1.4.2平台气这对无数已经处于实施、维护状态的项目很有意义。当然，并非所有的功 能都能完美地向下兼容，主要特性的兼容性如表4-6所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8823%EF%BC%89.png"></p><p>  首次启动VisualVM后，读者先不必着急找应用程序进行监测，因为现在VisualVM 还没有加载任何插件，虽然基本的监视、线程面板的功能主程序都以默认插件的形式提供了，但是不给VisualVM装任何扩展插件，就相当于放弃了它最精华的功能，和没有安装任何应用软件操作系统差不多。</p><p>  插件可以手工安装，在网站’上下载*.nbm包后，点击“工具”一“插件”一“已下载”菜单，然后在弹出的对话框中指定nbm包路径便可进行安装，插件安装后存放 在JDK HOME&#x2F;lib&#x2F;visualvm&#x2F;visualvm中。不过手工安装并不常用，使用VisualVM的 自动安装功能已经可以找到所需的大多数插件，在有网络连接的环境下，点击“工具-插件-菜单“，弹出如图4-11所示的插件页签，在页签的“可用插件”中列举了当前版本VisualVM可以使用的插件，选中插件后在右边窗口将显示这个插件的基本信 息，如开发者、版本、功能描述等。</p><p>  大家可以根据自己的工作需要和兴趣选择合适的插件，然后点击安装按钮，弹出如 图4-12所示的下载进度窗口，跟着提示操作稍后即可安装完成。</p><p>  安装完插件后，选择一个需要监视的程序就进入程序的主界面了，如图4-13所示。 根据读者选择安装插件数量的不同，看到的页签可能和笔者截图中的会有差异。</p><p>  VisualVM中“概述”、”监视”、”线程”、”MBeans”的功能与前面介绍的JConsole 差别不大，读者根据上一节的内容类比使用即可，下面挑选几个特色功能和插件进行 介绍。</p><h3 id="（2）生成和浏览堆转储快照"><a href="#（2）生成和浏览堆转储快照" class="headerlink" title="（2）生成和浏览堆转储快照"></a>（2）生成和浏览堆转储快照</h3><p>在VisualVM中生成dump文件有两种方式，可以执行下列任一操作：</p><ul><li>在“应用程序”窗口中右键单击应用程序节点，然后选择“堆Dump”。</li><li>在“应用程序”窗口中双击应用程序节点以打开应用程序标签，然后在“监视” 标签中单击“堆Dump”。</li></ul><p>  生成了 dump文件之后，应用程序页签将在该堆的应用程序下增加一个以 [heapdump]开头的子节点，并且在主页签中打开该转储快照，如图4-14所示。如果需 要把dump文件保存或发送出去，要在heapdump节点上右键选择“另存为”菜单，否 则当VisualVM关闭时，生成的dump文件会被当做临时文件被删除掉。要打开一个 已经存在的dump文件，通过文件菜单中的“装入”功能，选择硬盘上的dump文件 即可。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8824%EF%BC%89.png"></p><center>图 4-14</center><p>  从堆页签中的“摘要”面板可以看到应用程序dump时的运行时参数、System. getProperties()的内容、线程堆栈等信息，“类”面板则是以类为统计口径统计类的实例 数量和容量信息，”实例”面板不能直接使用，因为不能确定用户想査看哪个类的实例， 所以需要通过“类”面板进入，在“类”中选择一个关心的类后双击鼠标，即可在“实 例”中看见此类中500个实例的具体属性信息。“OQL控制台”面板里面就是运行OQL 査询语句的，同jhat里面介绍的OQL功能一样。</p><h3 id="（3）分析程序性能"><a href="#（3）分析程序性能" class="headerlink" title="（3）分析程序性能"></a>（3）分析程序性能</h3><p>在Profiler页签中，VisualVM提供了程序运行期间方法级的CPU执行时间分析及 内存分析，进行Profiling分析肯定会对程序运行性能有比较大的影响，所以一般不在生 产环境中使用这项功能。</p><p>要开始分析，先选择“CPU”和“内存”按钮中的一个，然后切换到应用程序中对程序进行操作，VisualVM会记录到这段时间中应用程序执行过的方法。如果是CPU分 析，将会统计每个方法的执行次数、执行耗时；如果是内存分析则会统计每个方法关联 的对象数及这些对象所占的空间。分析结束后，点击“停止”按钮结束监控过程，如图 4-15所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8825%EF%BC%89.png"></p><center>图 4-15</center><p>  注意 在JDK 1.5之后，在Client模式下的虚拟机加入并且自动开启了类共享——这是 一个在多虚拟机进程中共享rt.jar中的类数据以提高加载速度和节省内存的优化，而根 据相关Bug报告的反映，VisualVM的Profiler功能可能会因为类共享而导致被监视的应 用程序崩潰，所以读者进行Profiling前，最好在被监视的程序中使用-Xshare:off参数来 关闭类共享优化。</p><p>  图4-15中是对Eclipse IDE 一段操作的录制和分析结果，读者分析自己的应用程序时, 可以根据实际业务的复杂程度与方法的时间和调用次数做比较，找到最有优化价值的方法。</p><h3 id="（4）BTrace动态日志跟踪"><a href="#（4）BTrace动态日志跟踪" class="headerlink" title="（4）BTrace动态日志跟踪"></a>（4）BTrace动态日志跟踪</h3><p>BTrace®是一个很“有趣”的VisualVM插件，本身也是可以独立运行的程序。它的作用是在不停止目标程序运行的前提下，通过HotSpot虚拟机的HotSwap技术®动态加入 原本并不存在的调试代码。这项功能对实际生产中的程序很有意义：经常遇到程序出现问 题，但排査错误的一些必要信息，譬如方法参数、返回值等，在开发时并没有打印到日志 之中，以至于不得不停掉服务，通过调试增量来加入日志代码以解决问题。当遇到生产环 境服务无法随便停止时，缺一两句日志导致排错进行不下去是一件非常郁闷的事情。</p><p>  在VisualVM中安装了 BTrace插件后，应用程序面板右键点击要调试的程序，会出 现“Trace Application”菜单，点击将进入BTrace面板。这个面板里面看起来就像一个 简单的Java程序开发环境，里面还有一小段Java代码，如图4-16所示。</p><p><img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8826%EF%BC%89.png"></p><center>图 4-16</center><p>  准备了一段很简单的Java代码来演示BTrace的功能：产生两个1000以内的随机整数，输出这2个数字相加的结果，如代码清单4-9所示。</p><p>  代码清单4-9 BTrace跟踪演示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">FinalizeEscapeGC</span> <span class="variable">finalizeEscapeGC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalizeEscapeGC</span>();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            reader.readLine();</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="type">int</span>) Math.round(Math.random()*<span class="number">1000</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">int</span>) Math.round(Math.random()*<span class="number">1000</span>);</span><br><span class="line">            System.out.println(finalizeEscapeGC.add(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  程序运行后，在VisualVM中打开该程序的监视，在BTrace页签填充TracingScript 的内容，输入调试代码如代码清单4.10所示。</p><p>  代码清单4・10 BTrace调试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* BTrace Script Template */</span></span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;</span><br><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TracingScript</span> &#123;</span><br><span class="line"><span class="comment">/* put your code here */</span></span><br><span class="line">    <span class="meta">@OnMethod(</span></span><br><span class="line"><span class="meta">        clazz = &quot;com.intehel.demo.domain.FinalizeEscapeGC&quot;,</span></span><br><span class="line"><span class="meta">        method=&quot;add&quot;,</span></span><br><span class="line"><span class="meta">        location=@Location(Kind.RETURN)</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="meta">@Self</span> com.intehel.demo.domain.FinalizeEscapeGC instance,<span class="type">int</span> a,<span class="type">int</span> b,<span class="meta">@Return</span> <span class="type">int</span> result)</span>&#123;</span><br><span class="line">        println(<span class="string">&quot;调用堆栈：&quot;</span>);</span><br><span class="line">        jstack();</span><br><span class="line">        println(strcat(<span class="string">&quot;方法参数A:&quot;</span>,str(a)));</span><br><span class="line">        println(strcat(<span class="string">&quot;方法参数B:&quot;</span>,str(b)));</span><br><span class="line">        println(strcat(<span class="string">&quot;方法结果:&quot;</span>,str(result)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  点击“Start”按钮后稍等片刻，编译完成后，可见Output面板中出现“BTrace code successfuly deployed”的字样。程序运行的时候在Output面板将会输出如图4-17所示的 调试信息。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)%EF%BC%8827%EF%BC%89.png"></p><center>图 4-17</center><p>  BTrace的用法还有许多，打印调用堆栈、参数、返回值只是最基本的应用，在它的网站上有使用BTrace进行性能监视、定位连接泄漏、内存泄漏、解决多线程竞争问题等的使用例子，有兴趣的可以去网上了解相关信息。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章介绍了随JDK发布的6个命令行工具与2个可视化的故障处理工具，灵活使用 这些工具，可以给处理问题带来很大的便利。</p><p>  除了 JDK自带的工具之外，常用的故障处理工具还有很多，如果读者使用的是非Sun系列的JDK,非HotSpot的虚拟机，就需要使用对应的工具进行分析，如：</p><ul><li>IBM 的 Support Assistant’、Heap Analyzer®, Javacore Analyzer®, Garbage Collector Analyzer®适用于 IBM J9 VM„</li><li>HP 的 HPjmeter®、HPjtune 适用于 HP-UX, SAP、HotSpot VM.</li><li>Eclipse 的 Memory Analyzer Tool® (MAT)适用于 HP-UX、SAP、HotSpot VM, 安装IBM DTFjo插件后可支持IBM J9 VM。</li><li>BEA 的 JRockit Mission Control ®,适用于 JRockit VMO</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java垃圾收集器与内存分配策略(2)</title>
      <link href="/2022/08/18/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)/"/>
      <url>/2022/08/18/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>说起垃圾收集(Garbage Collection, GC),大部分人都把这项技术当做Java语言的伴生产物。事实上，GC的历史远远比Java久远，1960年诞生于MIT的Lisp是第一门 真正使用内存动态分配和垃圾收集技术的语言。当Lisp还在胚胎时期时，人们就在思考 GC需要完成的三件事情：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p>  经过半个世纪的发展，内存的动态分配与内存回收技术已经相当成熟，一切看起来 都进入了 ‘‘自动化”时代，那为什么我们还要去了解GC和内存分配呢？答案很简单： 当需要排査各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶 颈时，我们就需要对这些’‘自动化”的技术实施必要的监控和调节。</p><p>  把时间从半个世纪以前拨回到现在，回到我们熟悉的Java语言。第2章介绍了 Java 内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈 操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的(尽管在运行期会由JIT编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是 编译期可知的)，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。而 Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存，后续讨论中的”内存”分配与回收也仅指这一部分内存。</p><h1 id="2-对象巳死？"><a href="#2-对象巳死？" class="headerlink" title="2. 对象巳死？"></a>2. 对象巳死？</h1><p>堆中几乎存放着Java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一 件事情就是要确定这些对象有哪些还”存活”着，哪些已经“死去”(即不可能再被任何途径使用的对象)。</p><h2 id="2-1-引用计数算法"><a href="#2-1-引用计数算法" class="headerlink" title="2.1 引用计数算法"></a>2.1 引用计数算法</h2><p>  很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1 ；当引用失效时，计数器值就减1 ；任何时刻计数器都为0的对象就是不可能再被使用的。笔者面试过很多的应届生和一些有多年工 作经验的开发人员，他们对于这个问题给予的都是这个答案。</p><p>  客观地说，引用计数算法(Reference Counting)的实现简单，判定效率也很高， 在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软的 COM (Component Object Model)技术、使用 ActionScript 3 的 FlashPlayer、Python 语 言以及在游戏脚本领域中被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。 但是，Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决 对象之间的相互循环引用的问题。</p><p>  举个简单的例子，请看代码清单3-1中的testGCO方法：对象objA和objB都有字段 instance,赋值令 objA.instance &#x3D; objB 及 objB.instance &#x3D; objA,除此之外,这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0,于是引用计数算法无法通知GC收集器回收它们。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGC</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="literal">null</span>;</span><br><span class="line">        objB = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  程序正常退出，虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。</p><h2 id="2-2-根搜索算法"><a href="#2-2-根搜索算法" class="headerlink" title="2.2 根搜索算法"></a>2.2 根搜索算法</h2><p>在主流的商用程序语言中（Java和C#,甚至包括前面提到的古老的Lisp）,都是使用根搜索算法（GC Roots Tracing）判定对象是否存活的。这个算法的基本思路就是查 过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明此对象是不可用 的。如图3-1所示,对象。bject5、object 6. object 7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p><p>  在Java语言里，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li><li>方法区中的类静态属性引用的对象。</li><li>方法区中的常量引用的对象。</li><li>本地方法栈中JNI （即一般说的Native方法）的引用的对象。</li></ul><h2 id="2-3-再谈引用"><a href="#2-3-再谈引用" class="headerlink" title="2.3 再谈引用"></a>2.3 再谈引用</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引 用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2之前，Java中的引用 的定义很传统:如果reference类型的数据中存储的数值代表的是另外一块内存的起始 地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这 种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。 很多系统的缓存功能都符合这样的应用场景。</p><p>  在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference),软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)四种，这四种引用强度依次逐渐减弱。</p><ul><li>强引用就是指在程序代码之中普遍存在的，类似“Object obj &#x3D; new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li><li>软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在 系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二 次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了 SoftReference类来实现软引用。</li><li>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用 关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当 前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了 WeakReference类来实现弱引用。</li><li>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否 有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收 集器回收时收到一个系统通知。在JDK 1.2之后，提供了 PhantomReference类来 实现虚引用。</li></ul><h2 id="2-4-生存还是死亡？"><a href="#2-4-生存还是死亡？" class="headerlink" title="2.4 生存还是死亡？"></a>2.4 生存还是死亡？</h2><p>在根捜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于 “缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程:如果对象在进行 根捜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次 筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize（）方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为’‘没有必要 执行”。</p><p>  如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个 名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer 线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环(更极端的情况)，将很可能会导致F-Queue队列中的其他对象永久处于等待状态， 甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会， 稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this 关键字)赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。从代码清单3-2 中我们可以看到一个对象的finalize()被执行，但是它仍然可以存活。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">FinalizeEscapeGC</span> <span class="variable">SAVE_HOOK</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isAlive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am still alive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;Finalized method execution&quot;</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> <span class="title class_">FinalizeEscapeGC</span>();</span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为 finalize 方法优先级低，暂停等他0.5秒</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am dead!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为 finalize 方法优先级低，暂停等他0.5秒</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am dead!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行结果：</p><p>  Finalized method execution<br>  I am still alive<br>  I am dead!</p><p>  从代码清单3-2的运行结果可以看到，SAVE_HOOK对象的finalize()方法确实被 GC收集器触发过，并且在被收集前成功逃脱了。</p><p>  另外一个值得注意的地方就是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败，这是因为任何一个对象的finalize。方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行,因此第二段代码的自救行动失败了。</p><p>  需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用 它，因为它不是C&#x2F;C++中的析构函数，而是Java刚诞生时为了使C&#x2F;C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中提到它适合做“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize。能做的所有工作，使用try-finally或其他方式都可以做得更好、更及时,大家完全可以忘掉Java语言中还有这个方法的存在。</p><h2 id="2-5-回收方法区"><a href="#2-5-回收方法区" class="headerlink" title="2.5 回收方法区"></a>2.5 回收方法区</h2><p>  很多人认为方法区(或者HotSpot虚拟机中的永久代)是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收 集一般可以回收70%〜95%的空间，而永久代的垃圾收集效率远低于此。</p><p>  永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串 “abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc” 的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量 就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也 与此类似。</p><p>  判定一个常量是否是”废弃常量”比较简单，而要判定一个类是否是”无用的类” 的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供 了 -Xnoclassgc 参数进行控制，还可以使用-verbose:class 及-XX: +TraceClassLoading、 -XX:+TraceClassUnLoading 査看类的加载和卸载信息。-verbose: class 和-XX: +TraceClassLoading 可以在 Product 版的虚拟机中使用，但-XX:+TraceClassUnLoading 参数需要fastdebug版的虚拟机支持。</p><p>  在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和 OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能,以保证永久代不会溢出。</p><h1 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3. 垃圾收集算法"></a>3. 垃圾收集算法</h1><p>由于垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的 方法又各不相同，因此本节不打算过多地讨论算法的实现，只是介绍几种算法的思想及 其发展过程。</p><h2 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h2><p>  最基础的收集算法是“标记-清除”(Mark-Sweep)算法，如它的名字一样，算法分 _为_“标记“和“清除“两个阶段:首先标记出所有需要回收的对象，在标记完成后统一回 收掉所有被标记的对象,它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过 了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺 点进行改进而得到的。它的主要缺点有两个：一个是效率问题,标记和清除过程的效率都 不高：另外一个是空间问题,标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记-清除算法的执行过程如图3-2所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%881%EF%BC%89.png"></p><h2 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h2><p>为了解决效率问题，一种称为”复制”(Copying)的收集算法出现了，它将可用内存 按容量划分为大小相等的两块,毎次只使用其中的一块。当这一块的内存用完了，就将还 存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得 每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只 要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。复制算法的执行过程如图3-3所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%882%EF%BC%89.png"></p><p>  现在的商业虚拟机都采用这种收集算法来回收新生代,IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1 ： 1的比例来划分内存空间，而是 将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的 一块Survivor_”__。_当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外 一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟 机默认Eden和Survivor的大小比例是8 ： 1,也就是每次新生代中可用内存空间为整个 新生代容量的90% (80%+10%),只有10%的内存是会被“浪费”的。当然，98%的 对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对 象存活，当Survivor空间不够用时，需要依赖其他内存(这里指老年代)进行分配担保 (Handle Promotion)。</p><p>  内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能 按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担 保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保也一样，如果另外一块Survivor空间没有足够的空间存放上一次新生代收集 下来的存活对象，这些对象将直接通过分配担保机制进入老年代。关于对新生代进行分 配担保的内容，本章稍后在讲解垃圾收集器执行规则时还会再详细讲解。</p><h2 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a>3.3 标记-整理算法</h2><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>  根据老年代的特点，有人提出了另外一种“标记-整理”(Mark-Compact)算法， 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清 理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存,“标记-整理”算法的示意图如图3-4所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%883%EF%BC%89.png"></p><h2 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h2><p>当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，这 种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算 法。在新生代中,每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复 制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存 活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整 理”算法来进行回收。</p><h1 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4.垃圾收集器"></a>4.垃圾收集器</h1><p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。Java 虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本 的虚拟机所提供的垃圾收集器都可能会有很大的差别，并且一般都会提供参数供用户根 据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于Sun HotSpot虚拟机1.6版Update _22,_这个虚拟机包含的所有收集器如图3-5所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%884%EF%BC%89.png"></p><p>  图3-5展示了 7种作用于不同分代的收集器（包括JDK 1.6_Update14后引入的 Early Access版G1收集器），如果两个收集器之间存在连线，就说明它们可以搭配使用。</p><p>  在介绍这些收集器各自的特性之前，我们先来明确一个观点：虽然我们是在对各个 收集器进行比较，但并非为了挑选一个最好的收集器出来。因为直到现在为止还没有最 好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收 集器。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的 完美收集器存在，那HotSpot虚拟机就没必要实现那么多不同的收集器了。</p><h2 id="4-1-Serial-收集器"><a href="#4-1-Serial-收集器" class="headerlink" title="4.1 Serial 收集器"></a>4.1 Serial 收集器</h2><p>Serial收集器是最基本、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机 新生代收集的唯一选择。大家看名字就知道，这个收集器是一个单线程的收集器,但它 的’‘单线程”的意义并不仅仅是说明它只会使用一个CPU或一条收集线程去完成垃圾收 集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程（Sun将这件 事情称之为“Stop The World”）,直到它收集结束。“Stop The World”这个名字也许听 起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见 的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是难以接受的。你想 想，要是你的电脑每运行一个小时就会暂停响应5分钟，你会有什么样的心情？图3-6 示意了 Serial &#x2F; Serial Old收集器的运行过程。</p><p>  对于“Stop The World”带给用户的恶劣体验，虚拟机的设计者们表示完全理解，但也表示非常委屈：“你妈妈在给你打扫房间的时候，肯定也会让你老老实实地在椅子上 或房间外待着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完吗？ ”这确实是 一个合情合理的矛盾，虽然垃圾收集这项工作听起来和打扫房间属于一个性质的，但实际上肯定还要比打扫房间复杂得多啊！</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%885%EF%BC%89.png"></p><p>  从JDK 1.3开始，一直到现在还没正式发布的JDK 1.7，HotSpot虚拟机开发团队 为消除或减少工作线程因内存回收而导致停顿的努力一直在进行着，从Serial收集器 到Parallel收集器，再到Concurrent Mark Sweep （CMS）现在还未正式发布的Garbage First （G1）收集器，我们看到了一个个越来越优秀（也越来越复杂）的收集器的出现， 用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除（这里暂不包括RTSJ中 的收集器）。寻找更优秀的垃圾收集器的工作仍在继续！</p><p>  写到这里，笔者似乎已经把Serial收集器描述成一个老而无用，食之无味弃之可惜 的鸡肋了，但实际上到现在为止，它依然是虚拟机运行在Client模式下的默认新生代收 集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比）,对 于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收 集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理 的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的 内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫 秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial收集器对于运行在 Client模式下的虚拟机来说是一个很好的选择。</p><h2 id="4-2-ParNew-收集器"><a href="#4-2-ParNew-收集器" class="headerlink" title="4.2 ParNew 收集器"></a>4.2 ParNew 收集器</h2><p>ParNew收集器其实就是Serial收集器的多线程版本,除了使用多条线程进行垃圾 收集之外,其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure 等）、收集算法、Stop The World,对象分配规则、回收策略等都与Serial收集器完全一样，实现上这两种收集器也 共用了相当多的代码。ParNew收集器的工作过程如图3-7所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%886%EF%BC%89.png"></p><p>  ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之 处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器,其中有一个与 性能无关但很重要的原因是，除了 Serial收集器外，目前只有它能与CMS收集器配合工作。在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可称为有划时代意义 的垃圾收集器——CMS收集器（Concurrent Mark Sweep,本节稍后将详细介绍这款收集 器），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器， 它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，用前面那个例子的话 来说，就是做到了在你妈妈打扫房间的时候你还能同时往地上扔纸屑。</p><p>  不幸的是，它作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收 集器Parallel Scavenge配合工作。所以在JDK 1.5中使用CMS来收集老年代的时 候，新生代只能选择ParNew或Serial收集器中的一个。ParNew收集器也是使用-XX: WseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC 选项来强制指定它。</p><p>  ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之 百地保证能超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时 系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU 非常多（譬如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况 越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p><p>  注意从ParNew收集器开始，后面还将会接触到几款并发和并行的收集器。在大家可能 产生疑惑之前，有必要先解释两个名词：并发和并行。这两个名词都是并发编程中的概 念，在谈论垃圾收集器的上下文语境中，他们可以解释为：</p><ul><li>并行（Parallel）:指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续运行，而垃圾收集程序运行于另一个CPU上。</li></ul><h2 id="4-3-Parallel-Scavenge-收集器"><a href="#4-3-Parallel-Scavenge-收集器" class="headerlink" title="4.3 Parallel Scavenge 收集器"></a>4.3 Parallel Scavenge 收集器</h2><p>Parallel Scavenge收集器也是一个新生代收集器,它也是使用复制算法的收集器, 又是并行的多线程收集器……看上去和ParNew都一样，那它有什么特别之处呢？</p><p>  Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的 关注点尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目 标则是达到一个可控制的吞吐量(Throughput)。所谓吞吐量就是CPU用于运行用户代 码的时间与CPU总消耗时间的比值，即吞吐量&#x3D;运行用户代码时间&#x2F; (运行用户代码时 间+垃圾收集时间)，虚拟机总共运行了 100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><p>  停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体 验;而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适 合在后台运算而不需要太多交互的任务。</p><p>  Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制 最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数及直接设置吞吐量大小的 -XX:GCTimeRatio 参数。</p><p>  MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回 收花费的时间不超过设定值。不过大家不要异想天开地认为如果把这个参数的值设置得 稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和 新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB 快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100 毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也 降下来了。</p><p>  GCTimeRatio参数的值应当是一个大于0小于100的整数，也就是垃圾收集时间占 总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19,那允许的最大GC时 间就占总时间的5% (即1&#x2F; (1 + 19)),默认值为99,就是允许最大1% (即1 &#x2F; (1+99)) 的垃圾收集时间。</p><p>  由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称为“吞吐量 优先”收集器。除上述两个参数之外，Parallel Scavenge收集器还有一个参<br>_数_-XX：+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就 不需要手工指定新生代的大小（-Xmn）, Eden与Survivor E的比例（-XX:SurvivorRatio）、 晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当 前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或 最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics） 如果 读者对于收集器运作原理不太了解，手工优化存在困难的时候，使用Parallel Scavenge 收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个很 不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用 MaxGCPauseMillis参数（更关注最大停顿时间）或GCTimeRatio参数（更关注吞吐量） 给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调 节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p><h2 id="4-4-Serial-Old-收集器"><a href="#4-4-Serial-Old-收集器" class="headerlink" title="4.4 Serial Old 收集器"></a>4.4 Serial Old 收集器</h2><p>Serial Old是Serial 收集器的老年代版本,它同样是一个单线程收集器，使用“标 记-整理”算法。这个收集器的主要意义也是被Client模式下的虚拟机使用。如果 在Server模式下，它主要还有两大用途：一个是在JDK 1.5及之前的版本中与Parallel Scavenge收集器搭配使用气 另外一个就是作为CMS收集器的后备预案，在并发收集发 生Concurrent Mode Failure的时候使用。这两点都将在后面的内容中详细讲解。Serial Old收集器的工作过程如图3-8所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%887%EF%BC%89.png"></p><h2 id="4-5-Parallel-Old-收集器"><a href="#4-5-Parallel-Old-收集器" class="headerlink" title="4.5 Parallel Old 收集器"></a>4.5 Parallel Old 收集器</h2><p>Parallel Old_是_Parallel Scavenge收集器的老年代版本,使用多线程和“标记-整理” 算法。这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge 收集器一直处于比较尴尬的状态。原因是，如果新生代选择了 Parallel Scavenge收集器， 老年代除了 Serial Old (PS MarkSweep)收集器外别无选择(还记得上面说过Parallel Scavenge收集器无法与CMS收集器配合工作吗？)。由于单线程的老年代Serial Old收 集器在服务端应用性能上的’‘拖累”，即便使用了 Parallel Scavenge收集器也未必能在整 体应用上获得吞吐量最大化的效果,又因为老年代收集中无法充分利用服务器多CPU的 处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不…定 有ParNew加CMS的组合“给力”。</p><p>  直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应 用组合，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加 Parallel Old收集器。Parallel Old收集器的工作过程如图3-9所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%888%EF%BC%89.png"></p><h2 id="4-6-CMS收集器"><a href="#4-6-CMS收集器" class="headerlink" title="4.6 CMS收集器"></a>4.6 CMS收集器</h2><p>  CMS (Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收 集器。目前很大一部分的Java应用都集中在互联网站或B&#x2F;S系统的服务端上，这类应用 尤其重视服务的响应速度,希望系统停顿时间最短，以给用户帯来较好的体验。CMS收 集器就非常符合这类应用的需求。</p><p>  从名字(包含“Mark Sweep”)上就可以看出CMS收集器是基于“标记-清除”算法实现的,它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p><ul><li>初始标记(CMS initial mark)</li><li>并发标记(CMS concurrent mark)</li><li>重新标记(CMS remark)</li><li>并发清除（CMS concurrent sweep）</li></ul><p>  其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅 只是标记一下GC Roots能直接关联到的对象，速度很快,并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运 作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始 标记阶段稍长一些，但远比并发标记的时间短。</p><p>  由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。通过图3-10可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%889%EF%BC%89.png"></p><p>  CMS是一款优秀的收集器，它的最主要优点在名字上已经体现出来了 :并发收集、 低停顿，Sun的一些官方文档里面也称之为并发低停顿收集器（Concurrent Low Pause Collector）。但是CMS还远达不到完美的程度，它有以下三个显著的缺点：</p><ul><li><p>CMS收集器对CPU资源非常敏感。其实，面向并发设计的程序都对CPU资源比 较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启 动的回收线程数是（CPU数量+3）&#x2F;4,也就是当CPU在4个以上时，并发回收 时垃圾收集线程最多占用不超过25%的CPU资源。但是当CPU不足4个时（譬 如2个），那么CMS对用户程序的影响就可能变得很大，如果CPU负载本来就 比较大的时候，还分出一半的运算能力去执行收集器线程，就可能导致用户程序 的执行速度忽然降低了 50%,这也很让人受不了。为了解决这种情况，虚拟机提 供了一种称为“增量式并发收集器”(Incremental Concurrent Mark Sweep &#x2F; i-CMS) 的CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模 拟多任务机制的思想一样，就是在并发标记和并发清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些,速度下降也就没有那么明显，但是目前版本中，i-CMS已经被声明为“deprecated”，即不再提倡用户使用。</p></li><li><p>CMS收集器无法处理浮动垃圾(Floating Garbage),可能出现”Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在 标记过程之后，CMS无法在本次收集中处理掉它们，只好留待下一次GC时再将 其清理掉。这一部分垃圾就称为“浮动垃圾”，也是由于在垃圾收集阶段用户线 程还需要运行，即还需要预留足够的内存空间给用户线程使用，因此CMS收集 器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一 部分空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代 使用了 68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代 增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来 提高触发百分比，以便降低内存回收次数以获取更好的性能。要是CMS运行期 间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败,这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置得太高将会很容易导致大最Concurrent Mode Failure”失败，性能反而降低。</p></li><li><p>还有最后一个缺点，在本节在开头说过，CMS是款基于“标记-清除”算法实 现的收集器，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着 收集结束时会产生大量空间碎片。空间碎片过多时，将会给大对象分配带来很大 的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空 间来分配当前对象，不得不提前触发一次Full GC.为了解决这个问题，CMS收 集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享 受”完Full GC服务之后额外免费附送一个碎片整理过程，内存整理的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者们还 提供了另外一个参数-XX: CMSFullGCsBeforeCompaction,这个参数用于设置在 执行多少次不压缩的Full GC后，跟着来一次带压缩的。</p></li></ul><h2 id="4-7-G1收集器"><a href="#4-7-G1收集器" class="headerlink" title="4.7 G1收集器"></a>4.7 G1收集器</h2><p>G1 (Garbage First)收集器是当前收集器技术发展的最前沿成果，在JDK 1.6_ Update”中提供了 Early Access版本的G1收集器以供试用。在将来JDK 1.7正式发布 的时候，G1收集器很可能会有一个成熟的商用版本随之发布。这里只对G1收集器进行 简单介绍。</p><p>  G1收集器是垃圾收集器理论进一步发展的产物，它与前面的CMS收集器相比有两 个显著的改进:一是G1收集器是基于“标记-整理”算法实现的收集器，也就是说它 不会产生空间碎片，这对于长时间运行的应用系统来说非常重要。二是它可以非常精确 地控制停顿，既能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收 集上的时间不得超过N毫秒,这几乎已经是实时Java (RTSJ)的垃圾收集器的特征了。</p><p>  G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收，这是由于 它能够极力地避免全区域的垃圾收集，之前的收集器进行收集的范围都是整个新生代或 老年代，而G1将整个Java堆(包括新生代、老年代)划分为多个大小固定的独立区域 (Region),并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根 据允许的收集时间，优先回收垃圾最多的区域(这就是Garbage First名称的来由)。区 域划分及有优先级的区域回收，保证了 G1收集器在有限的时间内可以获得最高的收集 效率。</p><h2 id="4-8-垃圾收集器参数总结"><a href="#4-8-垃圾收集器参数总结" class="headerlink" title="4.8 垃圾收集器参数总结"></a>4.8 垃圾收集器参数总结</h2><p>JDK 1.6中的各种垃圾收集器到此已全部介绍完毕，在描述过程中提到了很多虚拟机非稳定的运行参数，表3-1整理了这些参数以供读者实践时参考。</p><p><img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%8810%EF%BC%89.png"></p><h1 id="5-内存分配与回收策略"><a href="#5-内存分配与回收策略" class="headerlink" title="5. 内存分配与回收策略"></a>5. 内存分配与回收策略</h1><p>Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题： 给对象分配内存以及回收分配给对象的内存。关于回收内存这一点，我们已经使用了大量的篇幅去介绍虚拟机中的垃圾收集器体系及其运作原理，现在我们再一起来探讨一下 给对象分配内存的那点事儿。</p><p>  对象的内存分配，往大方向上讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配。），对象主要分配在新生代的Eden区上，如果启动 了本地线程分配缓冲，将按线程优先在TLAB±分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p><p>  接下来我们将会讲解几条最普遍的内存分配规则，并通过代码去验证这些规则。本节中的代码在测试时使用Client模式虚拟机运行，没有手工指定收集器组合，换句话 说，验证的是使用Serial &#x2F; Serial Old收集器下（ParNew &#x2F; Serial Old收集器组合的规则 也基本一致）的内存分配和回收的策略。读者不妨根据自己项目中使用的收集器写一些 程序去验证一下使用其他几种收集器的内存分配策略。</p><h2 id="5-1-对象优先在Eden分配"><a href="#5-1-对象优先在Eden分配" class="headerlink" title="5.1 对象优先在Eden分配"></a>5.1 对象优先在Eden分配</h2><p>  大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配 时，虚拟机将发起一次Minor GC</p><p>  虚拟机提供了 -XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前内存各区域的分配情况。在实际应用中，内存回收日志一般是打印到文件后通过日志工具进行分析，不过本实验的日志并不多，直接阅读就能看得很清楚。</p><p>  代码清单3-3的testAllocation。方法中，尝试分配3个2MB大小和1个4MB 大小的对象，在运行时通过-Xms20M、-Xmx20M和-Xmn10M这3个参数限制Java 堆大小为20MB,且不可扩展，其中10MB分配给新生代，剩下的10MB分配给老 年代。-XX:SurvivorRatio&#x3D;8决定了新生代中Eden区与一个Survivor区的空间比例 是8比1,从输出的结果也能清晰地看到“eden space 8192K、from space 1024K、to space 1024K”的信息，新生代总可用空间为9216KB （Eden区+1个Survivor g的总 容量）。</p><p>  执行testAllocation()中分配allocation4对象的语句时会发生一次Minor GC,这次GC的结果是新生代6945KB变为1021KB,而总内存占用量则几乎没有减少（因为 allocations 2、3三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。这次GC 发生的原因是给allocation4分配内存的时候，发现Eden已经被占用了 6MB,剩余空间 已不足以分配allocation4所需的4MB内存，因此发生Minor GC。 GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（Survivor空间只有1MB大小），所以只好通过分配担保机制提前转移到老年代去。</p><p>  这次GC结束后，4MB的allocation，对象被顺利分配在Eden中。因此程序执行完 的结果是Eden占用4MB （被allocation4占用），Survivor空闲，老年代被占用6MB （被 allocation Is 2、3占用）。通过GC日志可以证实这一点。</p><ul><li>新生代GC （Minor GC）:指发生在新生代的垃圾收集动作，因为Java对象大多都具 备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li><li>老年代GC （Major GC &#x2F; Full GC）:指发生在老年代的GC,出现了 Major GC,经常 会伴随至少一次的Minor GC （但非绝对的，在ParallelScavenge收集器的收集策略里 就有直接进行Major GC的策略选择过程）。MajorGC的速度一般会比Minor GC慢10 倍以上。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"><span class="comment">// vm参数 -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        FinalizeEscapeGC.testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行结果:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 6945K-&gt;1021K(9216K)] 6945K-&gt;3674K(19456K), 0.0019542 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 5440K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 8192K, 53% used [0x00000000ff600000,0x00000000ffa50ed8,0x00000000ffe00000)</span><br><span class="line">  from space 1024K, 99% used [0x00000000ffe00000,0x00000000ffeff520,0x00000000fff00000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 10240K, used 6748K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  object space 10240K, 65% used [0x00000000fec00000,0x00000000ff297348,0x00000000ff600000)</span><br><span class="line"> Metaspace       used 3332K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 358K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><h2 id="5-2-大对象直接进入老年代"><a href="#5-2-大对象直接进入老年代" class="headerlink" title="5.2 大对象直接进入老年代"></a>5.2 大对象直接进入老年代</h2><p>所谓大对象就是指，需要大量连续内存空间的Java对象,最典型的大对象就是那种很 长的字符串及数组（笔者例子中的byte[]数组就是典型的大对象）。大对象对虚拟机的内存 分配来说就是一个坏消息（替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是 遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），经常出现大对象容易 导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来”安置”它们。</p><p>  虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接 在老年代中分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内 存拷贝（复习一下:新生代采用复制算法收集内存）。</p><p>  执行代码清单3-4中的testPretenureSizeThreshold（）方法后，我们看到老年代10MB的空间被使用了 40%,也就是4MB的allocation 对象直接就分配在老年代中，这是因为PretenureSizeThreshold被设置为3MB （就是 3145728B,这个参数不能与-Xmx之类的参数一样直接写3MB）,因此超过3MB的对 象都会直接在老年代中进行分配。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"><span class="comment">//vm参数： -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPretenured</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation;</span><br><span class="line">        allocation = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        FinalizeEscapeGC.testPretenured();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 4893K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 8192K, <span class="number">59</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffac76b8</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line"> ParOldGen       total 10240K, used 4096K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  object space 10240K, <span class="number">40</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff000010</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"> Metaspace       used 3189K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 343K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="5-3-长期存活的对象将进入老年代"><a href="#5-3-长期存活的对象将进入老年代" class="headerlink" title="5.3 长期存活的对象将进入老年代"></a>5.3 长期存活的对象将进入老年代</h2><p>  虚拟机既然采用了分代收集的思想来管理内存，那内存回收时就必须能识别哪些对 象应当放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义 了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然 存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。 对象在Survivor区中每熬过一次Minor GC,年龄就增加1岁，当它的年龄增加到一定 程度（默认为15岁）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过MaxTenuringThreshold&#x3D; 15的参数设置。</p><p>  可以试试分别以MaxTenuringThreshold&#x3D; 1 和MaxTenuringThreshold&#x3D; 15，此方法中对象需要256KB的内存空间，Survivor空间可以容纳。当MaxTenuringThreshold&#x3D;1 时，allocationl对象在第二次GC发生时进入老年代，新生代已使用的内存GC后 会非常干净地变成0KB。而MaxTenuringThreshold&#x3D;15时，第二次GC发生后， allocationl对象则还留在新生代Survivor空间，这时候新生代仍然有404KB的空间被占用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line"><span class="comment">//vm配置 -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:MaxTenuringThreshold=1</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="literal">null</span>;</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        FinalizeEscapeGC.testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以MaxTenuringThreshold&#x3D; 1 的参数设置来运行的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 5153K-&gt;1021K(9216K)] 13345K-&gt;10054K(19456K), <span class="number">0.0016619</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 1021K-&gt;0K(9216K)] [ParOldGen: 9032K-&gt;5879K(10240K)] 10054K-&gt;5879K(19456K), [Metaspace: 3309K-&gt;3309K(1056768K)], <span class="number">0.0058565</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 4262K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 8192K, <span class="number">52</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffa29b48</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 10240K, used 5879K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  object space 10240K, <span class="number">57</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff1bdf00</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"> Metaspace       used 3333K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 358K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>以MaxTenuringThreshold&#x3D; 15的参数设置来运行的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 5153K-&gt;1021K(9216K)] 13345K-&gt;10036K(19456K), <span class="number">0.0019170</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 1021K-&gt;0K(9216K)] [ParOldGen: 9015K-&gt;5879K(10240K)] 10036K-&gt;5879K(19456K), [Metaspace: 3310K-&gt;3310K(1056768K)], <span class="number">0.0058862</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 4178K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 8192K, <span class="number">51</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffa14930</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 10240K, used 5879K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  object space 10240K, <span class="number">57</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff1bdf00</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"> Metaspace       used 3317K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 356K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><h2 id="5-4-动态对象年龄判定"><a href="#5-4-动态对象年龄判定" class="headerlink" title="5.4 动态对象年龄判定"></a>5.4 动态对象年龄判定</h2><p>  为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到 MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小 的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><p>  执行代码清单3-6中的testTenuringThreshold2()方法，并设置参数-XX: MaxTenuringThreshold&#x3D;15,会发现运行结果中Survivor的空间占用仍然为0%,而老年 代比预期增加了 6%,也就是说allocation1, allocation2对象都直接进入了老年代，而没 有等到15岁的临界年龄。因为这两个对象加起来已经达到了 512KB,并且它们是同年 的，满足同年对象达到Survivor空间的一半规则。我们只要注释掉其中一个对象的new 操作，就会发现另外一个不会晋升到老年代中去了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="literal">null</span>;</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        FinalizeEscapeGC.testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 5409K-&gt;992K(9216K)] 13601K-&gt;10298K(19456K), <span class="number">0.0023467</span> secs] [Times: user=<span class="number">0.06</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 992K-&gt;0K(9216K)] [ParOldGen: 9306K-&gt;6159K(10240K)] 10298K-&gt;6159K(19456K), [Metaspace: 3322K-&gt;3322K(1056768K)], <span class="number">0.0068674</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 4178K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 8192K, <span class="number">51</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffa14930</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 10240K, used 6159K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  object space 10240K, <span class="number">60</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff203f80</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"> Metaspace       used 3331K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 358K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="5-5-空间分配担保"><a href="#5-5-空间分配担保" class="headerlink" title="5.5 空间分配担保"></a>5.5 空间分配担保</h2><p>  在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于 老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则査看 HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC ；如果不允许，则也要改为进行一次Full GC。</p><p>  前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个 Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况时 (最极端就是内存回收后新生代中所有对象都存活)，就需要老年代进行分配担保，让 Survivor无法容纳的对象直接进入老年代。与生活中的贷款担保类似，老年代要进行这 样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下 来，在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老 年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行 Full GC来让老年代腾出更多空间。</p><p>  取平均值进行比较其实仍然是一种动态概率的手段，也就是说如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败(Handle Promotion Failure)»如果出现了 HandlePromotionFailure失败，那就只好在失败后 重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还 是会将HandlePromotionFailure开关打开，避免Full GC过于频繁</p><p>  HandlePromotionFailure &#x3D; false参数和MaxTenuringThreshold&#x3D; true在JDK8及以后不再支持</p><h2 id="5-6-本章小结"><a href="#5-6-本章小结" class="headerlink" title="5.6 本章小结"></a>5.6 本章小结</h2><p>  本章介绍了垃圾收集的算法、几款JDK 1.6中提供的垃圾收集器特点及其运作原理。 通过代码实例验证了 Java虚拟机中自动内存分配及回收的主要规则。</p><p>  内存回收与垃圾收集器在很多时候都是影响系统性能、并发能力的主要因素之 一，虚拟机之所以提供多种不同的收集器及大量的调节参数，是因为只有根据实际应 用需求、实现方式选择最优的收集方式才能获取最好的性能。没有固定收集器、参数组合，也没有最优的调优方法，虚拟机也没有什么必然的内存回收行为。因此学习虚拟机内存知识，如果要到实践调优阶段，必须了解每个具体收集器的行为、优势和劣势、调节参数。在接下来的两章中，作者将会介绍内存分析的工具和调优的一些具体案例。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存区域与内存溢出异常(1)</title>
      <link href="/2022/08/17/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8(1)/"/>
      <url>/2022/08/17/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8(1)/</url>
      
        <content type="html"><![CDATA[<h1 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1. 运行时数据区域"></a>1. 运行时数据区域</h1><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据 区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的 启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟 机规范（第2版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区 域，如图2-1所示。</p><p><img src="https://image.buretuzi.online/blog/article/jvm/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8(1)%EF%BC%881%EF%BC%89.png"></p><h2 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h2><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看 做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型， 各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变 这个计数器的值来选取下一条需要执行的字节码指令,分支、循环、跳转、异常处理、 线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>  由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现 的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行 一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置,每条线程都需要 有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内 存区域为“线程私有”的内存。</p><p>  如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节 码指令的地址；如果正在执行的是Natvie方法,这个计数器值则为空（Undefined）。此 内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h2 id="1-2-Java虚拟机栈"><a href="#1-2-Java虚拟机栈" class="headerlink" title="1.2 Java虚拟机栈"></a>1.2 Java虚拟机栈</h2><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的， 它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame®）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在 虚拟机栈中从入栈到出栈的过程。</p><p>  经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack）,这种分法比较粗 糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序 员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的”堆”在后 面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈,或者说是虚拟机栈中的局部变 量表部分。</p><p>  局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、 float、long、double）,对象引用（reference类型，它不等同于对象本身，根据不同的虚拟 机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或 者其他与此对象相关的位置）和retumAddress类型（指向了一条字节码指令的地址）。</p><p>  其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot）,其余 的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配,当进入一个 方法时,这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间 不会改变局部变量表的大小。</p><p>  在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大 于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展 （当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的 虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p><h2 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h2><p>本地方法栈(Native Method Stacks)与虚拟机栈所发挥的作用是非常相似的，其 区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务,而本地方法栈则 是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语 言、使用方式与数据结构并没有强制规定,因此具体的虚拟机可以自由实现它。甚至 有的虚拟机(譬如Sun HotSpot虚拟机)直接就把本地方法栈和虚拟机栈合二为一。 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError 异常。</p><h2 id="1-4-Java-堆"><a href="#1-4-Java-堆" class="headerlink" title="1.4 Java 堆"></a>1.4 Java 堆</h2><p>对于大多数应用来说，Java堆(Java Heap)是Java虚拟机所管理的内存中最大的 一块。Java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建。此内存区域的 唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存。这一点在Java虚 拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。但是随着JIT编译器 的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换®优化技术将会导致一些微妙 的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p><p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”(Garbage Collected Heap,幸好国内没翻译成“垃圾堆”)。如果从内存回收的角度看，由于现在 收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代； 再细致-点的有Eden空间、From Survivor空间、To Survivor空间等。如果从内存分配 的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB).不过，无论如何划分，都与存放内容无关，无论哪个区域， 存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配 内存。</p><p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中,只要 逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小 的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx 和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。</p><h2 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h2><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域,它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽 然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non­Heap （非堆），目的应该是与Java堆区分开来。</p><p>  对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区 称为“永久代”（Permanent Generation）,本质上两者并不等价，仅仅是因为HotSpot虚 拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而 已。对于其他虚拟机（如BEA JRockit, IBM J9等）来说是不存在永久代的概念的。即 使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家” 至Native Memory来实现方法区的规划了。</p><p>  Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内 存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾 收集行为在这个区域是比较少出现的,但并非数据进入了方法区就如永久代的名字一 样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸 载,一般来说这个区域的回收”成绩”比较难以令人满意，尤其是类型的卸载，条件 相当苛刻，但是这部分区域的回收确实是有必要的。在Sun公司的BUG列表中，曾出 现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全冋收而导 致内存泄漏。</p><p>  根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。</p><h2 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6 运行时常量池"></a>1.6 运行时常量池</h2><p>运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有 类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池(Constant Pool Table),用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后存放 到方法区的运行时常量池中。</p><p>  Java虚拟机对Class文件的每一部分(自然也包括常量池)的格式都有严格的规 定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、 装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的 提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除 了保存Class文件中描述的符号引用外,还会把翻译出来的直接引用也存储在运行时常 量池中七</p><p>  运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性,Java语 言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容 才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中,这种特性被开发 人员利用得比较多的便是String类的intern。方法。</p><p>既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无 法再申请到内存时会抛出OutOfMemoryError异常。</p><h2 id="1-7-直接内存"><a href="#1-7-直接内存" class="headerlink" title="1.7 直接内存"></a>1.7 直接内存</h2><p>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分,也不是Java 虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError异常出现，所以我们放到这里一起讲解。</p><p>  在JDK 1.4中新加入了 NIO (New Input&#x2F;Output)类，引入了一种基于通道(Channel) 与缓冲区(Buffer)的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然 后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行 操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来 回复制数据。</p><p>  显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则 肯定还是会受到本机总内存（包括RAM及SWAP区或者分页文件）的大小及处理器 寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx 等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制 （包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError 异常。</p><h1 id="2-对象访问"><a href="#2-对象访问" class="headerlink" title="2. 对象访问"></a>2. 对象访问</h1><p>介绍完Java虚拟机的运行时数据区之后，我们就可以来探讨一个问题：在Java语 言中，对象访问是如何进行的？对象访问在Java语言中无处不在，是最普通的程序行 为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区 域之间的关联关系，如下面的这句代码：</p><p>Object obj &#x3D; new Object（）；</p><p>  假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java栈 的本地变量表中，作为一个reference类型数据出现。而“new Object（）”这部分的语义 将会反映到Java堆中，形成一块存储了 Object类型所有实例数据值（Instance Data,对 象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布 局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java堆中 还必须包含能査找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地 址信息，这些类型数据则存储在方法区中。</p><p>  由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有 定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此 不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接 指针。</p><ul><li>如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池,reference 中存储的就是对象的句柄地址,而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如图2-2所示。</li></ul><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8(1)%EF%BC%882%EF%BC%89.png"></p><ul><li>如果使用直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息,reference中直接存储的就是对象地址,如图2-3所示。</li></ul><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8(1)%EF%BC%883%EF%BC%89.png"></p><p>  这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存 储的是稳定的句柄地址,在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只 会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><p>  使用直接指针访问方式的最大好处就是速度更快,它节省了一次指针定位的时间开 销,由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就虚拟机Sun HotSpot而言，它是使用第二种方式进行对象 访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分 常见。</p><h1 id="3-实战：OutOfMemoryError-异常"><a href="#3-实战：OutOfMemoryError-异常" class="headerlink" title="3. 实战：OutOfMemoryError 异常"></a>3. 实战：OutOfMemoryError 异常</h1><p>在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区 域都有发生OutOfMemoryError （下文称OOM）异常的可能，本节将通过若干实例来验 证异常发生的场景（代码清单2-1至代码清单2-6的几段简单代码），并且会初步介绍几 个与内存相关的最基本的虚拟机参数。</p><p>  本节内容的目的有两个：第一，通过代码验证Java虚拟机规范中描述的各个运行 时区域储存的内容；第二，希望读者在工作中遇到实际的内存溢出异常时，能根据异常 的信息快速判断是哪个区域的内存溢出，知道怎样的代码可能会导致这些区域的内存溢 出，以及出现这些异常后该如何处理。</p><p>  下面代码的开头都注释了执行时所需要设置的虚拟机启动参数（注释中“VMArgs” 后面跟着的参数），这些参数对实验的结果有直接影响，请读者调试代码的时候不要忽 略掉。如果读者使用控制台命令来执行程序，那直接跟在Java命令之后书写就可以。如果使用Eclipse IDE,则可以参考图2-4在Debug&#x2F;Run页签中的设置。</p><p>  下文的代码都是基于Sun HotSpot 17.1-b03 （JDK 1.6 Update 22中带的虚拟机）运 行的，对于不同公司的不同版本的虚拟机，参数和程序运行的结果可能会有所差别。</p><h2 id="3-1-Java堆溢出"><a href="#3-1-Java堆溢出" class="headerlink" title="3.1 Java堆溢出"></a>3.1 Java堆溢出</h2><p>Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象 之间有可达路径来避免垃圾回收机制清除这些对象,就会在对象数量到达最大堆的容量限制后产生内存溢出异常。</p><p>  代码清单2-1中限制Java堆的大小为20MB,不可扩展（将堆的最小值-Xms参 数与最大值-Xmx参数设置为一样即可避免堆自动扩展）,通过参数-XX:+HeapDump OnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储 快照以便事后进行分析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">List&lt;OOMObject&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">OOMObject</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8(1)%EF%BC%884%EF%BC%89.png"></p><p>运行参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio&#x3D;8</p><p><img src="https://image.buretuzi.online/blog/article/jvm/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8(1)%EF%BC%885%EF%BC%89.png"></p><p>  Java堆内存的OOM异常是实际应用中最常见的内存溢出异常情况。出现Java堆内存溢出时，异常堆栈信息”java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space</p><p>  要解决这个区域的异常，一般的手段是首先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转储快照进行分析，重点是确认内存中的对象是 否是必要的,也就是要先分清楚到底是出现了内存泄漏(Memory Leak)还是内存溢 出(Memory Overflow)o 图 2-5 显示了使用 Eclipse Memory Analyzer 打开的堆转储快照文件。</p><p>  如果是内存泄漏，可进一步通过工具査看泄漏对象到GC Roots的引用链。于是就 能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收 它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确 地定位出泄漏代码的位置。</p><p>  如果不存在泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检査 虚拟机的堆参数(-Xmx与-Xms),与机器物理内存对比看是否还可以调大，从代码上 检査是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期 的内存消耗。</p><h2 id="3-2-虚拟机栈和本地方法栈溢出"><a href="#3-2-虚拟机栈和本地方法栈溢出" class="headerlink" title="3.2 虚拟机栈和本地方法栈溢出"></a>3.2 虚拟机栈和本地方法栈溢出</h2><p>  由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来 说，-Xoss参数（设置本地方法栈大小）虽然存在，但实际上是无效的,栈容量只由-Xss 参数设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError 异常。</li><li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError 异常。</li></ul><p>  这里把异常分成两种情况看似更加严谨，但却存在着一些互相重叠的地方：当栈空 间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一 件事情的两种描述而已。</p><p>  在笔者的实验中，如果将实验范围限制于单线程中的操作，尝试了下面两种方法均无法让虚拟机产生OutOfMemoryError异常，尝试的结果都是获得StackOverflowError 异常，测试代码如清单2-2所示。</p><ul><li>使用-Xss参数减少栈内存容量。结果：抛出StackOverflowError异常，异常出现 时输出的栈深度相应缩小。</li><li>定义了大量的本地变量，增加此方法帧中本地变量表的长度。结果：抛出 StackOverflowError异常时输出的栈深度相应缩小。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test.one;</span><br><span class="line"><span class="comment">//别忘了设置运行参数 -Xss128k</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaVMStackSOF</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">stackLength</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stackLeak</span><span class="params">()</span> &#123;</span><br><span class="line">stackLength++;</span><br><span class="line">stackLeak();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">JavaVMStackSOF</span> <span class="variable">oom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaVMStackSOF</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">oom.stackLeak();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;stack length:&quot;</span>+oom.stackLength);</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="hhttps://image.buretuzi.online/blog/article/jvm/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8(1)%EF%BC%886%EF%BC%89.png"></p><p>  实验结果表明：在单个线程下，无论是由于栈帧太大，还是虚拟机栈容量太小，当 内存无法分配的时候，虚拟机抛出的都是StackOverflowEnor异常。</p><p>  如果测试时不限于单线程，通过不断地建立线程的方式倒是可以产生内存溢出异 常，如代码清单2-3所示。但是，这样产生的内存溢出异常与栈空间是否足够大并不存 在任何联系，或者准确地说，在这种情况下，给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。</p><p>  原因其实不难理解，操作系统分配给每个进程的内存是有限制的，譬如32位的 Windows限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。剩余的内存为2GB （操作系统限制）减去Xmx （最大堆容量），再减去MaxPermSize （最大方法区容量），程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈”瓜分” 了。每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。</p><p>  这一点需要在开发多线程应用的时候特别注意，出现StackOverflowError异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机 默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的，所以 只能说大多数情况下）达到1000 - 2000完全没有问题，对于正常的方法调用（包括递 归），这个深度应该完全够用了。但是，如果是建立过多线程导致的内存溢出,在不能 减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换 取更多的线程。如果没有这方面的经验，这种通过“减少内存”的手段来解决内存溢出 的方式会比较难以想到。</p><p>  下面代码还是不要跑了，cpu直接跑满了，系统直接卡死</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test.one;</span><br><span class="line"><span class="comment">//别忘了设置运行参数 -Xss2M</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaVMStackOOM</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dontStop</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stackLeakByThread</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">dontStop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">JavaVMStackOOM</span> <span class="variable">oom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaVMStackOOM</span>();</span><br><span class="line">oom.stackLeakByThread();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意 特别提示一下，如果要尝试运行上面这段代码，记得要先保存当前的工作， 由于在Windows平台的虚拟机中，Java的线程是映射到操作系统的内核线程上的，所 以上述代码执行时有较大的风险，可能会导致操作系统假死。</p><h2 id="3-3-运行时常量池溢出"><a href="#3-3-运行时常量池溢出" class="headerlink" title="3.3 运行时常量池溢出"></a>3.3 运行时常量池溢出</h2><p>如果要向运行时常量池中添加内容，最简单的做法就是使用String.intem()这个 Native方法。该方法的作用是：如果池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通 过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量，如代码清单2-4所示。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test.one;</span><br><span class="line"><span class="comment">//别忘了设置运行参数 -XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeConstantPoolOOM</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">list.add(String.valueOf(i++).intern());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   <img src="https://image.buretuzi.online/blog/article/jvm/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8(1)%EF%BC%887%EF%BC%89.png"></p><h2 id="3-4-方法区溢出"><a href="#3-4-方法区溢出" class="headerlink" title="3.4 方法区溢出"></a>3.4 方法区溢出</h2><p>方法区用于存放Class的相关信息,如类名、访问修饰符、常量池、字段描述、方法描述等。对于这个区域的测试，基本的思路是运行时产生大量的类去填 满方法区，直到溢出。虽然直接使用Java SE API也可以动态产生类(如反射时的 GeneratedConstructorAccessor和动态代理等)，但在本次实验中操作起来比较麻 烦。在代码清单2-5中，笔者借助CGLib®直接操作字节码运行时，生成了大量的动态类。</p><p>  值得特别注意的是，我们在这个例子中模拟的场景并非纯粹是一个实验，这样的应 用经常会出现在实际应用中：当前的很多主流框架，如Spring和Hibernate对类进行增强时，都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证 动态生成的Class可以加载入内存。</p><p>  下面代码还是不要跑了，内存跑满才行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaMethodAreaOOM</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(o,objects);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收掉，判定条件是非常苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了上面提到的程序使用了 GCLib字节码增强外，常见的还有：大量JSP 或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用 （即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p><h2 id="3-5-本机直接内存溢出"><a href="#3-5-本机直接内存溢出" class="headerlink" title="3.5 本机直接内存溢出"></a>3.5 本机直接内存溢出</h2><p>DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆的最大值（-Xmx指定）一样。代码清单2-6越过了 DirectByteBuffer 类，直接通过反射获取Unsafe实例并进行内存分配（Unsafe类的getUnsafe（）方 法限制了只有引导类加载器才会返回实例，也就是设计者希望只有rt.jar中的类 才能使用Unsafe的功能）。因为，虽然使用DirectByteBuffer分配内存也会抛出 内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过 计算得知内存无法分配,于是手动抛出异常，真正申请分配内存的方法是unsafe. allocateMemory()。</p><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h1><p>  通过本章的学习，我们明白了虚拟机里面的内存是如何划分的, 样的代码和操作可能导致内存溢出异常。虽然Java有垃圾收集机制, 我们并不遥远，本章只是讲解了各个区域出现内存溢出异常的原因, Java垃圾收集机制为了避免内存溢出异常的出现都做了哪些努力。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring boot集成solr-SpringBoot（26）</title>
      <link href="/2022/08/17/spring%20boot%E9%9B%86%E6%88%90solr-SpringBoot%EF%BC%8826%EF%BC%89/"/>
      <url>/2022/08/17/spring%20boot%E9%9B%86%E6%88%90solr-SpringBoot%EF%BC%8826%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-了解Solr"><a href="#1-了解Solr" class="headerlink" title="1. 了解Solr"></a>1. 了解Solr</h1><p>Solr是一个独立的企业级搜索应用服务器，对外提供API接口。用户可以通过https请求向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过https GET操作提出查找请求, 并得到XML格式的返回结果。Solr现在支持多种返回结果。</p><h1 id="2-安装配置Solr"><a href="#2-安装配置Solr" class="headerlink" title="2. 安装配置Solr"></a>2. 安装配置Solr</h1><h2 id="2-1Solr安装"><a href="#2-1Solr安装" class="headerlink" title="2.1Solr安装"></a>2.1Solr安装</h2><p>  （1）访问镜像网站，下载Solr压缩包。</p><p>  （2）在下载完成后解压文件，在“cmd”控制台进入”solr&#x2F;bin”目录下，输入”solr start” 命令启动Solr。</p><p>  如果出现以下提示，则表示成功启动。</p><p>  Waiting up to 30 to see Solr running on port 8983<br>  Started Solr server on port 8983. Happy searching!</p><p>  （3）访问 <a href="https://localhost:8983/solr">https://localhost:8983/solr</a> 就可以看到已经启动了。</p><p>常用命令如下。</p><ul><li>停止：”solr stop -p 8983” 或 “solr stop - all”。</li><li>查看运行状态：solr status</li></ul><h2 id="2-2-Solr配置"><a href="#2-2-Solr配置" class="headerlink" title="2.2 Solr配置"></a>2.2 Solr配置</h2><p>  （1）进入Solr 的安装目录下的server&#x2F;solr&#x2F;，创建一个名字为new_core的文件夹。</p><p>  （2）将 conf 目录(在安装目录&#x2F;server&#x2F;solr&#x2F;configsets&#x2F;sample_techproducts_configs 下) 复制到new_core目录下。</p><p>  （3）访问 “<a href="https://localhost:8983/solr/#/&quot;">https://localhost:8983/solr/#/&quot;</a></p><p>    单击导航栏的“Core Admin”，在弹出窗口中单击“Add Core”命令，弹出如图13-8所示的对话框，输入名字和目录名，再单击“Add Core”按钮，完成创建。</p><p><img src="https://image.buretuzi.online/blog/article/springboot/spring%20boot%E9%9B%86%E6%88%90solr-SpringBoot%EF%BC%8826%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><center>图 13-8</center><h1 id="3-整合-Spring-Boot-和-Solr"><a href="#3-整合-Spring-Boot-和-Solr" class="headerlink" title="3. 整合 Spring Boot 和 Solr"></a>3. 整合 Spring Boot 和 Solr</h1><h2 id="（1）添加依赖，见以下代码："><a href="#（1）添加依赖，见以下代码：" class="headerlink" title="（1）添加依赖，见以下代码："></a>（1）添加依赖，见以下代码：</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-solr<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="（2）写入Solr配置"><a href="#（2）写入Solr配置" class="headerlink" title="（2）写入Solr配置"></a>（2）写入Solr配置</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">solr:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">https://localhost:8983/solr/new_core</span></span><br></pre></td></tr></table></figure><h1 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h1><h2 id="1-创建-User-类"><a href="#1-创建-User-类" class="headerlink" title="1.创建 User 类"></a>1.创建 User 类</h2><p>User类必须继承可序列化接口，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.apache.solr.client.solrj.beans.Field;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@Field(&quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="meta">@Field(&quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-测试增加、删除、修改和查询功能"><a href="#2-测试增加、删除、修改和查询功能" class="headerlink" title="2. 测试增加、删除、修改和查询功能"></a>2. 测试增加、删除、修改和查询功能</h2><h3 id="（1）测试増加功能"><a href="#（1）测试増加功能" class="headerlink" title="（1）测试増加功能"></a>（1）测试増加功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/addUser&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addUser</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SolrServerException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="string">&quot;155371&quot;</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;鸡蛋火腿饼&quot;</span>);</span><br><span class="line">    solrClient.addBean(user);</span><br><span class="line">    <span class="type">UpdateResponse</span> <span class="variable">commit</span> <span class="operator">=</span> solrClient.commit();</span><br><span class="line">    <span class="keyword">return</span> commit.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）测试増加功能，根据id查询刚刚添加的内容，见以下代码："><a href="#（2）测试増加功能，根据id查询刚刚添加的内容，见以下代码：" class="headerlink" title="（2）测试増加功能，根据id查询刚刚添加的内容，见以下代码："></a>（2）测试増加功能，根据id查询刚刚添加的内容，见以下代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getByIdFromSolr/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getByIdFromSolr</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> <span class="keyword">throws</span> IOException, SolrServerException &#123;</span><br><span class="line">    <span class="comment">//根据id查询内容</span></span><br><span class="line">    <span class="type">SolrDocument</span> <span class="variable">solrDocument</span> <span class="operator">=</span> solrClient.getById(id);</span><br><span class="line">    <span class="comment">//获取filedname</span></span><br><span class="line">    Collection&lt;String&gt; filedname = solrDocument.getFieldNames();</span><br><span class="line">    Map&lt;String, Object&gt; filedValueMap = solrDocument.getFieldValueMap();</span><br><span class="line">    List&lt;SolrDocument&gt; childDocuments = solrDocument.getChildDocuments();</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> solrDocument.toString();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）测试修改功能，根据id修改内容，见以下代码："><a href="#（3）测试修改功能，根据id修改内容，见以下代码：" class="headerlink" title="（3）测试修改功能，根据id修改内容，见以下代码："></a>（3）测试修改功能，根据id修改内容，见以下代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/updateUser&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updateUser</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SolrServerException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="string">&quot;155371&quot;</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;烤冷面&quot;</span>);</span><br><span class="line">    solrClient.addBean(user);</span><br><span class="line">    <span class="type">UpdateResponse</span> <span class="variable">commit</span> <span class="operator">=</span> solrClient.commit();</span><br><span class="line">    <span class="keyword">return</span> commit.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  所谓Solr的更新操作，就是对相同id的文档重新添加一次。修改之后，Version变得不一样了。</p><h3 id="（4）测试删除功能，根据id删除内容，见以下代码："><a href="#（4）测试删除功能，根据id删除内容，见以下代码：" class="headerlink" title="（4）测试删除功能，根据id删除内容，见以下代码："></a>（4）测试删除功能，根据id删除内容，见以下代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/deleteUser&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SolrServerException &#123;</span><br><span class="line">    <span class="type">UpdateResponse</span> <span class="variable">updateResponse</span> <span class="operator">=</span> solrClient.deleteById(<span class="string">&quot;155371&quot;</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> updateResponse.getElapsedTime();</span><br><span class="line">    <span class="type">int</span> <span class="variable">qTime</span> <span class="operator">=</span> updateResponse.getQTime();</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">requestUrl</span> <span class="operator">=</span> updateResponse.getRequestUrl();</span><br><span class="line">    <span class="comment">//请求的结果</span></span><br><span class="line">    NamedList&lt;Object&gt; response = updateResponse.getResponseHeader();</span><br><span class="line">    <span class="comment">//请求的状态</span></span><br><span class="line">    solrClient.commit();</span><br><span class="line">    <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> updateResponse.getStatus();</span><br><span class="line">    <span class="comment">//成功，则返回0，如果没有文档被删除也会返回0，代表根本没有</span></span><br><span class="line">    <span class="keyword">return</span> String.valueOf(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）实现文档高亮显示，见以下代码："><a href="#（5）实现文档高亮显示，见以下代码：" class="headerlink" title="（5）实现文档高亮显示，见以下代码："></a>（5）实现文档高亮显示，见以下代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/queryAll&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">queryAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SolrServerException &#123;</span><br><span class="line">    <span class="type">SolrQuery</span> <span class="variable">solrQuery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SolrQuery</span>();</span><br><span class="line">    <span class="comment">//设置默认搜索域</span></span><br><span class="line">    solrQuery.setQuery(<span class="string">&quot;*.*&quot;</span>);</span><br><span class="line">    solrQuery.set(<span class="string">&quot;q&quot;</span>,<span class="string">&quot;知然&quot;</span>);</span><br><span class="line">    solrQuery.add(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;知然&quot;</span>);</span><br><span class="line">    <span class="comment">//设置返回结果的排序规则</span></span><br><span class="line">    solrQuery.setSort(<span class="string">&quot;id&quot;</span>,SolrQuery.ORDER.asc);</span><br><span class="line">    <span class="comment">//设置查询的条数</span></span><br><span class="line">    solrQuery.setRows(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">//设置查询的开始</span></span><br><span class="line">    solrQuery.setStart(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//设置分页参数</span></span><br><span class="line">    solrQuery.setStart(<span class="number">0</span>);</span><br><span class="line">    solrQuery.setRows(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//设置高亮</span></span><br><span class="line">    solrQuery.setHighlight(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//设置高亮的字段</span></span><br><span class="line">    solrQuery.addHighlightField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="comment">//设置高亮的样式</span></span><br><span class="line">    solrQuery.setHighlightSimplePre(<span class="string">&quot;&lt;font color=&#x27;red&#x27;&gt;&quot;</span>);</span><br><span class="line">    solrQuery.setHighlightSimplePost(<span class="string">&quot;&lt;/font&gt;&quot;</span>);</span><br><span class="line">    System.out.println(solrQuery);</span><br><span class="line">    <span class="type">QueryResponse</span> <span class="variable">queryResponse</span> <span class="operator">=</span> solrClient.query(solrQuery);</span><br><span class="line">    Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlightMap = queryResponse.getHighlighting();</span><br><span class="line">    <span class="type">SolrDocumentList</span> <span class="variable">documents</span> <span class="operator">=</span> queryResponse.getResults();</span><br><span class="line">    <span class="type">long</span> <span class="variable">numFound</span> <span class="operator">=</span> documents.getNumFound();</span><br><span class="line">    System.out.println(<span class="string">&quot;查询到的文档数量&quot;</span>+numFound);</span><br><span class="line">    <span class="keyword">for</span> (SolrDocument document : documents) &#123;</span><br><span class="line">        System.out.println(document);</span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(highlightMap);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;true&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对比Elasticsearch和Solr："><a href="#对比Elasticsearch和Solr：" class="headerlink" title="对比Elasticsearch和Solr："></a>对比Elasticsearch和Solr：</h1><h2 id="（1）Solr的优点。"><a href="#（1）Solr的优点。" class="headerlink" title="（1）Solr的优点。"></a>（1）Solr的优点。</h2><ul><li>Solr有一个更大、更成熟的用户、开发和页献者社区。</li><li>支持添加多种格式的索引，如：HTML、PDF、微软Office系列软件格式，以及JSON、 XML、CSV等纯文本格式。</li><li>比较成熟、稳定。</li><li>搜索速度更快(不建索引时)。</li><li>Solr利用Zookeeper进行分布式管理，而Elasticsearch自身带有分布式协调管理功能。 如果项目本身使用了 Zookeeper,那Solr可能是最好选择。有时缺点在特点场景下可能会变成优点。</li><li>如果项目后期升级，要朝着Hadoop这块发展，当数据量较大时，用Hadoop处理数据， Solr可以很方便地与Hadoop结合。</li></ul><h2 id="（2）Elasticsearch-的优点。"><a href="#（2）Elasticsearch-的优点。" class="headerlink" title="（2）Elasticsearch 的优点。"></a>（2）Elasticsearch 的优点。</h2><ul><li>Elasticsearch本身是分布式、分发实时的，不需要其他组件。</li><li>Elasticsearch完全支持Apache Lucene的接近实时的搜索。</li><li>它处理多用户不需要特殊配置，而Solr则需要更多的高级设置。</li><li>Elasticsearch采用Gateway的槪念，备份更加简单。各节点组成对等的网络结构，某节点出现故障会自动分配其他节点代替其进行工作。</li></ul><h2 id="（3）Solr的缺点。"><a href="#（3）Solr的缺点。" class="headerlink" title="（3）Solr的缺点。"></a>（3）Solr的缺点。</h2><ul><li>建立索引时，搜索效率下降，实时索引搜索效率不高。</li><li>实时搜索应用效率明显低于Elasticsearch.</li></ul><h2 id="（4）Elasticsearch-的缺点。"><a href="#（4）Elasticsearch-的缺点。" class="headerlink" title="（4）Elasticsearch 的缺点。"></a>（4）Elasticsearch 的缺点。</h2><ul><li>没有Solr的生态系统发达。</li><li>仅支持JSON文件格式。</li><li>本身更注重核心功能，高级功能多由第三方插件提供。</li></ul><p>总结：Solr是传统搜索应用的有力解决方案，但Elasticsearch更适用于新兴的实时搜索应用。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring boot集成Elasticsearch-SpringBoot（25）</title>
      <link href="/2022/08/16/spring%20boot%E9%9B%86%E6%88%90Elasticsearch-SpringBoot%EF%BC%8825%EF%BC%89/"/>
      <url>/2022/08/16/spring%20boot%E9%9B%86%E6%88%90Elasticsearch-SpringBoot%EF%BC%8825%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/># 1. Elasticsearch—搜索应用服务器<h2 id="1-1-什么是搜索引擎"><a href="#1-1-什么是搜索引擎" class="headerlink" title="1.1 什么是搜索引擎"></a>1.1 什么是搜索引擎</h2><p>  搜索引擎(search engine )通常意义上是指：根据特定策略，运用特定的爬虫程序从互联网上搜集信息，然后对信息进行处理后，为用户提供检索服务，将检索到的相关信息展示给用户的系统。</p><p>  而我们讲解的是捜索的索引和检索，不涉及爬虫程序的内容爬取。大部分公司的业务也不会有爬取工作，而只提供查询服务，而且Elasticsearch也只是提供这方面的功能。</p><h2 id="1-2-认识-Elasticsearch"><a href="#1-2-认识-Elasticsearch" class="headerlink" title="1.2 认识 Elasticsearch"></a>1.2 认识 Elasticsearch</h2><p>​   Elasticsearch是一个分布式、RESTful风格的搜索和数据分析引撃。通过它，能够执行及合并多种类型的搜索（结构化数据、非结构化数据、地理位置、指标），解决不新涌现出的各种需求。</p><p>  Elasticsearch使用的是标准的RESTful风格的API,使用JSON提供多种语言（Java、 Python、.Net、SQL和PHP）的支持，它可以快速地存储、搜索和分析海量数据。</p><p>  Elasticsearch是用Java语言开发的，并使用Lucene作为其核心来实现所有索引和搜索的功能。它的目的是：通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p><p>  Elasticsearch是一个开源的高扩展的分布式全文检索引擎，可以近乎实时地存储、检索数据; 本身扩展性很好，允许多台服务器协同工作，每台服务器可以运行多个实例。单个实例称为一个节_点_（node）, 一组节点构成一个集群（cluster）。分片是底层的工作单元，文档保存在分片内，分片又被分配到集群内的各个节点里，每个分片仅保存全部数据的一部分。</p><p>  当Elasticsearch的节点启动后，它会使用多播（multicast）或单播（用户更改了配置）寻找集群中的其他节点，并与之建立连接。</p><h2 id="1-3-Elasticsearch-应用案例"><a href="#1-3-Elasticsearch-应用案例" class="headerlink" title="1.3 Elasticsearch 应用案例"></a>1.3 Elasticsearch 应用案例</h2><ul><li>GitHub： 2013年年初，GitHub把Solr缓存改成了Elasticsearch,以便用户搜索20TB 的数据，包括13亿个文件和1300亿行代码。</li><li>维基百科：启动以Elasticsearch为基础的核心搜索架构SoundCloud，为1.8亿用户提供即时而精准的音乐搜索服务。</li><li>百度：百度使用Elasticsearch作为数据分析引擎，20多个业务税采集服务器上的各类数据及用户自定义数据，通过对各种数据进行多维分析，辅助定位异常。其单集群最大100台机器，200个Elasticsearch节点，每天导入超过30TB的数据。</li></ul><p>除这些公司外，Stack Overflow、新浪、阿里、360、携程、有赞、苏宁都在使用它。它被广泛地用于各大公司的站内搜索、IT系统搜索（OA、CRM、ERP）、数据分析等工作中。</p><h2 id="1-4-对比-Elasticsearch-与-MySQL"><a href="#1-4-对比-Elasticsearch-与-MySQL" class="headerlink" title="1.4 对比 Elasticsearch 与 MySQL"></a>1.4 对比 Elasticsearch 与 MySQL</h2><p>尽管将Elasticsearch与MySQL进行对比并不科学，但是这样的对比能区分Elasticsearch 和MySQL数据库的区别，便于快速用熟悉的知识来理解Elasticsearch 。所以，本节采用对比的方式来讲解Elasticsearch。Elasticsearch与MySQL的结构对比见表13-1。</p><p><img src="https://image.buretuzi.online/blog/article/springboot/spring%20boot%E9%9B%86%E6%88%90Elasticsearch-SpringBoot%EF%BC%8825%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><center>图 13-1</center><ul><li>关系型数据库中的数据库，相当于Elasticsearch中的索引(index )。</li><li>一个数据库下面有多张表(table)，相当于一个索引(index)下面有多个类型(type)。</li><li>一个数据库表(table)下的数据由多行(row)多列(column属性)组成，相当于一个 type由多个文档(document)和多个field组成。</li><li>在关系型数据库中，schema定义了表、每个表的字段，还有表和字段之间的关系；在 Elasticsearch中，mapping定义索引下的type的字段处理规则，即索引如何建立、索引类型、 是否保存原始索引 JSON文档、是否压缩原始JSON文档、是否需要分词处理、如何进行分词处理等。</li><li>在 MySQL 数据库中的增(insert )、删(delete )、改(update )、查 ( select)操作相 当于 Elasticsearch 中的增(put&#x2F;post )、删(delete )、改(update )、查(get）</li></ul><p>  客户端主要通过”方法(PUT&#x2F;POST&#x2F;GET&#x2F; DELETE ) + <a href="https://ip:端口/索引名称/类型/主键”">https://ip:端口/索引名称/类型/主键”</a> 来访问内容。</p><h2 id="1-5-认识-ElasticSearchRepository"><a href="#1-5-认识-ElasticSearchRepository" class="headerlink" title="1.5 认识 ElasticSearchRepository"></a>1.5 认识 ElasticSearchRepository</h2><p>​Spring-data-elasticsearch 是 Spring 提供的操作 Elasticsearch 的数据接口，它封装了大量的基础操作。通过它可以很方便地操作Elasticsearch的数据。</p><p>  通过继承ElasticsearchRepository来完成基本的CRUD及分页操作，和普通的 JPA没有什 么区别。比如下面实体Product的Repository继承ElasticsearchRepository后，可以在 Elasticsearch文档中进行查找和比较等操作。具体使用方法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;User,Long&gt; &#123;</span><br><span class="line">    Optional&lt;User&gt; <span class="title function_">findById</span><span class="params">(Long id)</span>;</span><br><span class="line">    User <span class="title function_">findByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByEmail</span><span class="params">(String email)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  ElasticsearchRepository有几个特有的search方法，用来构建一些Elasticsearch查询， 主要由QueryBuilder和SearchQuery两个参数来完成一些特殊查询。</p><p>  实现类NativeSearchQuery实现了 QueryBuilder和SearchQuery方法，要构建复杂查询， 可以通过构建NativeSearchQuery类来实现。</p><p>  —般情况下，不是直接新建NativeSearchQuery类，而是使用NativeSearchQueryBuilder 来完成NativeSearchQuery的构建。具体用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NativeSearchQueryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>();</span><br><span class="line">builder.withQuery()</span><br><span class="line">    .withFilter()</span><br><span class="line">    .withSort()</span><br><span class="line">    .withXXX().build();</span><br></pre></td></tr></table></figure><h2 id="1-6-认识-ElasticsearchTemplate"><a href="#1-6-认识-ElasticsearchTemplate" class="headerlink" title="1.6 认识 ElasticsearchTemplate"></a>1.6 认识 ElasticsearchTemplate</h2><p>  ElasticsearchTemplate是Spring对Elasticsearch的API进行的封装，主要用来对索引进行创建、删除等操作。它继承了 ElasticsearchOperations 和 ApplicationContextAware 接口。 ElasticSearchTemplate 提供一些比 ElasticsearchRepository 更底层的方法。</p><p>  ElasticsearchOperations接口中常用的方法如下。</p><pre><code>*   createlndex()方法：创建索引，返回值为布尔类型数据。*   indexExists()方法：查询索引是否存在，返回值为布尔类型数据。*   putMapping()方法:  创建映射，返回值为布尔类型数据。*   getMapping()方法：得到映射，返回值为一个Map数据。*   deletelndex()方法：删除索引，返回值为布尔类型数据。</code></pre><h2 id="1-7-认识注解-Document"><a href="#1-7-认识注解-Document" class="headerlink" title="1.7 认识注解@Document"></a>1.7 认识注解@Document</h2><p>注解@Document作用于类，用于标记实体类为文档对象。</p><p>  存储在Elasticsearch中的一条数据，即是一个文档，类似关系型数据库的一行数据。 Elasticsearch会索引每个文档的内容，以便搜索。它使用JSON格式，将数据存储到Elasticsearch 中，实际上是将JSON格式的字符串发送给了 Elasticsearch。</p><h3 id="1-document的核心元数据"><a href="#1-document的核心元数据" class="headerlink" title="1.document的核心元数据"></a>1.document的核心元数据</h3><p>  document有三个核心元数据，分别是 _index、_type、_id</p><p>  （1）_index。代表一个document存放在哪个index中，类似的数据放在一个索引中，非类似的数据放在不同的索引中。index中包含了很多类似的document,这些document的field很大一 部分是相同的。索引名称必须小写，不能用下画线开头，不包含逗号。</p><p>  （2）_type。代表document属于index的哪个类别，一个索引通常会划分为多个type，逻辑 index不同的数据进行分类。type名称可以是大写或小写，但是不能用下画线开头，不能包含逗号。</p><p>  （3）_id。代表document的唯一标识，与_index和_type —起可以标识和定位一个 document。默认自动创建id,也可以手动指定document的id。</p><h3 id="2-document-id的手动指定和自动生成"><a href="#2-document-id的手动指定和自动生成" class="headerlink" title="2.document id的手动指定和自动生成"></a>2.document id的手动指定和自动生成</h3><h4 id="（1）手动指定-document-id"><a href="#（1）手动指定-document-id" class="headerlink" title="（1）手动指定 document id"></a>（1）手动指定 document id</h4><p>  如果需要从某些其他系统中导入一些数据到Elasticsearch,则会采用手动指定id的形式，因 为一般情况下系统中已有数据的唯一标识，可以用作Elasticsearch中的document的id。</p><p>  其语法格式为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">put /index/type/id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;json&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）自动生成-document-id"><a href="#（2）自动生成-document-id" class="headerlink" title="（2）自动生成 document id"></a>（2）自动生成 document id</h4><p>其语法格式为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">post /index/type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;json&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  自动生成的id长度为20个字符，URL安全、Base64编码、GUID、分布式系统并行生成时不会发生冲突。</p><h3 id="3-document的-source元数据，以及定制返回结果"><a href="#3-document的-source元数据，以及定制返回结果" class="headerlink" title="3. document的_source元数据，以及定制返回结果"></a>3. document的_source元数据，以及定制返回结果</h3><p>  _source元数据是在创建document时放在body中的JSON数据。在默认情况下，查找数据时会返回全部数据。如果要定制返回结果，则可以指定_source中返回哪些field</p><p>  例如：</p><p>  <code>GET /_index/_type/1?_source=field</code></p><h2 id="1-8-管理索引"><a href="#1-8-管理索引" class="headerlink" title="1.8 管理索引"></a>1.8 管理索引</h2><h3 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1. 创建索引"></a>1. 创建索引</h3><h4 id="（1）根据类的信息自动生成创建索引"><a href="#（1）根据类的信息自动生成创建索引" class="headerlink" title="（1）根据类的信息自动生成创建索引"></a>（1）根据类的信息自动生成创建索引</h4><p>下面代码是根据实体类创建一个名为 “ec” 的索引，并定义type是“product”。由于是单机环境，所以定义副本为0，分片为默认值5。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;user&quot;,type = &quot;user&quot;,replicas = 0,shards = 5)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释如下。</p><ul><li>indexName :对应索引库名称，可以理解为数据库名。必须小写，否则会报 “org.elasticsearch.indices.InvalidlndexNameException”异常。</li><li>type：对应在索引库中的类型，可以将其理解为“表名”</li><li>shards：分片数量，默认值为5。</li><li>replicas：副本数量，默认值为1。如果是单机环境，则健康状态为“yellow”。如果要成为 “green”，则指定值为0即可。</li></ul><h4 id="（2）手动创建索引"><a href="#（2）手动创建索引" class="headerlink" title="（2）手动创建索引"></a>（2）手动创建索引</h4><p> 可以使用createindex方法手动指定indexName和Settings,再进行映射。在使用前，要先注入ElasticsearchTemplate,使用方法如下。</p><ul><li>根据索引名创建索引：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elasticsearchTemplate.createIndex(&quot;indexname&quot;);</span><br></pre></td></tr></table></figure><ul><li>根据类名创建索引：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elasticsearchTemplate.createIndex(User.class);</span><br></pre></td></tr></table></figure><h3 id="2-查询索引"><a href="#2-查询索引" class="headerlink" title="2. 查询索引"></a>2. 查询索引</h3><ul><li>根据索引名查询：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elasticsearchTemplate.indexExists(&quot;indexname&quot;);</span><br></pre></td></tr></table></figure><ul><li>根据类名查询：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elasticsearchTemplate.indexExists(User.class);</span><br></pre></td></tr></table></figure><h3 id="3-删除索引"><a href="#3-删除索引" class="headerlink" title="3. 删除索引"></a>3. 删除索引</h3><p> 可以根据索引名和类名对索引进行删除。</p><ul><li>根据索引名删除：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elasticsearchTemplate.deleteIndex(&quot;indexname&quot;);</span><br></pre></td></tr></table></figure><ul><li>根据类名删除：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elasticsearchTemplate.deleteIndex(User.class);</span><br></pre></td></tr></table></figure><h2 id="2-用ELK管理Spring-Boot应用程序的日志"><a href="#2-用ELK管理Spring-Boot应用程序的日志" class="headerlink" title="2. 用ELK管理Spring Boot应用程序的日志"></a>2. 用ELK管理Spring Boot应用程序的日志</h2><p>ELK 是 Elasticsearch+Logstash+Kibana 的简称。</p><p>Logstash负责将数据信息从输入端传输到输出端，比如将信息从MySQL传入Elasticsearch, 还可以根据自己的需求在中间加上滤网。Logstash提供了很多功能强大的滤网，以满足各种应用场景。</p><p>Logstash有以下两种工作方式。</p><ul><li>每一台机器启动一个Logstash服务，读取本地的数据文件，生成流传给Elasticsearch。</li><li>Logback引入Logstash包，然后直接生产JSON流，传给一个中心的Logstash服务器，Logstash服务器再传给Elasticsearch，最后，Elasticsearch将其流传给Kibana。</li></ul><p>Kibana是一个开源的分析与可视化平台，和Elasticsearch —起使用。可以用Kibana搜索、 查看、交互存放在Elasticsearch索引里的数据。使用各种不同的图标、表格、地图等，Kibana能够很轻昜地展示高级数据分析与可视化。</p><p>ELK架构为数据分布式存储、日志解析和可视化创建了一个功能强大的管理链。三者相互配合, 取长补短，共同完成分布式大数据处理工作。</p><h2 id="2-1-安装-Elasticsearch"><a href="#2-1-安装-Elasticsearch" class="headerlink" title="2.1 安装 Elasticsearch"></a>2.1 安装 Elasticsearch</h2><p>（1）通过官网下载Elasticsearch。</p><p>（2）在下载完成后，首先将其解压到合适的目录，然后进入解压目录下的bin目录，双击 bat文件启动Elasticsearch。这里需要确保安装的Java版本在1.8及以上。</p><p>（3）访问“<a href="https://localhost:9200/%E2%80%9D%EF%BC%8C%E5%BD%93%E7%9C%8B%E5%88%B0%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%B2JSON%E6%A0%BC%E5%BC%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E6%97%B6%EF%BC%8C%E5%88%99%E8%AF%B4%E6%98%8E%E5%B7%B2%E7%BB%8F%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%E4%BA%86%E3%80%82">https://localhost:9200/”，当看到返回一串JSON格式的代码时，则说明已经安装成功了。</a></p><p>  根据应用需要，还可以安装Elasticsearch必要的一些插件，如Head、kibana、IK (中文分 词)、graph。</p><h2 id="2-2-安装-Logstash"><a href="#2-2-安装-Logstash" class="headerlink" title="2.2 安装 Logstash"></a>2.2 安装 Logstash</h2><h3 id="1-安装-Logstash"><a href="#1-安装-Logstash" class="headerlink" title="1. 安装 Logstash"></a>1. 安装 Logstash</h3><p>(1)访问 Elasticsearch 官网下载 Logstash</p><p>    (2)将下载文件解压到自定义的目录即可。</p><h3 id="2-配置-Logstash"><a href="#2-配置-Logstash" class="headerlink" title="2. 配置 Logstash"></a>2. 配置 Logstash</h3><p>(1 )在解压文件的config目录下新建log4j_to_es.conf文件，写入以下代码：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">input</span> &#123;</span><br><span class="line"><span class="string">beats</span> &#123;</span><br><span class="line"><span class="string">port</span> <span class="string">=&gt;</span> <span class="number">5044</span></span><br><span class="line"><span class="string">codec</span> <span class="string">=&gt;</span> <span class="string">&quot;json&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">output</span> &#123;</span><br><span class="line"><span class="string">elasticsearch</span> &#123;</span><br><span class="line"><span class="string">hosts</span> <span class="string">=&gt;</span> <span class="string">&quot;127.0.0.1:9200&quot;</span></span><br><span class="line"><span class="string">codec</span> <span class="string">=&gt;</span> <span class="string">json</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里一定要注意:这是UTF-8的格式，不要帯BOM。如果启动时岀现错误，则可以用“logstash -f ..&#x2F;config&#x2F;xxx.conf -t“命令检查配置文件是否错误。</p><p>  （2）新建文件 run.bat。写入代码 logstash -f .\config\log4j_to_es.conf保存。然后双击该配置文件，启动Logstash。</p><p>    (3)访问 localhost:9600 如出现以下內容，则代表配置成功。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;host&quot;</span>:<span class="string">&quot;DESKTOP-0VSQ1JE&quot;</span>,<span class="string">&quot;version&quot;</span>:<span class="string">&quot;8.3.3&quot;</span>,<span class="string">&quot;https_address&quot;</span>:<span class="string">&quot;127.0.0.1:9600&quot;</span>,</span><br><span class="line"> <span class="string">&quot;id&quot;</span>:<span class="string">&quot;f9a14845-005b-42f2-8725-9b3f67dafe86&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;DESKTOP-0VSQ1JE&quot;</span>,</span><br><span class="line"> <span class="string">&quot;ephemeral_id&quot;</span>:<span class="string">&quot;9ffa0b64-c9bb-4385-8924-6565b4cd8167&quot;</span>,<span class="string">&quot;status&quot;</span>:<span class="string">&quot;green&quot;</span>,</span><br><span class="line"> <span class="string">&quot;snapshot&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;pipeline&quot;</span>:&#123;<span class="string">&quot;workers&quot;</span>:<span class="number">8</span>,<span class="string">&quot;batch_size&quot;</span>:<span class="number">125</span>,<span class="string">&quot;batch_delay&quot;</span>:<span class="number">50</span>&#125;,</span><br><span class="line"> <span class="string">&quot;build_date&quot;</span>:<span class="string">&quot;2022-07-23T19:31:54Z&quot;</span>,<span class="string">&quot;build_sha&quot;</span>:<span class="string">&quot;0205f0c5f2ff21118c161e769e8f2bbb79ee81a3&quot;</span>,</span><br><span class="line"> <span class="string">&quot;build_snapshot&quot;</span>:<span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-安装Kibana"><a href="#2-3-安装Kibana" class="headerlink" title="2.3 安装Kibana"></a>2.3 安装Kibana</h2><p>Kibana是官方推出的Elasticsearch数据可视化工具。</p><p>  （1）通过访问Elasticsearch官网下载Kibana。</p><p>  （2）解压下载的压缩文件，进入解压目录，双击Kibana目录的bin&#x2F;kibana.bat，以启动 Kibana,当岀现以下提示时，代表启动成功。</p><p>  [2022-08-16T16:30:45.443+08:00][INFO ][status] Kibana is now available (was degraded)</p><p>  （3）访问localhost:5601就可以逬入Kibana控制台。</p><p>  单击控制台左边导航栏的“Dev-tools”按钮，可以进入Dev-tools界面。单击”Get to work”, 然后在控制台输入“GET&#x2F;_cat&#x2F;health?”命令，可以查看服务器状态。如果在右侧返回的结果中看到green或yellow ,则表示服务器状态正常。</p><h2 id="2-4-配置-Spring-Boot-项目"><a href="#2-4-配置-Spring-Boot-项目" class="headerlink" title="2.4 配置 Spring Boot 项目"></a>2.4 配置 Spring Boot 项目</h2><p>(1)添加项目依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）添加配置文件logback.xml,这里在Spring Boot项目里添加一个配置又件，见以下代码:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;LOGSTASH&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">destination</span>&gt;</span>localhost:9601<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LogstashEncoder&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125;[%thread]%-5level %logger - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;LOGSTASH&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-5-创建日志计划任务"><a href="#2-5-创建日志计划任务" class="headerlink" title="2.5 创建日志计划任务"></a>2.5 创建日志计划任务</h2><p>在Spring Boot项目中创建logTest类,用于测试将日志通过Logstash发送到Elasticsearch, 见以下代码：</p><h1 id="3-Spring-Boot集成Elasticsearch"><a href="#3-Spring-Boot集成Elasticsearch" class="headerlink" title="3. Spring Boot集成Elasticsearch"></a>3. Spring Boot集成Elasticsearch</h1><p>  实现增加、删除、修改、查询文档的功能</p><h2 id="3-1-集成-Elasticsearch"><a href="#3-1-集成-Elasticsearch" class="headerlink" title="3.1 集成 Elasticsearch"></a>3.1 集成 Elasticsearch</h2><p>Spring Boot 提供了 Starter ( spring-boot-starter-data-elasticsearch )来集成 Elasticsearch</p><ul><li>优点：开发速度快，不要求熟悉Elasticsearch的一些API,能快速上手。即使之前对 Elasticsearch不了解，也能通过方法名或SQL语句快速写岀自己需要的逻辑。而具体转换成API层的操作则是由框架底层实现的。</li><li>缺点：使用的Spring Boot的版本Elasticsearch的版本也有了要求，不能超过某些版本号，在部署时需要注意。如果采用API方式，则能解决这个问题。</li></ul><h3 id="（1）添加依赖"><a href="#（1）添加依赖" class="headerlink" title="（1）添加依赖"></a>（1）添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（2）添加application-yml配置"><a href="#（2）添加application-yml配置" class="headerlink" title="（2）添加application.yml配置"></a>（2）添加application.yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">elasticsearch:</span></span><br><span class="line">      <span class="attr">repositories:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#是否开启本地存储</span></span><br><span class="line">      <span class="attr">cluster-nodes:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9200</span></span><br><span class="line">      <span class="attr">cluster-name:</span> <span class="string">elasticsearch</span></span><br></pre></td></tr></table></figure><h2 id="3-2-创建实体"><a href="#3-2-创建实体" class="headerlink" title="3.2 创建实体"></a>3.2 创建实体</h2><h3 id="（1）创建实体"><a href="#（1）创建实体" class="headerlink" title="（1）创建实体"></a>（1）创建实体</h3><p>这里根据类的信息自动生成，也可以手动指定索引名称。ElasticsearchTemplate中提供了创建素引的API,因为进行本机测试，没做集群，所以replicas副本先设置为0。见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Document;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Field;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.FieldType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Document(indexName = &quot;ec&quot;,replicas = 0,shards = 5,type = &quot;product&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//@Id注解必须是org.springframework.data.annotation.Id;</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">//ik_max_word使用ik分词器</span></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text,analyzer = &quot;ik_max_word&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//在存储数据时，不会对category进行分词</span></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line">    <span class="comment">//价格</span></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Double)</span></span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line">    <span class="comment">//index = false 表示不建立索引</span></span><br><span class="line">    <span class="meta">@Field(index = false,type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String images;</span><br><span class="line">    <span class="keyword">private</span> String body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释如下，</p><ul><li>@ld注解：作用于成员变量，标记一个字段作为id主键。</li><li>@Field注解：作用于成员变量，标记为文档的字段，需要指定字段映射属性type。</li><li>index：是否索引，布尔类型，默认为true。</li><li>store：是否存储，布尔类型，默认为false,</li><li>analyzer；分词器名称，这里的ik_max_word即使用IK分词器。</li></ul><h3 id="（2）创建数据操作接口"><a href="#（2）创建数据操作接口" class="headerlink" title="（2）创建数据操作接口"></a>（2）创建数据操作接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.Product;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductRepository</span> <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;Product,Long&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Optional&lt;Product&gt; <span class="title function_">findById</span><span class="params">(Long id)</span>;</span><br><span class="line">    Product <span class="title function_">findByName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-实现增加、删除、修改和查询文档的功能"><a href="#3-3-实现增加、删除、修改和查询文档的功能" class="headerlink" title="3.3 实现增加、删除、修改和查询文档的功能"></a>3.3 实现增加、删除、修改和查询文档的功能</h2><p>在测试类中，实Elasticsearch文档进行增加、删除、修改和查询的功能，见以下代码：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.Product;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.repository.ProductRepository;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.QueueBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Sort;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElasticApplicationTests</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">PAGESIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductRepository productRepository;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(id,<span class="string">&quot;红富士&quot;</span>,<span class="string">&quot;水果&quot;</span>,<span class="number">7.99</span>,<span class="string">&quot;jpg&quot;</span>,<span class="string">&quot;测试&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            productRepository.save(product);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(product.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getProduct</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productRepository.findByName(<span class="string">&quot;红富士&quot;</span>);</span><br><span class="line">        System.out.println(product.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateProduct</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1660653233939L</span>;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(id,<span class="string">&quot;烤冷面&quot;</span>,<span class="string">&quot;小吃&quot;</span>,<span class="number">7.00</span>,<span class="string">&quot;jpg&quot;</span>,<span class="string">&quot;测试&quot;</span>);</span><br><span class="line">        productRepository.save(product);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getProductById</span><span class="params">()</span>&#123;</span><br><span class="line">        Optional&lt;Product&gt; product = productRepository.findById(<span class="number">1660653233939L</span>);</span><br><span class="line">        System.out.println(product.get().getName()+product.get().getBody());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteProduct</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1660653233939L</span>;</span><br><span class="line">        productRepository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">        Iterable&lt;Product&gt; list = productRepository.findAll(Sort.by(<span class="string">&quot;id&quot;</span>).ascending());</span><br><span class="line">        <span class="keyword">for</span> (Product product : list) &#123;</span><br><span class="line">            System.out.println(product);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-Elasticsearch查询"><a href="#4-Elasticsearch查询" class="headerlink" title="4. Elasticsearch查询"></a>4. Elasticsearch查询</h1><h2 id="4-1-自定义方法"><a href="#4-1-自定义方法" class="headerlink" title="4.1 自定义方法"></a>4.1 自定义方法</h2><p>可以根据Spring Data提供的方法名称，实现自己想自定义的查询功能：无须写实现类，只要继承ElasticsearchRepository接口即可。如”findByTitle”表示根据”title”进行查询，具体方法见表13~2</p><p><img src="https://image.buretuzi.online/blog/article/springboot/spring%20boot%E9%9B%86%E6%88%90Elasticsearch-SpringBoot%EF%BC%8825%EF%BC%89%EF%BC%882%EF%BC%89.png"></p><center>图 13-2</center><p><img src="https://image.buretuzi.online/blog/article/springboot/spring%20boot%E9%9B%86%E6%88%90Elasticsearch-SpringBoot%EF%BC%8825%EF%BC%89%EF%BC%883%EF%BC%89.png"></p><center>图 13-3</center><p>  如果要查询价格在7 ~ 8元的商品,则可以在接口类加上”List<Product> findByPriceBetween(Double min, Double max);”方法，见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductRepository</span> <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;Product,Long&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    List&lt;Product&gt; <span class="title function_">findByPriceBetween</span><span class="params">(Double min, Double max)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  然后，在测试类中直接使用自定义的”findByPriceBetween”方法查询出数据，见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryByPriceBetween</span><span class="params">()</span>&#123;</span><br><span class="line">    Iterable&lt;Product&gt; list = productRepository.findByPriceBetween(<span class="number">7.00</span>,<span class="number">8.00</span>);</span><br><span class="line">    <span class="keyword">for</span> (Product product : list) &#123;</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-精准查询"><a href="#4-2-精准查询" class="headerlink" title="4.2 精准查询"></a>4.2 精准查询</h2><h3 id="1-单参数-termQuery"><a href="#1-单参数-termQuery" class="headerlink" title="1.单参数 termQuery"></a>1.单参数 termQuery</h3><p>用法见以下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QueueBuilder queueBuilder = QueueBuilder.termQuery(&quot;字段名&quot;,&quot;查询值&quot;);</span><br></pre></td></tr></table></figure><p>它是不分词查询。因为不分词，所以汉字只能查询一个字，而多字母的英语单词算一个字</p><p>具体实现见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryByPriceBetween</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">NativeSearchQueryBuilder</span> <span class="variable">nativeSearchQueryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>();</span><br><span class="line">    nativeSearchQueryBuilder.withQuery(QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;富&quot;</span>));</span><br><span class="line">    <span class="comment">//查询词，只能查询一个汉字，或一个英文单词</span></span><br><span class="line">    Page&lt;Product&gt; page = productRepository.search(nativeSearchQueryBuilder.build());</span><br><span class="line">    <span class="comment">//搜索，获取结果</span></span><br><span class="line">    <span class="keyword">for</span> (Product product : page)&#123;</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-多参数–termsQuery"><a href="#2-多参数–termsQuery" class="headerlink" title="2.多参数–termsQuery"></a>2.多参数–termsQuery</h3><p>terms可以提供n个查询的参数对一个字段进行查询，用法见以下代码。注意，这里是term的复数形式terms</p><p>  QueueBuilder queueBuilder &#x3D; QueueBuilder.termsQuery(“字段名”,”查询值”,”查询值”);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryByPriceBetween</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">NativeSearchQueryBuilder</span> <span class="variable">nativeSearchQueryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>();</span><br><span class="line">    nativeSearchQueryBuilder.withQuery(QueryBuilders.termsQuery(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;富&quot;</span>,<span class="string">&quot;帅&quot;</span>));</span><br><span class="line">    <span class="comment">//查询词，只能查询一个汉字，或一个英文单词</span></span><br><span class="line">    Page&lt;Product&gt; page = productRepository.search(nativeSearchQueryBuilder.build());</span><br><span class="line">    <span class="comment">//搜索，获取结果</span></span><br><span class="line">    <span class="keyword">for</span> (Product product : page)&#123;</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-分词查询–-matchQuery"><a href="#3-分词查询–-matchQuery" class="headerlink" title="3.分词查询– matchQuery"></a>3.分词查询– matchQuery</h3><p>分词查询采用默认的分词器.用法见以下代码</p><p>  QueueBuilder queueBuilder &#x3D; QueueBuilder.matchQuery(“字段名”,”查询值”);</p><p>  具体实现见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchQuery</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;&#125;&#123;</span><br><span class="line">    <span class="type">NativeSearchQueryBuilder</span> <span class="variable">nativeSearchQueryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>();</span><br><span class="line">    nativeSearchQueryBuilder.withQuery(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;红士&quot;</span>));</span><br><span class="line">    <span class="comment">//查询词</span></span><br><span class="line">    Page&lt;Product&gt; page = productRepository.search(nativeSearchQueryBuilder.build());</span><br><span class="line">    <span class="comment">//搜索，获取结果</span></span><br><span class="line">    <span class="keyword">for</span> (Product product : page)&#123;</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-多字段查询-multiMatchQuery"><a href="#4-多字段查询-multiMatchQuery" class="headerlink" title="4.多字段查询 multiMatchQuery"></a>4.多字段查询 multiMatchQuery</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchQuery</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">NativeSearchQueryBuilder</span> <span class="variable">nativeSearchQueryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>();</span><br><span class="line">    nativeSearchQueryBuilder.withQuery(QueryBuilders.multiMatchQuery(<span class="string">&quot;红富士Gila&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;body&quot;</span>));</span><br><span class="line">    <span class="comment">//查询词</span></span><br><span class="line">    Page&lt;Product&gt; page = productRepository.search(nativeSearchQueryBuilder.build());</span><br><span class="line">    <span class="comment">//搜索，获取结果</span></span><br><span class="line">    <span class="keyword">for</span> (Product product : page)&#123;</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-模糊查询"><a href="#4-3-模糊查询" class="headerlink" title="4.3 模糊查询"></a>4.3 模糊查询</h2><p>  常见的模糊查询的方法有4种</p><h3 id="1-左右模糊"><a href="#1-左右模糊" class="headerlink" title="1.左右模糊"></a>1.左右模糊</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QueryBuilders.queryStringQuery(&quot;查询值&quot;).field(&quot;字段名&quot;)</span><br></pre></td></tr></table></figure><p>   具体实现见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchQuery</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">NativeSearchQueryBuilder</span> <span class="variable">nativeSearchQueryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>();</span><br><span class="line">    nativeSearchQueryBuilder.withQuery(QueryBuilders.queryStringQuery(<span class="string">&quot;我觉得红富士好吃&quot;</span>).field(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    <span class="comment">//查询词</span></span><br><span class="line">    Page&lt;Product&gt; page = productRepository.search(nativeSearchQueryBuilder.build());</span><br><span class="line">    <span class="comment">//搜索，获取结果</span></span><br><span class="line">    <span class="keyword">for</span> (Product product : page)&#123;</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-前缀查询—-prefixQuery"><a href="#2-前缀查询—-prefixQuery" class="headerlink" title="2. 前缀查询— prefixQuery"></a>2. 前缀查询— prefixQuery</h3><p>如果字段没分词，则匹配整个字段前缀，用法见以下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QueryBuilders.prefixQuery(&quot;字段名&quot;,&quot;查询值&quot;)</span><br></pre></td></tr></table></figure><p>  具体实现见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchQuery</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">NativeSearchQueryBuilder</span> <span class="variable">nativeSearchQueryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>();</span><br><span class="line">    nativeSearchQueryBuilder.withQuery(QueryBuilders.prefixQuery(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;士&quot;</span>));</span><br><span class="line">    <span class="comment">//查询词</span></span><br><span class="line">    Page&lt;Product&gt; page = productRepository.search(nativeSearchQueryBuilder.build());</span><br><span class="line">    <span class="comment">//搜索，获取结果</span></span><br><span class="line">    <span class="keyword">for</span> (Product product : page)&#123;</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-通配符查询-wildcard-query"><a href="#3-通配符查询-wildcard-query" class="headerlink" title="3. 通配符查询  wildcard query"></a>3. 通配符查询  wildcard query</h3><p>使用通配符方式进行查询，支持通配符”*“和”？“，”*“代表任意字符串，”？ ”代表任意一个字符。</p><p>  （1）使用通配符”*“</p><p>  通配符可以匹配多个值，用法见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchQuery</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">NativeSearchQueryBuilder</span> <span class="variable">nativeSearchQueryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>();</span><br><span class="line">    nativeSearchQueryBuilder.withQuery(QueryBuilders.wildcardQuery(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;*士&quot;</span>));</span><br><span class="line">    <span class="comment">//查询词</span></span><br><span class="line">    Page&lt;Product&gt; page = productRepository.search(nativeSearchQueryBuilder.build());</span><br><span class="line">    <span class="comment">//搜索，获取结果</span></span><br><span class="line">    <span class="keyword">for</span> (Product product : page)&#123;</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （2）使用通配符“？”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchQuery</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">NativeSearchQueryBuilder</span> <span class="variable">nativeSearchQueryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>();</span><br><span class="line">    nativeSearchQueryBuilder.withQuery(QueryBuilders.wildcardQuery(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;红富?&quot;</span>));</span><br><span class="line">    <span class="comment">//查询词</span></span><br><span class="line">    Page&lt;Product&gt; page = productRepository.search(nativeSearchQueryBuilder.build());</span><br><span class="line">    <span class="comment">//搜索，获取结果</span></span><br><span class="line">    <span class="keyword">for</span> (Product product : page)&#123;</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-分词模糊査询-fuzzy-query"><a href="#4-分词模糊査询-fuzzy-query" class="headerlink" title="4. 分词模糊査询   fuzzy query"></a>4. 分词模糊査询   fuzzy query</h3><p>分词模糊查询即匹配截取字符串为字前或后加1个词的文档，这里通过增加fuzziness (模糊) 属性来查询，fuzziness的含义是检索的term前后增加或减少n个词的匹配查询。用法见以下代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QueryBuilders.fuzzyQuery(&quot;字段名&quot;,&quot;查询值&quot;).fuzziness(Fuzziness.ONE)</span><br></pre></td></tr></table></figure><p>  具体实现见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchQuery</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">NativeSearchQueryBuilder</span> <span class="variable">nativeSearchQueryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>();</span><br><span class="line">    nativeSearchQueryBuilder.withQuery(QueryBuilders.fuzzyQuery(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;士&quot;</span>).fuzziness(Fuzziness.ONE));</span><br><span class="line">    <span class="comment">//查询词</span></span><br><span class="line">    Page&lt;Product&gt; page = productRepository.search(nativeSearchQueryBuilder.build());</span><br><span class="line">    <span class="comment">//搜索，获取结果</span></span><br><span class="line">    <span class="keyword">for</span> (Product product : page)&#123;</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-相似内容推荐"><a href="#5-相似内容推荐" class="headerlink" title="5. 相似内容推荐"></a>5. 相似内容推荐</h3><p>相似内容的推荐是给定一篇文档信息，然后向用户推荐与该文档相似的文档。通过 Elasticsearch的More like this查询接口，可以非常方便地实现基于内容的推荐，用法见以下代码: QueryBuilders.moreLikeThisQuery(new StnngQ (“WfiS”}).addLikeText(“@i®ffi”);</p><p>  如果不指定字段名，则默认全部，常用在相似内容的推荐上。</p><p>  QueryBuilders.moreLikeThisQuery(new String[]{“字段名”}).addLikeText(“查询值”)</p><h2 id="4-4-范围查询"><a href="#4-4-范围查询" class="headerlink" title="4.4 范围查询"></a>4.4 范围查询</h2><p>  闭区间查询：QueryBuilders.rangeQuery(“字段名”).from(“值1”).to(“值2”)</p><p>  开区间查询：QueryBuilders.rangeQuery(“字段名”).from(“值1”).to(“值2”).includeLower(false).includeUpper(false)</p><p>  大于：QueryBuilders.rangeQuery(“字段名”).gt(“查询值”)</p><p>  大于或等于：QueryBuilders.rangeQuery(“字段名”).gte(“查询值”)</p><p>  小于：QueryBuilders.rangeQuery(“字段名”).lt(“查询值”)</p><p>  小于或等于：QueryBuilders.rangeQuery(“字段名”).lte(“查询值”)</p><h2 id="4-5-组合查询"><a href="#4-5-组合查询" class="headerlink" title="4.5 组合查询"></a>4.5 组合查询</h2><p>组合查询是可以设置多个条件的查询方式，用来组合多个查询。有4种方式。</p><ul><li>must：代表文档必须完全匹配条件，相当于and,会参与计算分值。</li><li>mustnot：代表必须不满足匹配条件。</li><li>filter：代表返回的文档必须满足filter条件，但不会参与计算分值。</li><li>should：代表返回的文档可能满足条件，也可能不满足条件，有多个should时满足任何一 个就可以，相当于or,可以通过minimum_should_match设置至少满足几个。</li></ul><h2 id="4-6-分页查询"><a href="#4-6-分页查询" class="headerlink" title="4.6 分页查询"></a>4.6 分页查询</h2><p>使用NativeSearchQueryBuilder实现分页查询，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchQuery</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">NativeSearchQueryBuilder</span> <span class="variable">nativeSearchQueryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>();</span><br><span class="line">    nativeSearchQueryBuilder.withQuery(QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;富&quot;</span>));</span><br><span class="line">    nativeSearchQueryBuilder.withPageable(PageRequest.of(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">    <span class="comment">//查询词</span></span><br><span class="line">    Page&lt;Product&gt; page = productRepository.search(nativeSearchQueryBuilder.build());</span><br><span class="line">    <span class="comment">//搜索，获取结果</span></span><br><span class="line">    <span class="keyword">for</span> (Product product : page)&#123;</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果要进行排序，只要在分页查询上构建withSort参数即可，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchQuery</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">NativeSearchQueryBuilder</span> <span class="variable">nativeSearchQueryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>();</span><br><span class="line">    nativeSearchQueryBuilder.withQuery(QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;富&quot;</span>));</span><br><span class="line">    nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(<span class="string">&quot;id&quot;</span>).order(SortOrder.DESC));</span><br><span class="line">    nativeSearchQueryBuilder.withPageable(PageRequest.of(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">    <span class="comment">//查询词</span></span><br><span class="line">    Page&lt;Product&gt; page = productRepository.search(nativeSearchQueryBuilder.build());</span><br><span class="line">    <span class="comment">//搜索，获取结果</span></span><br><span class="line">    <span class="keyword">for</span> (Product product : page)&#123;</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-7-聚合查询"><a href="#4-7-聚合查询" class="headerlink" title="4.7 聚合查询"></a>4.7 聚合查询</h2><p>聚合(aggregation )是Elasticsearch的一个强大功能，可以极其方便地实现对数据的统计、分析工作。搜索是查找某些具体的文档，聚合就是对这些搜索到的文档进行统计，可以聚合出更加细致的数据。它有两个重要概念。</p><ul><li>Bucket (桶&#x2F;集合)：满足特定条件的文档的集合，即分组。</li><li>Metric (指标&#x2F;度量)：对桶内的文档进行统计计算(最小值、最大值)，简单理解就是进行运算</li></ul><p>聚合由AggregationBuilders类来构建，它提供的静态方法见表13-3</p><p><img src="https://image.buretuzi.online/blog/article/springboot/spring%20boot%E9%9B%86%E6%88%90Elasticsearch-SpringBoot%EF%BC%8825%EF%BC%89%EF%BC%884%EF%BC%89.png"></p><center>图 13-4</center><p>  具体用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;StringTerms.Bucket&gt; searchBybucket()&#123;</span><br><span class="line">    <span class="type">NativeSearchQueryBuilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>();</span><br><span class="line">    queryBuilder.withSourceFilter(<span class="keyword">new</span> <span class="title class_">FetchSourceFilter</span>(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;&quot;</span>&#125;,<span class="literal">null</span>));</span><br><span class="line">    <span class="comment">//指定索引的类型,只先从各分片中查询匹配的文档,再重新排名,取前size个文档</span></span><br><span class="line">    queryBuilder.withSearchType(SearchType.QUERY_THEN_FETCH);</span><br><span class="line">    <span class="comment">//添加一个新的聚合,聚合类型为terms,聚合名称为brands,聚合字段为brand</span></span><br><span class="line">    queryBuilder.addAggregation(AggregationBuilders.terms(<span class="string">&quot;brand&quot;</span>).field(<span class="string">&quot;brand&quot;</span>));</span><br><span class="line">    <span class="comment">//查询,需要把结果强转为Aggregatedpage类型,Aggregatedpage:聚合查询的结果类,它是Page&lt;T&gt;的子接口</span></span><br><span class="line">    AggregatedPage&lt;Product&gt; productsPage = (AggregatedPage&lt;Product&gt;) productRepository.search(queryBuilder.build());</span><br><span class="line">    <span class="comment">//从结果中取出名为brands的聚合解析</span></span><br><span class="line">    <span class="comment">//强转为StringTerm类型</span></span><br><span class="line">    <span class="type">StringTerms</span> <span class="variable">aggregations</span> <span class="operator">=</span> (StringTerms) productsPage.getAggregation(<span class="string">&quot;brands&quot;</span>);</span><br><span class="line">    <span class="comment">//获取桶</span></span><br><span class="line">    List&lt;StringTerms.Bucket&gt; buckets = aggregations.getBuckets();</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span> (StringTerms.Bucket bucket : buckets) &#123;</span><br><span class="line">        <span class="comment">//获取桶中的key</span></span><br><span class="line">        System.out.println(bucket.getKey());</span><br><span class="line">        <span class="comment">//获取桶中的文档数量</span></span><br><span class="line">        System.out.println(bucket.getDocCount());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buckets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  还可以嵌套聚合，在聚合AggregationBuilders中使用subAggregation,用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queryBuilder.addAggregation(AggregationBuilders.terms(<span class="string">&quot;brand&quot;</span>).field(<span class="string">&quot;brand&quot;</span>)</span><br><span class="line">                            .subAggregation(AggregationBuilders.avg(<span class="string">&quot;price_avg&quot;</span>).field(<span class="string">&quot;price&quot;</span>))</span><br><span class="line">                            <span class="comment">//在品牌聚合桶内进行嵌套聚合</span></span><br><span class="line">                           );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring boot集成RabbitMQ-SpringBoot（24）</title>
      <link href="/2022/08/14/spring%20boot%E9%9B%86%E6%88%90RabbitMQ-SpringBoot%EF%BC%8824%EF%BC%89/"/>
      <url>/2022/08/14/spring%20boot%E9%9B%86%E6%88%90RabbitMQ-SpringBoot%EF%BC%8824%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-认识RabbitMQ"><a href="#1-认识RabbitMQ" class="headerlink" title="1. 认识RabbitMQ"></a>1. 认识RabbitMQ</h1><h2 id="1-1介绍RabbitMQ"><a href="#1-1介绍RabbitMQ" class="headerlink" title="1.1介绍RabbitMQ"></a>1.1介绍RabbitMQ</h2><p>RabbitMQ 是开源的高级消息队列协议(Advanced Message Queueing Protocol, AMQP) 的实现，用Erlang 语言编写，支持多种客户端。</p><p>RabbitMQ是目前应用相当广泛的消息中间件(其他同类的消息处理中间件有ActiveMQ、Kafka等)。在企业级应用、微服务应用中，RabbitMQ担当着十分重要的角色。例如，在业务服务模块中解耦、异步通信、高并发限流、超时业务、数据延迟处理等都可以使用RabbitMQ。</p><p>RabbitMQ的处理流程如图12-1所示</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/spring%20boot%E9%9B%86%E6%88%90RabbitMQ-SpringBoot%EF%BC%8824%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><center>图 12-1</center><h2 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h2><h3 id="（1）推送通知"><a href="#（1）推送通知" class="headerlink" title="（1）推送通知"></a>（1）推送通知</h3><p>  “发布&#x2F;订阅”是RabbitMQ的重要功能。可以用”发布&#x2F;订阅”功能来实现通知功能。消费者 (consumer) 一直监听RabbitMQ的数据。如果RabbitMQ有数据，则消费者会按照“先进先岀” 规则逐条进行消费。而生产者(producer)只需要将数据存入RabbitMQ。这样既降低了不同系统之间的耦合度，也确保了消息通知的及时性，且不影响系统的性能。</p><p>  “发布&#x2F;订阅”功能支持三种模式：一对一、一对多、广播。这三种模式都可以根据规则选择分发的对象。众多消费者(consumer)可以根据规则选择是否接收这些数据，扩展性非常强。</p><h3 id="（2）异步任务"><a href="#（2）异步任务" class="headerlink" title="（2）异步任务"></a>（2）异步任务</h3><p>  后台系统接到任务后，将其分解成多个小任务，只要分别完成这些小任务，整个任务便可以完成。但是，如果某个小任务很费时，且延迟执行并不影响整个任务，则可以将该任务放入消息队列中去处理，以便加快请求响应时间。</p><p>  如果用户注册会员时有一项需求一发送验证邮件或短信验证码以完成验证，则可以使用 RabbitMQ的消息队列来实现，这样可以及时提醒用户操作已经成功。等待收到邮件或验证码，然后进行相应的确认，即完成验证。</p><h3 id="（3）多平台应用的通信"><a href="#（3）多平台应用的通信" class="headerlink" title="（3）多平台应用的通信"></a>（3）多平台应用的通信</h3><p>RabbitMQ可以用于不同开发语言开发的应用间的通信(如Java开发的应用程序需要与C++ 开发的应用程序进行通信)，实现企业应用集成。由于消息队列是无关平台和语言的，而且语义上也不是函数调用，因此RabbitMQ适合作为多个应用之间的松耦合的接口，且不需要发送方和接收方同时在线。</p><p>  不同语言的软件解耦，可以最大限度地减少程序之间的相互依赖，提高系统可用性及可扩展性, 同时还增加了消息的可靠传输和事务管理功能。</p><p>RabbitMQ提供两种事务模式：</p><ul><li>AMQP事务模式。</li><li>Confirm事务模式。</li></ul><h3 id="（4）消息延迟"><a href="#（4）消息延迟" class="headerlink" title="（4）消息延迟"></a>（4）消息延迟</h3><p>  利用RabbitMQ消息队列演出功能，可以实现订单、支付过期定时取消功能。因为延迟队列存储延时消息，所以，当消息被发送以后，消费者不是立即拿到消息，而是等待指定时间后才拿到这个消息进行消费。</p><p>  当然，死信、计时器、定时任务也可以实现延退或定时功能，但是需要开发者去处理。</p><p>  要实现消息队列延迟功能，一般釆用官方提供的插件“rabbitmq_delayed_message_ exchange”来实现，但RabbitMQ版本必须是3.5.8版本以上才支持该插件。如果低于这个版本， 则可以利用“死信”来完成。</p><h3 id="（5）远程过程调用"><a href="#（5）远程过程调用" class="headerlink" title="（5）远程过程调用"></a>（5）远程过程调用</h3><p>在实际的应用场景中，有时需要一些同步处理，以等待服务器端将消息处理完成后再进行下一 步处理，这相当于RPC ( Remote Procedure Call,远程过程调用)。RabbitMQ也支持RPC。</p><h2 id="1-3-特性"><a href="#1-3-特性" class="headerlink" title="1.3 特性"></a>1.3 特性</h2><p>RabbitMQ具有以下特性。</p><ul><li>信息确认：RabbitMQ有以下两种应答模式。<ul><li>自动应答：当RabbitMQ把消息发送到接收端，接收端从队列接收消息时，会自动发送应答消息给服务器端。</li><li>手动应答：需要开发人员手动调用方法告诉服务端已经收到。</li></ul></li><li>队列持久化：队列可以被持久化，但是否为持久化，要看持久化设置。</li><li>信息持久化：设置properties.DeliveryMode值即可。默认值为1,代表不是持久的，2代表持久化。</li><li>消息拒收：接收端可以拒收消息，而且在发送”reject”命令时，可以选择是否要把拒收的消息重新放回队列中。</li><li>消息的QoS：在接收端设置的。发送端没有任何变化，接收端的代码也比较简单，只需要加上如 “channel.BasicQos(0,1, false);”的代码即可。</li></ul><p>如果实际场景中对个别消息的丢失不是很敏感，则选用自动应答比较理想。</p><p>如果是一个消息都不能丢的场景，则需要选用手动应答，在正确处理完以后才应答。 如果选择了自动应答，那消息重发这个功能就没有了。</p><h1 id="2-RabbitMQ的基本概念"><a href="#2-RabbitMQ的基本概念" class="headerlink" title="2. RabbitMQ的基本概念"></a>2. RabbitMQ的基本概念</h1><h1 id="2-1-生产者、消费者和代理"><a href="#2-1-生产者、消费者和代理" class="headerlink" title="2.1 生产者、消费者和代理"></a>2.1 生产者、消费者和代理</h1><p>RabbitMQ的角色有以下三种。</p><ul><li>生产者：消息的创建者，负责创建和推送数据到消息服务器。</li><li>消费者：消息的接收方，用于处理数据和确认消息。</li><li>代理：RabbitMQ本身，扮演“快递”的角色，本身不生产消息。</li></ul><p>生产者和消费者并不属于RabbitMQ。RabbitMQ只是为生产者和消费者提供发送和接收消息的API。</p><h2 id="2-2-消息队列"><a href="#2-2-消息队列" class="headerlink" title="2.2 消息队列"></a>2.2 消息队列</h2><p>Queue （队列）是RabbitMQ的内部对象，用于存储生产者的消息直到发送给消费者，也是消费者接收消息的地方。RabbitMQ中的消息也都只能存储在Queue中，多个消费者可以订阅同一 个 Queue。</p><p>Queue有以下一些重要的属性。</p><ul><li>持久性：如果启用，则队列将会在消息协商器（broker）重启前都有效。</li><li>自动删除：如果启用，则队列将会在所有的消费者停止使用之后自动删除掉。</li><li>惰性：如果没有声明队列，则应用程序调用队列时会导致异常，并不会主动声明。</li><li>排他性：如果启用，则声明它的消费者才能使用。</li></ul><h2 id="2-3-交换机"><a href="#2-3-交换机" class="headerlink" title="2.3 交换机"></a>2.3 交换机</h2><p>  Exchange （交换机）用于接收、分配消息。生产者先要指定一个“routing key”，然后将消息发送到交换机。这个”routing key”需要与”Exchange Type”及”binding key”联合使用才能最终生效，然后，交换机将消息路由到一个或多个Queue中，或丢弃。</p><p>  在虚拟主机的消息协商器（broker）中，每个Exchange都有睢一的名字。</p><p>  Exchange包含4种类型：direct、topic、fanout、headers。不同的类型代表绑定到队列的行为不同。</p><h3 id="（1）direct"><a href="#（1）direct" class="headerlink" title="（1）direct"></a>（1）direct</h3><p>direct类型的行为是“先匹配，再投送”。在绑定队列时会设定一个routing key，只有在消息的routing key与队列匹配时，消息才会被交换机投送到绑定的队列中。允许一个队列通过一个固定的routing key （通常是队列的名字）进行绑定。Direct交换机将消息根据其routing key属性投递到包含对应key属性的绑定器上。</p><p>  Direct Exchange是RabbitMQ默认的交换机模式，也是最简单的模式。它根据routing key 全文匹配去寻找队列。</p><h3 id="（2）topic"><a href="#（2）topic" class="headerlink" title="（2）topic"></a>（2）topic</h3><p>  按规则转发消息（最灵活）。主题交换机（topic exchange ）转发消息主要根据通配符。队列和交换机的绑定会定义一种路由模式，通配符就要在这种路由模式和路由键之间匹配后，交换机才能转发消息。</p><p>  在这种交换机模式下，路由键必须是一串字符，用”.“隔开。</p><p>  路由模式必须包含一个星号“*”，主要用于匹配路由键指定位置的一个单词。</p><p>  topic还支持消息的routing key,用”*“或”#“的模式进行绑定。“*”匹配一个单词，“#” 匹配0个或多个单词。例如 “&#x2F;binding key *.user.#”匹配 routing key 为“cn.user“和“us.user.db”, 但是不匹配“user.hello”</p><h3 id="（3）headers"><a href="#（3）headers" class="headerlink" title="（3）headers"></a>（3）headers</h3><p>它根据应用程序消息的特定属性进行匹配，可以在binding key中标记消息为可选或必选。在队列与交换机绑定时，会设定一组键值对规则。消息中也包括一组键值对（headers属性），当这些键值対中有一对，或全部匹配时，消息被投送到对应队列。</p><h3 id="（4）fanout"><a href="#（4）fanout" class="headerlink" title="（4）fanout"></a>（4）fanout</h3><p>消息广播的模式，即将消息广播到所有绑定到它的队列中，而不考虑routing key的值（不管路由键或是路由模式）。如果配置了 routing key。则routing key依然会被忽略。</p><h2 id="2-4-绑定"><a href="#2-4-绑定" class="headerlink" title="2.4 绑定"></a>2.4 绑定</h2><p>  RabbitMQ中通过绑定（binding ）,将Exchange与Queue关联起来。这样 RabbitMQ 就知道如何正确地将消息路由到指定的 Queue <em>了。</em></p><p>  在绑定 Exchange与 Queue时,—般会指定一个binding key。消赛者将消息发送给Exchange 时，一般会指定一个routing key。如果 binding key 与 routing key 相匹配，则消息将会被路由到对应的Queue中。</p><p>  绑定是生产者和消费者消息传递的连接。生产者发送消息到 Exchange，消费者从Queue接收消息，都是根据绑定来执行的。</p><h2 id="2-5-通道"><a href="#2-5-通道" class="headerlink" title="2.5 通道"></a>2.5 通道</h2><p>有些应用需要与AMQP代理建立多个连接。但同时开启多个TCP （ Transmission Control Protocol,传输控制协议）连接会消耗过多的系统资源，并使得防火堵的配置变得更加困难。“AMQP 0-9-1“协议用通道（channel）来处理多连接，可以把通道理解成“共享一个TCP连接的多个轻量化连接”。</p><p>  一个特定通道上的通信与其他通道上的通信是完全隔离的，因此，每个AMQP方法都需要携带一个通道号。这样客户端就可以指定此方法是为哪个通道准备的。</p><h2 id="2-6-消息确认"><a href="#2-6-消息确认" class="headerlink" title="2.6 消息确认"></a>2.6 消息确认</h2><p>消息确认（message acknowledgement ）是指：当一个消息从队列中投递给消费者 （consumer）后，消费者会通知一下消息代理（broker）,这个过程可以是自动的，也可以由处理消息的应用的开发者执行。当“消息确认”启用时，消息代理需要收到来自消费者的确认回执后， 才完全将消息从队列中删除。</p><p>  如果消息无法被成功路由，或被返给发送者并被丢弃，或消息代理执行了延期操作，则消息会 被放入一个“死信”队列中。此时，消息发送者可以选择某些参数来处理这些特殊情况。</p><h1 id="3-RabbitMQ的六种工作模式"><a href="#3-RabbitMQ的六种工作模式" class="headerlink" title="3. RabbitMQ的六种工作模式"></a>3. RabbitMQ的六种工作模式</h1><h2 id="3-1-简单模式"><a href="#3-1-简单模式" class="headerlink" title="3.1 简单模式"></a>3.1 简单模式</h2><p>生产者把消息放入队列，消费者获得消息，如图12-2所示。这个模式只有一个消费者、一个生产者、一个队列，只需要配置主机参数，其他参数使用默认值即可通信。<br><img src="https://image.buretuzi.online/blog/article/springboot/spring%20boot%E9%9B%86%E6%88%90RabbitMQ-SpringBoot%EF%BC%8824%EF%BC%89%EF%BC%882%EF%BC%89.png"></p><center>图 12-2</center><h2 id="3-2-工作队列模式"><a href="#3-2-工作队列模式" class="headerlink" title="3.2 工作队列模式"></a>3.2 工作队列模式</h2><p>  这种模式出现了多个消费者，如图12-3所示。为了保证消费者之间的负载均衡和同步，需要在消息队列之间加上同步功能。</p><p>  工作队列（任务队列）背后的主要思想是：避免立即执行资源密集型任务（耗时），以便下一个任务执行时不用等待它完成。工作队列将任务封装为消息并将其发送到队列中。</p><p><img src="https://image.buretuzi.online/blog/article/springboot/spring%20boot%E9%9B%86%E6%88%90RabbitMQ-SpringBoot%EF%BC%8824%EF%BC%89%EF%BC%883%EF%BC%89.png"></p><center>图 12-3</center><h2 id="3-3-交换机模式"><a href="#3-3-交换机模式" class="headerlink" title="3.3 交换机模式"></a>3.3 交换机模式</h2><p>实际上，前两种模式也使用了交换机，只是使用了采用默认设置的交换机。交换机参数是可以配置的，如果消息配置的交换机参数和RabbitMQ队列绑定（binding ）的交换机名称相同，则转发，否则丢弃，如图12-4所示。</p><p><img src="https://image.buretuzi.online/blog/article/springboot/spring%20boot%E9%9B%86%E6%88%90RabbitMQ-SpringBoot%EF%BC%8824%EF%BC%89%EF%BC%884%EF%BC%89.png"></p><center>图 12-4</center><h2 id="3-4-Routing-转发模式"><a href="#3-4-Routing-转发模式" class="headerlink" title="3.4 Routing 转发模式"></a>3.4 Routing 转发模式</h2><p>交换机要配置为direct类型，转发的规则变为检查队列的routing key值。如果routing key 值相同，则转发，否则丢弃，如图12-5所示。</p><p><img src="https://image.buretuzi.online/blog/article/springboot/spring%20boot%E9%9B%86%E6%88%90RabbitMQ-SpringBoot%EF%BC%8824%EF%BC%89%EF%BC%885%EF%BC%89.png"></p><center>图 12-5</center><h2 id="3-5-主题转发模式"><a href="#3-5-主题转发模式" class="headerlink" title="3.5 主题转发模式"></a>3.5 主题转发模式</h2><p>这种模式下交换机要配置为topic类型，routing key配置失效。发送到主题交换机的信息, 不能是任意routing key,它必须是一个单词的列表，用逗号分隔。特点是可以模糊匹配，匹配规则为：*（星号）可以代替一个词；#（#号）可以代替零个或更多的单词，其模式情况如图12-6 所示。</p><p><img src="https://image.buretuzi.online/blog/article/springboot/spring%20boot%E9%9B%86%E6%88%90RabbitMQ-SpringBoot%EF%BC%8824%EF%BC%89%EF%BC%886%EF%BC%89.png"></p><center>图 12-6</center><h2 id="3-6-RPC-模式"><a href="#3-6-RPC-模式" class="headerlink" title="3.6 RPC 模式"></a>3.6 RPC 模式</h2><p>这种模式主要使用在远程调用的场景下。如果一个应用程序需要另外一个应用程序来最终返回运行结果，那这个过程可能是比较耗时的操作，使用RPC模式是最合适的。其模式情况如图12-7 所示。</p><p><img src="https://image.buretuzi.online/blog/article/springboot/spring%20boot%E9%9B%86%E6%88%90RabbitMQ-SpringBoot%EF%BC%8824%EF%BC%89%EF%BC%887%EF%BC%89.png"></p><center>图 12-7</center><p>6种工作模式的主要特点如下。</p><ul><li>简单模式：只有一个生产者，一个消费者</li><li>工作队列模式：一个生产者，多个消费者，每个消费者获取到的消息唯一。</li><li>订阅模式：一个生产者发送的消息会被多个消费者获取。</li><li>路由模式：发送消息到交换机，并且要指定路由key，消费者在将队列绑定到交换机时需要指定路由key。</li><li>topic模式：根据主题进行匹配，此时队列需要绑定在一个模式上，“#”匹配一个词或多个词，”*“只匹配一个词。</li></ul><h1 id="4-认识AmqpTemplate接口"><a href="#4-认识AmqpTemplate接口" class="headerlink" title="4. 认识AmqpTemplate接口"></a>4. 认识AmqpTemplate接口</h1><p>Spring AMQP提供了操作AMQP协议的模板类AmqpTemplate，用于发送和接收消息, 它定义发送和接收消息等操作，还提供了 RabbitTemplate用于实现AmqpTemplate接口， 而且还提供了错误拋岀类AmqpException，RabbitTemplate支持消息的确认与返回（默认禁用）</p><h2 id="4-1-发送消息"><a href="#4-1-发送消息" class="headerlink" title="4.1 发送消息"></a>4.1 发送消息</h2><h3 id="（1）send方法"><a href="#（1）send方法" class="headerlink" title="（1）send方法"></a>（1）send方法</h3><p>AmqpTemplate模板提供了 send方法用来发送消息，它有以下3个重载：</p><ul><li>void send(Message message) throws AmqpException</li><li>void send(String routingKey, Message message) throws AmqpException</li><li>void send(String exchange, String routingKey, Message message)throws AmqpException</li></ul><h3 id="（2）convertAndSend-方法"><a href="#（2）convertAndSend-方法" class="headerlink" title="（2）convertAndSend 方法"></a>（2）convertAndSend 方法</h3><p>AmqpTemplate模板还提供了 convertAndSend方法用来发送消息。convertAndSend 方法相当于简化了的send方法，可以自动处理消息的序列化。下面通过两个功能一样的代码来比较两者的区别：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;body content&quot;</span>.getBytes())</span><br><span class="line">        .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class="line">        .setMessageId(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        .setHeader(<span class="string">&quot;header&quot;</span>,<span class="string">&quot;header&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    amqpTemplate.send(<span class="string">&quot;QueueHello&quot;</span>,message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span>&#123;</span><br><span class="line">    amqpTemplate.convertAndSend(<span class="string">&quot;QueueHello&quot;</span>,<span class="string">&quot;body content&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面代码和下面代码的效果一样。</p><h2 id="4-2-接收消息"><a href="#4-2-接收消息" class="headerlink" title="4.2 接收消息"></a>4.2 接收消息</h2><p>接收消息可以有两种方式。</p><ul><li>直接去查询获取消息，即调用receive方法。如果该方法没有获得消息，则直接返回null, 因为receive方法不阻塞。</li><li>异步接收，通过注册一个Listener (监听器）来实现消息接收。接收消息需要指定队列 (Queue)，或设置默认的队列。</li></ul><p>  AmqpTemplate提供的直接获得消息的方法是receive</p><p>  另外，AmqpTemplate也提供了直接接收POJO (代替消息对象)的方法receiveAndConvert，并提供了各种的 Messageconverter 用来处理返回的Object (对象)。</p><p>  从 Spring-Rabbit 1.3 版本开始，AmqpTemplate 也提供了 receiveAndReply 方法来异步接收、处理及回复消息。</p><h2 id="4-3-异步接收消息"><a href="#4-3-异步接收消息" class="headerlink" title="4.3 异步接收消息"></a>4.3 异步接收消息</h2><p>Spring AMQP也提供了多种不同的方式来实现异步接收消息，比如常用的通过 MessageListener (消息监听器)的方式来实现。</p><p>   从Spring-rabbit 1.4版本开始，可使用注解@RabbitListener来异步接收消息，它更为简便。 使用方法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;object&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Receiver object&quot;</span>+user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-在Spring-Boot中集成RabbitMQ"><a href="#5-在Spring-Boot中集成RabbitMQ" class="headerlink" title="5. 在Spring Boot中集成RabbitMQ"></a>5. 在Spring Boot中集成RabbitMQ</h1><h2 id="5-1-安装RabbitMQ"><a href="#5-1-安装RabbitMQ" class="headerlink" title="5.1 安装RabbitMQ"></a>5.1 安装RabbitMQ</h2><p>RabbitMQ是用Erlang语言开发的。所以，需要先安装Erlang环境，再安装RabbitMQ。</p><h3 id="1-下载-Erlang-环境和-RabbitMQ"><a href="#1-下载-Erlang-环境和-RabbitMQ" class="headerlink" title="(1)下载 Erlang 环境和 RabbitMQ"></a>(1)下载 Erlang 环境和 RabbitMQ</h3><p>      到Erlang官网下载Erlang环境。</p><p>      到 RabbitMQ 官网下载 RabbitMQ。</p><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="(2)安装"></a>(2)安装</h3><p>      下载完成后，先单击Erlang安装文件进行安装，然后单击RabbitMQ安装文件进行安装。在安装过程中，按照提示一步一步操作即可。在RabbitMQ成功安装后，会自动启动服务器。</p><h3 id="3-开启网页管理界面"><a href="#3-开启网页管理界面" class="headerlink" title="(3)开启网页管理界面"></a>(3)开启网页管理界面</h3><p>      虽然可以在命令行管理RabbitMQ，但稍微麻烦。RabbitMQ提供了可视化的网页管理平台, 可以使用“rabbitmq-plugms.bat enable rabbitmq_management”命令开启网页管理界面。</p><h2 id="5-2-界面化管理RabbitMQ"><a href="#5-2-界面化管理RabbitMQ" class="headerlink" title="5.2 界面化管理RabbitMQ"></a>5.2 界面化管理RabbitMQ</h2><h3 id="（1）概览"><a href="#（1）概览" class="headerlink" title="（1）概览"></a>（1）概览</h3><p>在安装配置完成后，开启网页管理，然后可以通过”<a href="https://localhost:15672/">https://localhost:15672</a>“进行查看和管理, 输入默认的用户名”guest”和密码”guest”进行登录。RabbitMQ的后台界面如图12-8所示。</p><p><img src="https://image.buretuzi.online/blog/article/springboot/spring%20boot%E9%9B%86%E6%88%90RabbitMQ-SpringBoot%EF%BC%8824%EF%BC%89%EF%BC%888%EF%BC%89.png"></p><center>图 12-8</center><h3 id="（2）管理交换机"><a href="#（2）管理交换机" class="headerlink" title="（2）管理交换机"></a>（2）管理交换机</h3><p>进入交换机管理页面后，单击“Add exchange （添加交换机）”按钮，弹出添加界面，可以看到列出了 RabbitMQ 默认的4种类型，由于笔者已经添加了消息延迟插件，所以会有 “x-delayed-message”类型，如图 12-9 所示。</p><p><img src="https://image.buretuzi.online/blog/article/springboot/spring%20boot%E9%9B%86%E6%88%90RabbitMQ-SpringBoot%EF%BC%8824%EF%BC%89%EF%BC%889%EF%BC%89.png"></p><center>图 12-9</center><h3 id="（3）管理管理员"><a href="#（3）管理管理员" class="headerlink" title="（3）管理管理员"></a>（3）管理管理员</h3><p>消息中间件的安全配置也是必不可少的。在RabbitMQ中，可以通过命令行创建用户、设置密码、绑定角色。常用的命令如下。</p><ul><li>rabbitmqctl.bat list_users：查看现有用户。</li><li>rabbitmqctl.bat add_user username password：新増用户。新増的用户只有用户名、密码，没有管理员、超级管理员等角色。</li><li>rabbitmqctl.bat set_user_tags username administrator：设置角色。角色分为 none、 management、policymaker、monitoring、administrator。</li><li>rabbitmqctl change_password userName newPassword：修改密码命令。</li><li>rabbitmqctl.bat delete_user username：删除用户命令。</li></ul><p>还可以在开启RabbitMQ网页管理界面之后，用可视化界面进行操作，如图12-10所示。其 中“Tags”是管理员类型。</p><p>  在创建用户后，需要指定用户访问一个虚拟机（如图12-11所示），并且该用户只能访问该虚拟机下的队列和交换机。如果没有指定，则默认是”No access”,而不是“&#x2F;“（所有）。在一个 RabbitMQ服务器上可以运行多个vhost，以适应不同的业务需要。这样做既可以满足权限配置的要求，也可以避免不同业务之间队列、交换机的命名冲突问题，因为不同vhost之间是隔离的，权限设置可以细化到主题。</p><p><img src="https://image.buretuzi.online/blog/article/springboot/spring%20boot%E9%9B%86%E6%88%90RabbitMQ-SpringBoot%EF%BC%8824%EF%BC%89%EF%BC%8810%EF%BC%89.png"></p><center>图 12-10</center>![](https://image.buretuzi.online/blog/article/springboot/spring%20boot%E9%9B%86%E6%88%90RabbitMQ-SpringBoot%EF%BC%8824%EF%BC%89%EF%BC%8811%EF%BC%89.png)<center>图 12-11</center><h2 id="5-3-在-Spring-Boot-中配置-RabbitMQ"><a href="#5-3-在-Spring-Boot-中配置-RabbitMQ" class="headerlink" title="5.3 在 Spring Boot 中配置 RabbitMQ"></a>5.3 在 Spring Boot 中配置 RabbitMQ</h2><h3 id="（1）添加依赖"><a href="#（1）添加依赖" class="headerlink" title="（1）添加依赖"></a>（1）添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（2）配置-application-properties-文件"><a href="#（2）配置-application-properties-文件" class="headerlink" title="（2）配置 application.properties 文件"></a>（2）配置 application.properties 文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><h1 id="6-在SpringBoot中实现RabbitMQ的四种发送-x2F-接收模式"><a href="#6-在SpringBoot中实现RabbitMQ的四种发送-x2F-接收模式" class="headerlink" title="6. 在SpringBoot中实现RabbitMQ的四种发送&#x2F;接收模式"></a>6. 在SpringBoot中实现RabbitMQ的四种发送&#x2F;接收模式</h1><h2 id="6-1-实例：实现发送和接收队列"><a href="#6-1-实例：实现发送和接收队列" class="headerlink" title="6.1 实例：实现发送和接收队列"></a>6.1 实例：实现发送和接收队列</h2><h3 id="（1）配置队列"><a href="#（1）配置队列" class="headerlink" title="（1）配置队列"></a>（1）配置队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;Queue1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）创建接收者"><a href="#（2）创建接收者" class="headerlink" title="（2）创建接收者"></a>（2）创建接收者</h3><p>注意，发送者和接收者的 Queue 名称必须一致，否则不能接收，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//监听QueueHello的消息队列</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;Queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveA</span> &#123;</span><br><span class="line">    <span class="comment">//@RabbitHandler来实现具体消费</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">QueueReceiver</span><span class="params">(String Queue1)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Receive A：&quot;</span>+Queue1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）创建发送者"><a href="#（3）创建发送者" class="headerlink" title="（3）创建发送者"></a>（3）创建发送者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String content)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sender：&quot;</span>+content);</span><br><span class="line">        <span class="comment">//使用AmqpTemplate将消息发送到消息队列中</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;Queue1&quot;</span>,content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）测试发送和接收情况"><a href="#（4）测试发送和接收情况" class="headerlink" title="（4）测试发送和接收情况"></a>（4）测试发送和接收情况</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">QueueSend</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Queue1 msg&quot;</span>+j+<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendA.send(msg);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试，可以看到控制台输岀如下结果：</p><p>Receive A：Queue1 msg0Sun Aug 14 11:16:45 CST 2022<br>Receive A：Queue1 msg1Sun Aug 14 11:16:45 CST 2022</p><p>上述信息表示发送成功，且接收成功。</p><p>如果是多个接收者，则会均匀地将消息发送到 <em>N</em> 个接收者中，并不是全部发送一遍, 也会和”一对多” 一样，接收端仍然会均匀地接收到消息。</p><h2 id="6-2-实现发送和接收对象"><a href="#6-2-实现发送和接收对象" class="headerlink" title="6.2 实现发送和接收对象"></a>6.2 实现发送和接收对象</h2><h3 id="（1）编辑配置类"><a href="#（1）编辑配置类" class="headerlink" title="（1）编辑配置类"></a>（1）编辑配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">objectQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）编写接收类"><a href="#（2）编写接收类" class="headerlink" title="（2）编写接收类"></a>（2）编写接收类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;object&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Receiver object&quot;</span>+user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）编写发送类"><a href="#（3）编写发送类" class="headerlink" title="（3）编写发送类"></a>（3）编写发送类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectSender</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sender object&quot;</span>+user);</span><br><span class="line">        <span class="built_in">this</span>.amqpTemplate.convertAndSend(<span class="string">&quot;object&quot;</span>,user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）编写测试"><a href="#（4）编写测试" class="headerlink" title="（4）编写测试"></a>（4）编写测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">objectSend</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        user.setMsg(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        objectSender.send(user);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，可以看到控制台输岀如下结果：</p><p>Sender objectUser(id&#x3D;1, msg&#x3D;username)  </p><p>Receiver objectUser(id&#x3D;1, msg&#x3D;username)</p><h2 id="6-3-实例：实现用接收器接收多个主题"><a href="#6-3-实例：实现用接收器接收多个主题" class="headerlink" title="6.3 实例：实现用接收器接收多个主题"></a>6.3 实例：实现用接收器接收多个主题</h2><h3 id="（1）配置topic"><a href="#（1）配置topic" class="headerlink" title="（1）配置topic"></a>（1）配置topic</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">topicA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;topic.a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">topicB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;topic.b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    TopicExchange <span class="title function_">exchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(<span class="string">&quot;topicExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bingTopicA</span><span class="params">(Queue topicA,TopicExchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicA).to(exchange).with(<span class="string">&quot;topic.a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bingTopicB</span><span class="params">(Queue topicB,TopicExchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicB).to(exchange).with(<span class="string">&quot;topic.#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）编写接收者A"><a href="#（2）编写接收者A" class="headerlink" title="（2）编写接收者A"></a>（2）编写接收者A</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.a&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicReceiveA</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;topicReceiveA: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）编写接收者B"><a href="#（3）编写接收者B" class="headerlink" title="（3）编写接收者B"></a>（3）编写接收者B</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.b&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicReceiveB</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;topicReceiveB: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）编写发送者"><a href="#（4）编写发送者" class="headerlink" title="（4）编写发送者"></a>（4）编写发送者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicSender</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="string">&quot;topic&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sender: &quot;</span>+context);</span><br><span class="line">        <span class="built_in">this</span>.amqpTemplate.convertAndSend(<span class="string">&quot;topicExchange&quot;</span>,<span class="string">&quot;topic.1&quot;</span>,context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendToA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="string">&quot;topicToA&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sender: &quot;</span>+context);</span><br><span class="line">        <span class="built_in">this</span>.amqpTemplate.convertAndSend(<span class="string">&quot;topicExchange&quot;</span>,<span class="string">&quot;topic.a&quot;</span>,context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendToB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="string">&quot;topicToB&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sender: &quot;</span>+context);</span><br><span class="line">        <span class="built_in">this</span>.amqpTemplate.convertAndSend(<span class="string">&quot;topicExchange&quot;</span>,<span class="string">&quot;topic.b&quot;</span>,context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）编写测试"><a href="#（5）编写测试" class="headerlink" title="（5）编写测试"></a>（5）编写测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">topic</span><span class="params">()</span>&#123;</span><br><span class="line">    topicSender.send();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">topicA</span><span class="params">()</span>&#123;</span><br><span class="line">    topicSender.sendToA();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">topicB</span><span class="params">()</span>&#123;</span><br><span class="line">    topicSender.sendToB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4-实现广播模式"><a href="#6-4-实现广播模式" class="headerlink" title="6.4 实现广播模式"></a>6.4 实现广播模式</h2><h3 id="（1）配置fanout"><a href="#（1）配置fanout" class="headerlink" title="（1）配置fanout"></a>（1）配置fanout</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;fanoutExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bingFanoutA</span><span class="params">(Queue fanoutA,FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutA).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bingFanoutB</span><span class="params">(Queue fanoutB,FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutB).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）编写发送者"><a href="#（2）编写发送者" class="headerlink" title="（2）编写发送者"></a>（2）编写发送者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutSender</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="string">&quot;Fanout&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sender: &quot;</span> + context);</span><br><span class="line">        <span class="built_in">this</span>.amqpTemplate.convertAndSend(<span class="string">&quot;fanoutExchange&quot;</span>, <span class="string">&quot;&quot;</span>,context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）编写接收者A"><a href="#（3）编写接收者A" class="headerlink" title="（3）编写接收者A"></a>（3）编写接收者A</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.A&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutReceiveA</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fanout ReceiveA: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）编写接收者B"><a href="#（4）编写接收者B" class="headerlink" title="（4）编写接收者B"></a>（4）编写接收者B</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.B&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutReceiveB</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fanout ReceiveB: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）编写测试-1"><a href="#（5）编写测试-1" class="headerlink" title="（5）编写测试"></a>（5）编写测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutSendControllerTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FanoutSender sender;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fanoutSend</span><span class="params">()</span>&#123;</span><br><span class="line">        sender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，可以看到控制台输出如下结果：</p><p>  fanout ReceiveB: Fanout<br>  fanout ReceiveA: Fanout</p><h2 id="6-5-实例：实现消息队列延迟功能"><a href="#6-5-实例：实现消息队列延迟功能" class="headerlink" title="6.5 实例：实现消息队列延迟功能"></a>6.5 实例：实现消息队列延迟功能</h2><p>要实现这个功能，一般使用RabbitMQ的消息队列延迟功能，即采用官方提供的插件 “rabbitmq_delayed_message_exchange”来实现。但 RabbitMQ 版本必须是 3.5.8 以上才支持该插件，否则得用其“死信”功能。</p><h3 id="（1）安装延迟插件"><a href="#（1）安装延迟插件" class="headerlink" title="（1）安装延迟插件"></a>（1）安装延迟插件</h3><p>  用rabbitmq-plugins list命令可以查看安装的插件。如果没有，则直接访问官网进行下载，下载完成后，将其解压到RabbitMQ的plugins目录。</p><p>  然后执行下面的命令进行安装：</p><p>  rabbitmq-plugins enable rabbitmq_delayed_message_exchange</p><h3 id="（2）配置交换机"><a href="#（2）配置交换机" class="headerlink" title="（2）配置交换机"></a>（2）配置交换机</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queueDelay</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delay_queue_1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CustomExchange <span class="title function_">delayExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">    args.put(<span class="string">&quot;x-delayed-type&quot;</span>,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(<span class="string">&quot;delayed_exchange&quot;</span>,<span class="string">&quot;x-delayed-message&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">Binding <span class="title function_">bingDelayB</span><span class="params">(Queue queueDelay,CustomExchange delayExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queueDelay).to(delayExchange).with(<span class="string">&quot;delay_queue_1&quot;</span>).noargs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里要使用 CustomExchange,而不是 DirectExchange。CustomExchange 的类型必须是 x-delayed-message</p><h3 id="（3）实现消息发送"><a href="#（3）实现消息发送" class="headerlink" title="（3）实现消息发送"></a>（3）实现消息发送</h3><p>这里设置消息延迟5s</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomSender</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String queueName, String msg)</span>&#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送时间：&quot;</span>+sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;delayed_exchange&quot;</span>, queueName, msg, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">                <span class="comment">//消息延迟5s</span></span><br><span class="line">                message.getMessageProperties().setHeader(<span class="string">&quot;x-delay&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">                <span class="keyword">return</span> message;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）实现消息接收"><a href="#（4）实现消息接收" class="headerlink" title="（4）实现消息接收"></a>（4）实现消息接收</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;delay_queue_1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        System.out.println(<span class="string">&quot;Received: 执行取消订单&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）测试发送延迟消息"><a href="#（5）测试发送延迟消息" class="headerlink" title="（5）测试发送延迟消息"></a>（5）测试发送延迟消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutSendControllerTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomSender customSender;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        customSender.sendMsg(<span class="string">&quot;delay_queue_1&quot;</span>,<span class="string">&quot;支付超时，取消订单通知!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，可以看到控制台输岀如下结果：</p><p>  消息发送时间：2022-08-14 14:48:41</p><p>  2022-08-14 14:48:46<br>  Received: 执行取消订单支付超时，取消订单通知!</p><p>至此，消息队列延迟功能成功实现。在rabbitmq_delayed_message_exchange插件产生之前，我们大都是使用“死信”功能来达到延迟队列的效果。</p><p>  “死信”在创建Queue（队列）时，要声明“死信”队列。队列里的消息到一定时间没被消费, 就会变成死信转发到死信相应的Exchange或Queue中。</p><p>  延退消息是Exchange到Queue或其他Exchange的延迟。但如果消息延迟到期了，或消息不能被分配给其他的Exchange或Queue,则消息会被丢弃。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用redis和jpa实现缓存文章和点击量-SpringBoot（23）</title>
      <link href="/2022/08/13/%E7%94%A8redis%E5%92%8Cjpa%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E6%96%87%E7%AB%A0%E5%92%8C%E7%82%B9%E5%87%BB%E9%87%8F-SpringBoot%EF%BC%8823%EF%BC%89/"/>
      <url>/2022/08/13/%E7%94%A8redis%E5%92%8Cjpa%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E6%96%87%E7%AB%A0%E5%92%8C%E7%82%B9%E5%87%BB%E9%87%8F-SpringBoot%EF%BC%8823%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h1><p><img src="https://image.buretuzi.online/blog/article/springboot/%E7%94%A8redis%E5%92%8Cjpa%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E6%96%87%E7%AB%A0%E5%92%8C%E7%82%B9%E5%87%BB%E9%87%8F-SpringBoot%EF%BC%8823%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><h1 id="1-实现缓存文章"><a href="#1-实现缓存文章" class="headerlink" title="1. 实现缓存文章"></a>1. 实现缓存文章</h1><h2 id="1-1-实体类"><a href="#1-1-实体类" class="headerlink" title="1.1 实体类"></a>1.1 实体类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Article</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-数据库持久层"><a href="#1-2-数据库持久层" class="headerlink" title="1.2 数据库持久层"></a>1.2 数据库持久层</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.Article;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ArticleMapper</span> &#123;</span><br><span class="line">    Article <span class="title function_">findArticleById</span><span class="params">(Long id)</span>;</span><br><span class="line">    Long <span class="title function_">updateArticle</span><span class="params">(<span class="meta">@Param(&quot;lviews&quot;)</span> Long lviews, <span class="meta">@Param(&quot;lid&quot;)</span> Long lid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-mybatis映射文件"><a href="#1-3-mybatis映射文件" class="headerlink" title="1.3 mybatis映射文件"></a>1.3 mybatis映射文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.intehel.demo.mapper.ArticleMapper&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.intehel.demo.domain.Article&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;num&quot;</span> <span class="attr">property</span>=<span class="string">&quot;num&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--根据参数名称查询参数配置表--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findArticleById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span> &gt;</span></span><br><span class="line">        select * from article where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--根据主键，不存在就新增，已存在就修改--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateArticle&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class="line">        update article set num = #&#123;lviews&#125; where id = #&#123;lid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-4-实现服务层的缓存设置"><a href="#1-4-实现服务层的缓存设置" class="headerlink" title="1.4 实现服务层的缓存设置"></a>1.4 实现服务层的缓存设置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.Article;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.mapper.ArticleMapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachePut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;articleService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleMapper articleMapper;</span><br><span class="line">    <span class="meta">@Cacheable(key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Article <span class="title function_">findArticleById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> articleMapper.findArticleById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@CachePut(key = &quot;#lid&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Article <span class="title function_">updateArticle</span><span class="params">(<span class="meta">@Param(&quot;lviews&quot;)</span> Long lviews, <span class="meta">@Param(&quot;lid&quot;)</span> Long lid)</span> &#123;</span><br><span class="line">        articleMapper.updateArticle(lviews,lid);</span><br><span class="line">        <span class="keyword">return</span> articleMapper.findArticleById(lid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-配置redis"><a href="#1-5-配置redis" class="headerlink" title="1.5 配置redis"></a>1.5 配置redis</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.interceptor.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在缓存对象集合中，缓存是以key-value形式保存的</span></span><br><span class="line">    <span class="comment">//如果没有指定缓存的key，则Spring Boot 会使用SimpleKeyGenerator生成key</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> KeyGenerator <span class="title function_">keyGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyGenerator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">//定义缓存key的生成策略</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">generate</span><span class="params">(Object target, Method method, Object... params)</span> &#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                sb.append(target.getClass().getName());</span><br><span class="line">                sb.append(method.getName());</span><br><span class="line">                <span class="keyword">for</span> (Object obj : params) &#123;</span><br><span class="line">                    sb.append(obj.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//缓存管理器 2.X版本</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; strSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jacksonSeial</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jacksonSeial.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定制缓存数据序列化方式及时效</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofDays(<span class="number">1</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair</span><br><span class="line">                        .fromSerializer(strSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair</span><br><span class="line">                        .fromSerializer(jacksonSeial))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> RedisCacheManager</span><br><span class="line">                .builder(connectionFactory).cacheDefaults(config).build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存管理器 1.X版本</span></span><br><span class="line"><span class="comment">/*    public CacheManager cacheManager(@SuppressWarnings(&quot;rawtypes&quot;)RedisTemplate redisTemplate)&#123;</span></span><br><span class="line"><span class="comment">        return new RedisCacheManager(redisTemplate);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//注册成Bean被Spring管理，如果没有这个Bean，则Redis可视化工具中的中文内容都会以二进制存储，不易检查</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">// 创建JSON格式序列化对象，对缓存数据的key和value进行转换</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="comment">// 解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">//设置redisTemplate模板API的序列化方式为json</span></span><br><span class="line">        template.setDefaultSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        <span class="type">StringRedisTemplate</span> <span class="variable">stringRedisTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>();</span><br><span class="line">        stringRedisTemplate.setConnectionFactory(factory);</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> RedisSerializer&lt;?&gt; keySerializer() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值使用jackson进行序列化</span></span><br><span class="line">    <span class="keyword">private</span> RedisSerializer&lt;?&gt; valueSerializer() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// return new JdkSerializationRedisSerializer();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-实现统计点击量"><a href="#2-实现统计点击量" class="headerlink" title="2. 实现统计点击量"></a>2. 实现统计点击量</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.Article;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.service.ArticleService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/article&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleService articleService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Article <span class="title function_">testPathVariable</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">        <span class="type">Article</span> <span class="variable">article</span> <span class="operator">=</span> articleService.findArticleById(Long.valueOf(id));</span><br><span class="line">        System.out.println(article);</span><br><span class="line">        <span class="keyword">if</span> (article.getNum()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (redisTemplate.opsForValue().get(<span class="string">&quot;num::&quot;</span>+id)!=<span class="literal">null</span>)&#123;</span><br><span class="line">                redisTemplate.opsForValue().increment(<span class="string">&quot;num::&quot;</span>+id, <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.boundValueOps(<span class="string">&quot;num::&quot;</span>+id).increment(article.getNum()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            redisTemplate.boundValueOps(<span class="string">&quot;num::&quot;</span>+id).increment(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> article;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-实现定时同步"><a href="#3-实现定时同步" class="headerlink" title="3.实现定时同步"></a>3.实现定时同步</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.service.ArticleService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountScheduledTasks</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleService articleService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/10 * * * * ?&quot; )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncPostViews</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">StartTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="type">List</span> <span class="variable">dtolist</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        Set&lt;String&gt; keySet = redisTemplate.keys(<span class="string">&quot;num::*&quot;</span>);</span><br><span class="line">        System.out.println(keySet);</span><br><span class="line">        <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">view</span> <span class="operator">=</span> redisTemplate.opsForValue().get(key).toString();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sid</span> <span class="operator">=</span> key.replaceAll(<span class="string">&quot;num::&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="type">Long</span> <span class="variable">lid</span> <span class="operator">=</span> Long.valueOf(sid);</span><br><span class="line">            <span class="type">Long</span> <span class="variable">lviews</span> <span class="operator">=</span> Long.valueOf(view);</span><br><span class="line">            articleService.updateArticle(lviews,lid);</span><br><span class="line">            redisTemplate.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  同时要在启动类中添加注解，开启redis缓存和定时任务：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.intehel.demo&quot;)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot整合redis-SpringBoot（22）</title>
      <link href="/2022/08/12/springboot%E6%95%B4%E5%90%88redis-SpringBoot%EF%BC%8822%EF%BC%89/"/>
      <url>/2022/08/12/springboot%E6%95%B4%E5%90%88redis-SpringBoot%EF%BC%8822%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-在-Spring-Boot-中集成-Redis"><a href="#1-在-Spring-Boot-中集成-Redis" class="headerlink" title="1. 在 Spring Boot 中集成 Redis"></a>1. 在 Spring Boot 中集成 Redis</h1><h2 id="（1）完成配置基础项。"><a href="#（1）完成配置基础项。" class="headerlink" title="（1）完成配置基础项。"></a>（1）完成配置基础项。</h2><p>添加 Redis、MySQL、MyBatis 依赖。</p><h2 id="（2）配置MySQL、Redis服务器"><a href="#（2）配置MySQL、Redis服务器" class="headerlink" title="（2）配置MySQL、Redis服务器"></a>（2）配置MySQL、Redis服务器</h2><p>可以直接在application.yml文件中逬行配置，具体配置方法见以下代码：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">thymeleaf:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">HTML</span></span><br><span class="line">      <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">      <span class="attr">servlet:</span></span><br><span class="line">        <span class="attr">content-type:</span> <span class="string">text/html</span></span><br><span class="line">      <span class="attr">cache:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">prefix:</span> <span class="string">classpath:/static/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment"># spring boot集成mybatis的方式打印sql</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h2 id="（3）在入口类加上-EnableCaching注解，开启缓存支持。"><a href="#（3）在入口类加上-EnableCaching注解，开启缓存支持。" class="headerlink" title="（3）在入口类加上@EnableCaching注解，开启缓存支持。"></a>（3）在入口类加上@EnableCaching注解，开启缓存支持。</h2><h1 id="2-配置Redis类"><a href="#2-配置Redis类" class="headerlink" title="2. 配置Redis类"></a>2. 配置Redis类</h1><p>要想启用Spring缓存支持，需创建一个CacheManager的Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.interceptor.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在缓存对象集合中，缓存是以key-value形式保存的</span></span><br><span class="line">    <span class="comment">//如果没有指定缓存的key，则Spring Boot 会使用SimpleKeyGenerator生成key</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> KeyGenerator <span class="title function_">keyGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyGenerator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">//定义缓存key的生成策略</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">generate</span><span class="params">(Object target, Method method, Object... params)</span> &#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                sb.append(target.getClass().getName());</span><br><span class="line">                sb.append(method.getName());</span><br><span class="line">                <span class="keyword">for</span> (Object obj : params) &#123;</span><br><span class="line">                    sb.append(obj.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//缓存管理器 2.X版本</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> RedisCacheManager.create(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存管理器 1.X版本</span></span><br><span class="line"><span class="comment">/*    public CacheManager cacheManager(@SuppressWarnings(&quot;rawtypes&quot;)RedisTemplate redisTemplate)&#123;</span></span><br><span class="line"><span class="comment">        return new RedisCacheManager(redisTemplate);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//注册成Bean被Spring管理，如果没有这个Bean，则Redis可视化工具中的中文内容都会以二进制存储，不易检查</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        RedisTemplate&lt;String,Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;String,Object&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(factory);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        <span class="type">StringRedisTemplate</span> <span class="variable">stringRedisTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>();</span><br><span class="line">        stringRedisTemplate.setConnectionFactory(factory);</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-创建测试实体类"><a href="#3-创建测试实体类" class="headerlink" title="3.创建测试实体类"></a>3.创建测试实体类</h1><p>  创建用于数据操作的测试实体类，见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-实现实体和数据表的映射关系"><a href="#4-实现实体和数据表的映射关系" class="headerlink" title="4. 实现实体和数据表的映射关系"></a>4. 实现实体和数据表的映射关系</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.Person;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Insert(&quot;insert into person(name, age,address) values(#&#123;name&#125;,#&#123;age&#125;,#&#123;address&#125;)&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">addPerson</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span>String name, <span class="meta">@Param(&quot;age&quot;)</span>String age, <span class="meta">@Param(&quot;address&quot;)</span>String address)</span>;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from person where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    Person <span class="title function_">findById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span>String id)</span>;</span><br><span class="line">    <span class="meta">@Update(&quot;update person set age = #&#123;age&#125;,name = #&#123;name&#125;,address = #&#123;address&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateById</span><span class="params">(Person person)</span>;</span><br><span class="line">    <span class="meta">@Delete(&quot;delete from person where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span>String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-创建Redis缓存服务层"><a href="#5-创建Redis缓存服务层" class="headerlink" title="5. 创建Redis缓存服务层"></a>5. 创建Redis缓存服务层</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.Person;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.mapper.PersonMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheEvict;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachePut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    PersonMapper personMapper;</span><br><span class="line">    <span class="meta">@Cacheable(key = &quot;#p0&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">selectPerson</span><span class="params">(String id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;selectPerson&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> personMapper.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@CachePut(key = &quot;#p0&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePerson</span><span class="params">(Person person)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;updatePerson&quot;</span>);</span><br><span class="line">        personMapper.updateById(person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@CacheEvict(key = &quot;#p0&quot;,allEntries = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deletePerson</span><span class="params">(String id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;deletePerson&quot;</span>);</span><br><span class="line">        personMapper.deleteById(id);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释如下。</p><ul><li>@Cacheable：将查询结果缓存到Redis中。</li><li>key&#x3D;”#p0”：指定传入的第1个参数作为Redis的key。</li><li>@CachePut：指定key, 将更新的结果同步到Redis中。</li><li>@CacheEvict：指定key, 删除缓存数据。</li><li>@allEntries&#x3D;true:方法调用后将立即清除缓存</li></ul><h1 id="6-完成增加、删除、修改和查询测试API"><a href="#6-完成增加、删除、修改和查询测试API" class="headerlink" title="6.完成增加、删除、修改和查询测试API"></a>6.完成增加、删除、修改和查询测试API</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.service.PersonService;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.Person;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    PersonService personService;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">selectPerson</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personService.selectPerson(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">updatePerson</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span>&#123;</span><br><span class="line">        personService.updatePerson(person);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deletePerson</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span>&#123;</span><br><span class="line">        personService.deletePerson(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;delete success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  启动项目，多次访问<a href="https://eocalhost:8080/user/1">https://localhost:8080/user/1</a> 第一次时控制台会出现select信息，代表对数据库进行了查询操作。后面再访问时则不会出现提示，表示没有对数据库执行操作，而是使用 Redis中的缓存数据。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-SpringBoot（21）</title>
      <link href="/2022/08/11/redis-SpringBoot%EF%BC%8821%EF%BC%89/"/>
      <url>/2022/08/11/redis-SpringBoot%EF%BC%8821%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>  Redis是大规模互联网应用常用的内存高速缓存数据库，它的读写速度非常快，据官方 Bench-mark的数据，它读的速度能到11万次&#x2F;秒，写的速度是8.1万次&#x2F;秒。</p><h1 id="1-认识Spring-Cache"><a href="#1-认识Spring-Cache" class="headerlink" title="1. 认识Spring Cache"></a>1. 认识Spring Cache</h1><p>在很多应用场景中通常是获取前后相同或更新不频繁的数据，比如访问产品信息数据、网页数据。如果没有使用缓存，则访问每次需要重复请求数据库，这会导致大部分时间都耗费在数据库查询和方法调用上，因为数据库进行I&#x2F;O操作非常耗费时间，这时就可以利用Spring Cache来解决。</p><p>  Spring Cache是Spring提供的一整套缓存解决方案。它本身并不提供缓存实现，而是提供统 一的接口和代码规范、配置、注解等，以便整合各种Cache方案，使用户不用关心Cache的细节。</p><p>  Spring支持“透明”地向应用程序添加缓存，将缓存应用于方法，在方法执行前检查缓存中是否有可用的数据。这样可以减少方法执行的次数，同时提高响应的速度。缓存的应用方式“透明”， 不会对调用者造成任何干扰。只要通过注解@EnableCaching启用了缓存支持，Spring Boot就会自动处理好缓存的基础配置。</p><p>  Spring Cache作用在方法上。当调用一个缓存方法时，会把该方法参数和返回结果作为一个 “键值对”(key&#x2F;value )存放在缓存中，下次用同样的参数来调用该方法时将不再执行该方法，而是直接从缓存中获取结果进行返回。所以在使用Spring Cache 时,要保证在缓存的方法和方法参数相同时返回相同的结果。</p><h2 id="1-1-声明式缓存注解"><a href="#1-1-声明式缓存注解" class="headerlink" title="1.1 声明式缓存注解"></a>1.1 声明式缓存注解</h2><p>Spring Boot提供的声明式缓存(cache)注解，见表11-1。</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/redis-SpringBoot%EF%BC%8821%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><center>图 11-1</center><h3 id="1-EnableCaching"><a href="#1-EnableCaching" class="headerlink" title="1.@EnableCaching"></a>1.@EnableCaching</h3><p>  标注在入口类上，用于开启缓存。</p><h3 id="2-Cacheable"><a href="#2-Cacheable" class="headerlink" title="2.@Cacheable"></a>2.@Cacheable</h3><p>  可以作用在类和方法上，以键值对的方式缓存类或方法的返回值。键可以有默认策略和自定义策略。</p><p>  @Cacheable注解会先查询是否己经有缓存，如果己有则会使用缓存，如果没有则会执行方法并进行缓存。</p><p>  @Cacheabfe 可以指定 3 个属性—– value、key 和 condition。</p><ul><li><ul><li>value :缓存的名称，在Spring配置文件中定义，必须指定至少一个。如， @Cacheable(value&#x3D; “cache1” )、@Cacheable(value&#x3D;{ “cache1” , “cache2n }。</li><li>key：缓存的key可以为空，如果自定义key,则要按照SpEL表达式编写。可以自动按照方法的参数组合。如，@Cacheable(value&#x3D; “cache1”，key&#x3D; “#id” )</li><li>condition：缓存的条件可以为空，如果自定义condition，则使用SpEL表达式辐写，以返 回true或false值，只有返回true才进行缓存。如，@Cacheable(value&#x3D; “cache1” ,condition&#x3D; “#id.length()&gt;2” )。</li></ul></li></ul><p>  @Cacheable注解的使用方法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(value = &quot;emp&quot;,key = &quot;targetClass + methodName + #p0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Card&gt; <span class="title function_">getCardList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cardRepository.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释如下。</p><ul><li>value是必需的，它指定了缓存存放的位置。</li><li>key使用的是SpEL表达式。</li><li>User实体类一定要实现序列化，否则会报“java.io.NotSerializableException”异常。序 列化可以继承 Serializable,如 public class User implements Serializable。</li></ul><h3 id="3-CachePut"><a href="#3-CachePut" class="headerlink" title="3. @CachePut"></a>3. @CachePut</h3><p>@CachePut标注的方法在执行前不检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。和@Cacheable不同的是， @CachePut每次都会触发真实方法的调用，比如用户更新缓存数据。</p><p>  需要注意的是，该注解的value和key必须与要更新的缓存相同，即与@Cacheable 相同。 具体见下面两段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CachePut(value = &quot;usr&quot;,key = &quot;targetClass + #p0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">update</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(value = &quot;usr&quot;,key = &quot;targetClass + #p0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">save</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-CacheEvict"><a href="#4-CacheEvict" class="headerlink" title="4. @CacheEvict"></a>4. @CacheEvict</h3><p>@CacheEvict用来标注需要清除缓存元素的方法或类。该注解用于触发缓存的清除操作。其属性有value、key、condition、allEntries 和 beforeInvocation。可以用这些属性来指定清除的条件。使用方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(value = &quot;usr&quot;,key = &quot;#p0.id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">save</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheEvict(value = &quot;usr&quot;,key = &quot;#id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheEvict(value = &quot;accountCache&quot;,allEntries = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CacheEvict(value = &quot;accountCache&quot;,beforeInvocation = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Caching"><a href="#5-Caching" class="headerlink" title="5. @Caching"></a>5. @Caching</h3><p>注解@Caching用来组合多个注解标签，有3个属性：cacheable、put 和 evict,用于指定 @Cacheable、@CachePut 和 @CacheEvict。使用方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Caching(cacheable = &#123;@Cacheable(value = &quot;usr&quot;,key = &quot;#p0&quot;),&#125;,</span></span><br><span class="line"><span class="meta">         put = &#123;@CachePut(value = &quot;usr&quot;,key = &quot;#p0&quot;),&#125;,</span></span><br><span class="line"><span class="meta">         evict = &#123;@CacheEvict(value = &quot;usr&quot;,key = &quot;#p0&quot;),&#125;)</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">save</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-实例：用Spring-Cache进行缓存管理"><a href="#1-2-实例：用Spring-Cache进行缓存管理" class="headerlink" title="1.2 实例：用Spring Cache进行缓存管理"></a>1.2 实例：用Spring Cache进行缓存管理</h2><p>本实例展示Spring Cache是如何使用简单缓存(SIMPLE方式)进行缓存管理的。</p><h3 id="（1）添加依赖"><a href="#（1）添加依赖" class="headerlink" title="（1）添加依赖"></a>（1）添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（2）配置缓存管理器"><a href="#（2）配置缓存管理器" class="headerlink" title="（2）配置缓存管理器"></a>（2）配置缓存管理器</h3><p>在application.yml文件中配置目标缓存管理器，支持Ehcache、Generic、Redis、 Jcache 等。这里使用 SIMPLE 方式 “spring: cache: type: SIMPLE”。</p><h3 id="（3）开启缓存功能"><a href="#（3）开启缓存功能" class="headerlink" title="（3）开启缓存功能"></a>（3）开启缓存功能</h3><p>在入口类添加注解@EnableCaching,开启缓存功能。</p><h3 id="（4）在服务实现里编写缓存业务逻辑："><a href="#（4）在服务实现里编写缓存业务逻辑：" class="headerlink" title="（4）在服务实现里编写缓存业务逻辑："></a>（4）在服务实现里编写缓存业务逻辑：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        bookDao.insert(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CachePut(value = &quot;usr&quot;,key = &quot;targetClass + #p0&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">update</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Caching(cacheable = &#123;@Cacheable(value = &quot;usr&quot;,key = &quot;#p0&quot;),&#125;,</span></span><br><span class="line"><span class="meta">            put = &#123;@CachePut(value = &quot;usr&quot;,key = &quot;#p0&quot;),&#125;,</span></span><br><span class="line"><span class="meta">            evict = &#123;@CacheEvict(value = &quot;usr&quot;,key = &quot;#p0&quot;),&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">save</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;usr&quot;,key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;accountCache&quot;,allEntries = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上述代码可以看出，查找用户的方法使用了注解@Cacheable来开启缓存。修改和添加方法使用了注解@CachePut。它是先处理方法，然后把结果进行缓存的。要想删除数据，则需要使用注解@CacheEvict来清空缓存。</p><h3 id="（5）控制器里调用缓存服务"><a href="#（5）控制器里调用缓存服务" class="headerlink" title="（5）控制器里调用缓存服务"></a>（5）控制器里调用缓存服务</h3><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/book&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">insert</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setUsername(<span class="string">&quot;拉行啊&quot;</span>);</span><br><span class="line">        book.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSON.toJSONString(book);</span><br><span class="line">        System.out.println(jsonObject);</span><br><span class="line">        book.setJson(jsonObject);</span><br><span class="line">        bookService.insert(book);</span><br><span class="line">        id = book.getId();</span><br><span class="line">        <span class="keyword">return</span> book.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/get&quot;,method = RequestMethod.GET,produces = &quot;application/json&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setUsername(<span class="string">&quot;拉行啊&quot;</span>);</span><br><span class="line">        book.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/put&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">put</span><span class="params">(<span class="meta">@RequestParam(&quot;upload&quot;)</span>MultipartFile file, RedirectAttributes redirectAttributes)</span>&#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nyr</span> <span class="operator">=</span> dateFormat.format(date);</span><br><span class="line">        <span class="keyword">if</span> (file.getOriginalFilename().endsWith(<span class="string">&quot;.jpg&quot;</span>)||file.getOriginalFilename().endsWith(<span class="string">&quot;.png&quot;</span>)||</span><br><span class="line">                file.getOriginalFilename().endsWith(<span class="string">&quot;.git&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] bytes = file.getBytes();</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> nyr+Math.random()+file.getOriginalFilename();</span><br><span class="line">                <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;./&quot;</span>+s);</span><br><span class="line">                Files.write(path, bytes);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;格式不支持&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(Model model)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;book&quot;</span>,book);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-整合-Ehcache"><a href="#1-3-整合-Ehcache" class="headerlink" title="1.3 整合 Ehcache"></a>1.3 整合 Ehcache</h2><p>Spring Boot支持多种不同的缓存产品。在默认情况下使用的是简单缓存，不建议在正式环境中使用。我们可以配置一些更加强大的缓存，比如Ehcache。Ehcache是一种广泛使用的开源Java分布式缓存，它具有内存和磁盘存储、缓存加载器、缓存扩展、缓存异常处理、GZIP缓存、Servlet过滤器，以及支持REST和SOAP API等特点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &#123;&quot;userCache&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;usr&quot;,key = &quot;targetClass + #p0&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Page&lt;Book&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-整合-Caffeine"><a href="#1-4-整合-Caffeine" class="headerlink" title="1.4 整合 Caffeine"></a>1.4 整合 Caffeine</h2><p>  Caffeine是使用Java 8对Guava缓存的重写版本。它基于LRU算法实现，支持多种缓存过期策略。要使用它，需要在pom.xml文件中增加Caffeine依赖，这样Spring Boot就会自动用 Caffeine替换默认的简单缓存。</p><p>  增加Caffeine依赖的代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  然后配置参数，见以下代码：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">caffeine</span></span><br><span class="line">    <span class="attr">cache-names:</span> <span class="string">myCaffeine</span></span><br><span class="line">    <span class="attr">caffeine:</span></span><br><span class="line">      <span class="attr">spec:</span> <span class="string">maximumSize=1,expireAfterAccess=5s</span></span><br></pre></td></tr></table></figure><p>代码解释如下。</p><ul><li>cache.type:指定使用哪个缓存供应商。</li><li>cache.cache-names：在启动时创建缓存名称（即前面的cacheNames ）。如果有多个名称，则用逗号进行分隔。</li><li>cache.caffeine.spec：这是 Caffeine 缓存的专用配置。</li><li>maximumSize&#x3D;1：最大缓存数量。如果超出最大缓存数量，则保留后进（最新）的，最开始的缓存会被清除。</li><li>expireAfterAccess&#x3D;5s：缓存5s，即缓存在5 s之内没有被使用，就会被清除，在默认情况下，缓存的数据会一直保存在内存中。有些数据可能用一次后很长时间都不会再月，这样会有大量无用的数据长时间占用内存，我们可以通过配置及时清除不需要的缓存。</li></ul><h1 id="2-认识Redis"><a href="#2-认识Redis" class="headerlink" title="2. 认识Redis"></a>2. 认识Redis</h1><h2 id="2-1-对比-Redis-与-Memcached"><a href="#2-1-对比-Redis-与-Memcached" class="headerlink" title="2.1 对比 Redis 与 Memcached"></a>2.1 对比 Redis 与 Memcached</h2><p>Cache可以和Redis一起用，Spring Boot支持把Cache存到Redis里。如果是单服务器， 则用Cache、Ehcache或Caffeine，性能更高也能满足需求。如果拥有服务器集群，则可以使用 Redis,这样性能更高。</p><h3 id="1-Redis"><a href="#1-Redis" class="headerlink" title="1. Redis"></a>1. Redis</h3><p>  Redis是目前使用最广泛的内存数据存储系统之一。它支持更丰富的数据结构，支持数据持久化、事务、HA （高可用High Available）双机集群系统、主从库。</p><p>  Redis是key-value存储系统。它支持的value类型包括String、List、Set、Zset （有序集合）和Hash。这些数据类型都支持push&#x2F;pop、add&#x2F;remove，以及取交集、并集、差集或更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序和算法。</p><p>  Redis会周期性地把更新后的数据写入磁盘，或把修改操作写入追加的记录文件中（RDB和 AOF两种方式），并且在此基础上实现了 master-slave （主从）同步。机器重启后，能通过持久化数据自动重建内存。如果使用Redis作为Cache，则机器宕机后热点数据不会丢失。</p><p>  丰富的数据结构加上Redis兼具缓存系统和数据库等特性，使得Redis拥有更加丰富的应用场景。</p><p>  Redis可能会导致的问题：</p><ul><li><ul><li>缓存和数据库双写一致性问题。</li><li>缓存雪崩问题。</li><li>缓存击穿问题。</li><li>缓存的并发竞争问题。</li></ul></li></ul><p>  Redis为什么快：</p><ul><li><ul><li>纯内存操作。</li><li>单线程操作，避免了频繁的上下文切换。</li><li>采用了非阻塞I&#x2F;O多路复用机制。</li></ul></li></ul><h3 id="2-Memcached"><a href="#2-Memcached" class="headerlink" title="2. Memcached"></a>2. Memcached</h3><p>Memcached的协议简单，它基于Libevent的事件处理，内置内存存储方式。Memcached 的分布式不互相通信，即各个Memcached不会互相通信以共享信息，分布策略由客户端实现。它不会对数据进行持久化，重启Memcached、重启操作系统都会导致全部数据消失。</p><p>  Memcached常见的应用场景一存储一些读取频繁但更新较少的数据，如静态网页、系统配置及规则数据、活跃用户的基本数据和个性化定制数据、实时统计信息等。</p><h3 id="3-比较-Redis-与-Memcached"><a href="#3-比较-Redis-与-Memcached" class="headerlink" title="3. 比较 Redis 与 Memcached"></a>3. 比较 Redis 与 Memcached</h3><p>  （1）关注度。</p><p>    近年来，Redis越来越火热，人们对Redis的关注度越来越高；对 Memcached关注度比较平稳，且有下降的趋势。</p><p>  （2）性能。</p><p>    两者的性能都比较高。</p><p>  （3）数据类型。</p><p>    Memcached的数据结构单一。</p><p>    Redis非常丰富。</p><p>  （4）内存大小。</p><p>    Redis在2.0版本后增加了自己的VM特性，突破物理内存的限制。</p><p>    Memcached可以修改最大可用内存的大小来管理内存，采用LRU算法.</p><p>  （5）可用性。</p><p>    Redis依赖客户端来实现分布式读写，在主从复制时，每次从节点重新连接主节点都要依赖整个快照，无增量复制。Redis不支持自动分片(sharding)。如果要实现分片功能，则需要依赖程序设定一致的散列(hash)机制。</p><p>    Memcached采用成熟的hash或环状的算法，来解决单点故障引起的抖动问题，其本身没有数据冗余机制。</p><p>  （6）持久化。</p><p>    Redis依赖快照、AOF进行持久化。但AOF在增强可靠性的同时，对性能也有所影响。</p><p>    Memcached不支持持久化，通常用来做缓存，以提升性能。</p><p>  （7）value数据大小。</p><p>    Redis的value的最大限制是1GB。</p><p>    Memcached只能保存1MB以内的数据。</p><p>  （8）数据一致性(事务支持)。</p><p>    Memcached在并发场景下用CAS保证一致性。</p><p>    Redis对事务支持比较弱，只能保证事务中的每个操作连续执行。</p><p>  （9）应用场景。</p><p>    Redis：适合数据量较少、性能操作和运算要求高的场景。</p><p>    Memcached：适合提升性能的场景。适合读多与少，如果数据量比较大，则可以采用分片的方式来解决。</p><h2 id="2-2-Redis的适用场景"><a href="#2-2-Redis的适用场景" class="headerlink" title="2.2 Redis的适用场景"></a>2.2 Redis的适用场景</h2><ol><li>高并发的读写</li></ol><p>    Redis特别适合将方法的运行结果放入缓存，以便后续在请求方法时直接去缓存中读取。对执行耗时，且结果不频繁变动的SQL查询的支持极好。</p><p>    在高并发的情况下，应尽暈避免请求直接访问数据库，这时可以使用Redis进行缓冲操作，让请求先访问Redis。</p><ol start="2"><li>计数器</li></ol><p>    电商网站（APP）商品的浏览量、视频网站（APP）视频的播放数等数据都会被统计，以便用于运营或产品分析。为了保证数据实时生效，每次浏览都得+1,这会导致非常高的并发量。这时可以用Redis提供的incr命令来实现计数器功能，这一切在内存中操作，所以性能非常好，非常适用于这些计数场景。</p><ol start="3"><li>排行榜</li></ol><p>    可以利用Redis提供的有序集合数据类，实现各种复杂的排行榜应用。如京东、淘宝的销量榜单，商品按时间、销量排行等。</p><ol start="4"><li>分布式会话</li></ol><p>    在集群模式下，一般都会搭建以Redis等内存数据库为中心的Session （会活）服务，它不再由容器管理，而是由Session服务及内存数据库管理。</p><ol start="5"><li>互动场景</li></ol><p>    使用Redis提供的散列、集合等数据结构，可以很方便地实现网站（APP）中的点赞、踩、关注共同好友等社交场景的基本功能。</p><ol start="6"><li>最新列表</li></ol><p>    Redis可以通过LPUSH在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID,无须查询最新的列表，直接根据ID查找対应的内容即可。</p><h1 id="3-Redis的数据类型"><a href="#3-Redis的数据类型" class="headerlink" title="3. Redis的数据类型"></a>3. Redis的数据类型</h1><p>Redis有5种数据类型，见表11-2。</p><p><img src="https://image.buretuzi.online/blog/article/springboot/redis-SpringBoot%EF%BC%8821%EF%BC%89%EF%BC%882%EF%BC%89.png"></p><center>图 11-2</center><ol><li>字符串（string）</li></ol><p>    Redis字符串可以包含任意类型的数据、字符、整数、浮点数等。</p><p>    一个字符串类型的值的容量有512MB,代表能存储最大512MB的内容。</p><p>    可以使用INCR （DECR、INCRBY）命令来把字符串当作原子计敬器使用。</p><p>    使用APPEND命令在字符串后添加内容。</p><p>    应用场景：计数器。</p><ol start="2"><li>列表（list）</li></ol><p>    Redis列表是简单的字符串列表，按照插入顺序排序。可以通过LPUSH、RPUSH命令添加一个元素到列表的头部或尾部。</p><p>    一个列表最多可以包含以”232-1“（4294967295）个元素。</p><p>    应用场景：取最新_N_个数据的操作、消息队列、删除与过滤、实时分析正在发生的情况，数据统计与防止垃圾邮件（结合Set ）。</p><ol start="3"><li>集合（set）</li></ol><p>    Redis集合是一个无序的、不允许相同成员存在的字符串合集。</p><p>    支持一些服务器端的命令从现有的集合出发去进行集合运算，如合并（并集：union）、求交（交集intersection）、差集，找出不同元素的操作（共同好友、二度好友）。</p><p>    应用场景：Unique操作，可以获取某段时间内所有数据“排重值”，比如用于共同好友、二度好友、统计独立IP、好友推荐等。</p><ol start="4"><li>散列（hash ）</li></ol><p>    Redis hash是字符串字段和字符串值之间的映射，主要用来表示对象，也能够存储许多元素。</p><p>    应用场景：存储、读取、修改用户属性。</p><ol start="5"><li>有序集合（sorted set、zset）</li></ol><p>    Redis有序集合和Redis集合类似，是不包含相同字符串的合集。每个有序集合的成员都关联着一个评分，这个评分用于把有序集合中的成员按最低分到最高分排列（排行榜应用，取TOP <em>N</em> 操作）。</p><p>    使用有序集合，可以非常快捷地完成添加、删除和更新元素的操作。元素是在插入时就排好序 的，所以很快地通过评分（score ）或位次（position ）获得一个范围的元素。</p><p>    应用场景：排行榜应用、取TOP _N_、需要精准设定过期时间的应用（时间戳作为Score）、带有权重的元素（游戏用户得分排行榜）、过期项目处理、按照时间排序等。</p><h1 id="4-用RedisTemplate操作Redis的五种数据类型"><a href="#4-用RedisTemplate操作Redis的五种数据类型" class="headerlink" title="4. 用RedisTemplate操作Redis的五种数据类型"></a>4. 用RedisTemplate操作Redis的五种数据类型</h1><h2 id="4-1-认识opsFor方法"><a href="#4-1-认识opsFor方法" class="headerlink" title="4.1 认识opsFor方法"></a>4.1 认识opsFor方法</h2><p>Spring封装了 RedisTemplate来操作Redis,它支持所有的Redis原生的API，在 RedisTemplate中定义了对5种数据结构的操作方法。</p><ul><li><ul><li>opsForValueQ：操作字符串。</li><li>opsForHashO：操作散列。</li><li>opsForList（）：操作列表。</li><li>opsForSet（）：操作集合。</li><li>opsForZSetO：操作有序集合。</li></ul></li></ul><p>下面通过实例来理解和应用这些方法。这里需要特别注意的是，运行上述方法后要对数据进行清空操作，否则多次运行会导致数据重复操作。</p><h2 id="4-2-操作字符串"><a href="#4-2-操作字符串" class="headerlink" title="4.2 操作字符串"></a>4.2 操作字符串</h2><p>字符串（string ）是Redis最基本的类型。string的一个“key”对应一个”value”，即key-value 键值对。string是二进制安全的，可以存储任何数据（比如图片或序列化的对象）。值最大能存储512MB的数据。一般用于一些复杂的计数功能的缓存。RedisTemplate提供以下操作string的方法。</p><p>  （1）set void set(K key, V value)；get V get(Object key)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;staing&quot;</span>,<span class="string">&quot;somewhere&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">s</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">s2</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;staing&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （2）set void set(K key, V value, long timeout, TimeUnit unit)</p><p>  以下代码设置3 s失效。3 s之内查询有结果，3 s之后查询则返回为null。具体用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">String</span><span class="params">()</span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">s</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">            s = redisTemplate.opsForValue().get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">            s = redisTemplate.opsForValue().get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TimeUnit是java.util.concurrent包下面的一个类，表示给定单元粒度的时间段，常用的颗粒度有：</p><ul><li>小时(TimeUnit.HOURS )</li><li>分钟(TimeUnit.MINUTES ) </li><li>秒(TimeUnit.SECONDS ) </li><li>毫秒(TimeUnit.MILLISECONDS )</li></ul><p>  （3）set void set(K key, V value, long offset)</p><p>  给定key所存储的字符串值，从偏移量 offset开始。具体用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;hello world&quot;</span>,<span class="number">6</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  hello</p><p>  （4）getAndSet V getAndSet(K key, V value)</p><p>  设置键的字符串值，并返回其旧值。具体用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().getAndSet(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hey&quot;</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  world</p><p>  hey</p><p>  （5）append Integer append(K key, String value)</p><p>  如果key已经存在，并且是一个字符串，则该命令将该值追加到字符串的末尾。如果key不存在，则它将被创建并设置为空字符串，因此append在这种特殊情况下类似于set。用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().append(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">        redisTemplate.opsForValue().append(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  hello</p><p>  helloworld   </p><p>  这里一定要注意反序列化配置，否则会报借。</p><p>  （6）size Long size(K key)</p><p>  返回key所对应的value值的长度，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().size(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输岀如下结果：</p><p>  3</p><h2 id="4-3-操作散列"><a href="#4-3-操作散列" class="headerlink" title="4.3 操作散列"></a>4.3 操作散列</h2><p>Redis hash (散列)是一个string类型的field和value的映射表，hash特别适合用于存储对象。value中存放的是结构化的对象.利用这种数据结构，可以方便地操作其中的某个字段。比如在“单点登录”时，可以用这种数据结构存储用户信息。以Cookield作为key,设置30分钟为缓存过期时间，能很好地模拟出类似Session的效果。</p><p>  （1）void putAII(H key, Map&lt;? extends HK, ? extends HV&gt; m)</p><p>    用m中提供的多个散列字段设置到key对应的散列表中，用法见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().putAll(<span class="string">&quot;HASH&quot;</span>,map);</span><br><span class="line">        System.out.println(redisTemplate.opsForHash().entries(<span class="string">&quot;HASH&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  {key1&#x3D;value1, key2&#x3D;value2}</p><p>  （2）void put(H key, HK hashKey, HV value)</p><p>    设置hashKey的值，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;male&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForHash().entries(<span class="string">&quot;redis&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  {name&#x3D;li, sex&#x3D;male}</p><p>  （3）List<HV> values(H key)</p><p>  根据密钥获取整个散列存储的值，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;male&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForHash().values(<span class="string">&quot;redis&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  [li, male]</p><p>  （4）Map&lt;HK, HV&gt; entries(H key)</p><p>  根据密钥获取整个散列存储，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;male&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForHash().entries(<span class="string">&quot;redis&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  {name&#x3D;li, sex&#x3D;male}</p><p>  （5）Long delete(H key, Object… hashKeys)</p><p>  删除给定的hashKeys,用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;male&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForHash().delete(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForHash().entries(<span class="string">&quot;redis&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  1<br>  {sex&#x3D;male}</p><p>  （6）Boolean hasKey(H key, Object hashKey)</p><p>  确定hashKey是否存在，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;male&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForHash().hasKey(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForHash().hasKey(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  true<br>  true</p><p>  （7）HV get(H key, Object hashKey)</p><p>  从键中的散列获取给定hashKey的值，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;male&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForHash().get(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  li</p><p>  （8）Set<HK> keys(H key)</p><p>  获取key所对应的key的值，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;male&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForHash().keys(<span class="string">&quot;redis&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  [sex, name]</p><p>  （9）Long size(H key)</p><p>  获取key所对应的散列表的大小个数，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;redis&quot;</span>,<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;male&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForHash().size(<span class="string">&quot;redis&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  2</p><h2 id="4-4-操作列表"><a href="#4-4-操作列表" class="headerlink" title="4.4 操作列表"></a>4.4 操作列表</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部(左边) 或尾部(右边)。</p><p>    使用list数据结构，可以做简单的消息队列的功能。还可以利用Irange命令，做基于Redis的分页功能，性能极佳。而使用SQL语句做分页功能往往效果扱差。</p><p>  （1）Long leftPushAII(K key, V… values)</p><p>    leftPushAII表示把一个数组插入列表中，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">        redisTemplate.opsForList().leftPushAll(<span class="string">&quot;list&quot;</span>,strings);</span><br><span class="line">        System.out.println(redisTemplate.opsForList().range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输岀如下结果：</p><p>  [3,2,1]</p><p>  （2）Long size(K key)</p><p>    返回存储在键中的列表的长度。如果键不存在，则将其解释为空列表，并返回0。如果key存储的值不是列表，则返回错误。用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">        redisTemplate.opsForList().leftPushAll(<span class="string">&quot;list&quot;</span>,strings);</span><br><span class="line">        System.out.println(redisTemplate.opsForList().size(<span class="string">&quot;list&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输岀如下结果：</p><p>  6</p><p>  （3）Long leftPush(K key, V value)</p><p>    将所有指定的值插入在键的列表的头部，如果键不存在，则在执行推送操作之前将其创建为空列表(从左边插入)。用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForList().leftPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForList().size(<span class="string">&quot;list&quot;</span>));</span><br><span class="line">        redisTemplate.opsForList().leftPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForList().size(<span class="string">&quot;list&quot;</span>));</span><br><span class="line">        redisTemplate.opsForList().leftPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForList().size(<span class="string">&quot;list&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （4）Long rightPush(K key, V value)</p><p>    将所有指定的值插入存储在键的列表的头部。如果键不存在，则在执行推送操作之前将其创建为空列表(从右边插入)。用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForList().rightPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForList().size(<span class="string">&quot;list&quot;</span>));</span><br><span class="line">        redisTemplate.opsForList().rightPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForList().size(<span class="string">&quot;list&quot;</span>));</span><br><span class="line">        redisTemplate.opsForList().rightPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForList().size(<span class="string">&quot;list&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （5）Long rightPushAII(K key, V… values)</p><p>    通过rightPushAII方法向最右边批量添加元素,用法见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">        redisTemplate.opsForList().rightPushAll(<span class="string">&quot;list&quot;</span>,strings);</span><br><span class="line">        System.out.println(redisTemplate.opsForList().range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （6）void set(K key, long index, V value)</p><p>    在列表中index的位置设置value,用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">        redisTemplate.opsForList().rightPushAll(<span class="string">&quot;list&quot;</span>,strings);</span><br><span class="line">        System.out.println(redisTemplate.opsForList().range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">        redisTemplate.opsForList().set(<span class="string">&quot;list&quot;</span>,<span class="number">1</span>,<span class="string">&quot;值&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForList().range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  [1, 2, 3]<br>  [1, 值, 3]</p><p>  （7）Long remove(K key, long count, Object value)</p><p>   从存储在键中的列表，删除给定“count”值的元素的第1个计数事件。其中，参数count的 含义如下。</p><ul><li><ul><li>count&#x3D;0：删除等于value的所有元素。</li><li>count&gt;0：删除等于从头到尾移动的值的元素：</li><li>counK&lt;0：删除等于从尾到头移动的值的元素。</li></ul></li></ul><p>以下代码用于删除列表中第一次出现的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">        redisTemplate.opsForList().rightPushAll(<span class="string">&quot;list&quot;</span>,strings);</span><br><span class="line">        System.out.println(redisTemplate.opsForList().range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">        redisTemplate.opsForList().remove(<span class="string">&quot;list&quot;</span>,<span class="number">1</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForList().range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  [1, 2, 3]<br>  [1, 3]</p><p>  （8）V index(K key, long index)</p><p>    根据下标获取列表中的值(下标从0幵始)，用法见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">        redisTemplate.opsForList().rightPushAll(<span class="string">&quot;list&quot;</span>,strings);</span><br><span class="line">        System.out.println(redisTemplate.opsForList().range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForList().index(<span class="string">&quot;list&quot;</span>,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  [1, 2, 3]<br>  3</p><p>  （9）V leftPop(K key)</p><p>    弹出最左边的元素，弹出之后该值在列表中将不复存在，用法见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">        redisTemplate.opsForList().rightPushAll(<span class="string">&quot;list&quot;</span>,strings);</span><br><span class="line">        System.out.println(redisTemplate.opsForList().range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForList().leftPop(<span class="string">&quot;list&quot;</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForList().range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  [1, 2, 3]<br>  1<br>  [2, 3]</p><p>  （10）V rightPop(K key)</p><p>    弹出最右边的元素，弹出之后该值任列表中将不复存在，用法见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">        redisTemplate.opsForList().rightPushAll(<span class="string">&quot;list&quot;</span>,strings);</span><br><span class="line">        System.out.println(redisTemplate.opsForList().range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForList().rightPop(<span class="string">&quot;list&quot;</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForList().range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  [1, 2, 3]<br>  3<br>  [1, 2]</p><h2 id="4-5-操作集合"><a href="#4-5-操作集合" class="headerlink" title="4.5 操作集合"></a>4.5 操作集合</h2><p>  set是存放不重复值的集合。利用set可以做全局去重的功能。还可以进行交集、并集、<em>差集等</em> 操作，也可用来实现计算共同喜好、全部的喜好、自己独有的喜好等功能。</p><p>  Redis的set是string类型的无序集合，通过散列表实现。</p><p>  （1）Long add(K key, .. values)</p><p>    在无序集合中添加元素，返回添加个数，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;str1&quot;</span>, <span class="string">&quot;str2&quot;</span>&#125;;</span><br><span class="line">        System.out.println(redisTemplate.opsForSet().add(<span class="string">&quot;set1&quot;</span>,strings));</span><br><span class="line">        System.out.println(redisTemplate.opsForSet().add(<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>2</p><p>  3</p><p>  （2）Long remove(K key, Object… values)</p><p>    移除集合中一个或多个成员，用法见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;str1&quot;</span>, <span class="string">&quot;str2&quot;</span>&#125;;</span><br><span class="line">        System.out.println(redisTemplate.opsForSet().add(<span class="string">&quot;set1&quot;</span>,strings));</span><br><span class="line">        System.out.println(redisTemplate.opsForSet().remove(<span class="string">&quot;set1&quot;</span>,strings));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  2</p><p>  0</p><p>  （3）V pop(K key)</p><p>    移除并返回集合中的一个随机元素，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;str1&quot;</span>, <span class="string">&quot;str2&quot;</span>&#125;;</span><br><span class="line">        System.out.println(redisTemplate.opsForSet().add(<span class="string">&quot;set1&quot;</span>,strings));</span><br><span class="line">        System.out.println(redisTemplate.opsForSet().pop(<span class="string">&quot;set1&quot;</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForSet().members(<span class="string">&quot;set1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  2<br>  str2<br>  [str1]</p><p>  （4）Boolean move(K key, V value, K destKey)</p><p>    将member元素移动，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;str1&quot;</span>, <span class="string">&quot;str2&quot;</span>&#125;;</span><br><span class="line">        System.out.println(redisTemplate.opsForSet().add(<span class="string">&quot;set1&quot;</span>,strings));</span><br><span class="line">        redisTemplate.opsForSet().move(<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;set1tostr1&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForSet().members(<span class="string">&quot;set1&quot;</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForSet().members(<span class="string">&quot;set1tostr1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  2<br>  [str2]<br>  [str1]</p><p>  （5）Long size(K key)</p><p>    获取无序集合的大小长度，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;str1&quot;</span>, <span class="string">&quot;str2&quot;</span>&#125;;</span><br><span class="line">        System.out.println(redisTemplate.opsForSet().add(<span class="string">&quot;set&quot;</span>,strings));</span><br><span class="line">        System.out.println(redisTemplate.opsForSet().size(<span class="string">&quot;set&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>_  2_</p><p>_  2_</p><p>（6）Set<V> members(K key)</p><p>    返回集合中的所有成员，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;str1&quot;</span>, <span class="string">&quot;str2&quot;</span>&#125;;</span><br><span class="line">        System.out.println(redisTemplate.opsForSet().add(<span class="string">&quot;set&quot;</span>,strings));</span><br><span class="line">        System.out.println(redisTemplate.opsForSet().members(<span class="string">&quot;set&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>_  2_</p><p>  [str1,str2]</p><p>  （7）Cursor<V> scan(K key, ScanOptions options)</p><p>    遍历Set,用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;str1&quot;</span>, <span class="string">&quot;str2&quot;</span>&#125;;</span><br><span class="line">        System.out.println(redisTemplate.opsForSet().add(<span class="string">&quot;set&quot;</span>,strings));</span><br><span class="line">        Cursor&lt;Object&gt; cursor = redisTemplate.opsForSet().scan(<span class="string">&quot;set&quot;</span>, ScanOptions.NONE);</span><br><span class="line">        <span class="keyword">while</span> (cursor.hasNext()) &#123;</span><br><span class="line">            System.out.println(cursor.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输岀如下结果：</p><p>  2</p><p>  str2</p><p>  str1</p><h2 id="4-6-操作有序集合"><a href="#4-6-操作有序集合" class="headerlink" title="4.6 操作有序集合"></a>4.6 操作有序集合</h2><p>  zset (sorted set,有序集合)也是string类型元素的集合，且不允许重复的成员。每个元素都会关联一个double类型的分数。可以通过分数将该集合中的成员从小到大进行排序。</p><p>  zset的成员是唯一的，但权重参数分数(score)却可以重复。集合中的元素能够按score进行排列。它可以用来做排行榜应用、取TOP <em>N</em> 延时任务、范围查找等。</p><p>  （1）Long add(K key, Set&lt;TypedTuple<V>&gt;tuples)</p><p>    新增一个有序集合，用法见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple1 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-1&quot;</span>,<span class="number">9.6</span>);</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple2 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-2&quot;</span>,<span class="number">9.9</span>);</span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        tuples.add(objectTypedTuple1);</span><br><span class="line">        tuples.add(objectTypedTuple2);</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().add(<span class="string">&quot;zset&quot;</span>,tuples));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().range(<span class="string">&quot;zset&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  1<br>  [zset-1, zset-2]</p><p>  （2）Boolean add(K key, V value, double score)</p><p>    新增一个有序集合，如果存在则返回false,如果不存在则返回true，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().add(<span class="string">&quot;zset&quot;</span>,<span class="string">&quot;zset-1&quot;</span>,<span class="number">1.0</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().add(<span class="string">&quot;zset&quot;</span>,<span class="string">&quot;zset-1&quot;</span>,<span class="number">1.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   运行测试，输出如下结果：</p><p>  true<br>  false</p><p>  （3）Long remove(K key, Object… values)</p><p>    从有序集合中移除一个或多个元素，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().add(<span class="string">&quot;zset&quot;</span>,<span class="string">&quot;zset-1&quot;</span>,<span class="number">1.0</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().add(<span class="string">&quot;zset&quot;</span>,<span class="string">&quot;zset-2&quot;</span>,<span class="number">1.0</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().range(<span class="string">&quot;zset&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().remove(<span class="string">&quot;zset&quot;</span>,<span class="string">&quot;zset-2&quot;</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().range(<span class="string">&quot;zset&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  true<br>  true<br>  [zset-1, zset-2]<br>  1<br>  [zset-1]</p><p>  （4）Long rank(K key, Object o)</p><p>    返回有序集中指定成员的排名，按分数值递增排列，用法见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().add(<span class="string">&quot;zset&quot;</span>,<span class="string">&quot;zset-1&quot;</span>,<span class="number">1.0</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().add(<span class="string">&quot;zset&quot;</span>,<span class="string">&quot;zset-2&quot;</span>,<span class="number">1.0</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().range(<span class="string">&quot;zset&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().remove(<span class="string">&quot;rank&quot;</span>,<span class="string">&quot;zset-1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  true<br>  true<br>  [zset-1, zset-2]<br>  0</p><p>  （5）Set<V> range(K key, long start, long end)</p><p>    通过索引区间返回有序集合指定区间内的成员，按分数值递增排列，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple1 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-1&quot;</span>,<span class="number">9.6</span>);</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple2 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-2&quot;</span>,<span class="number">8.1</span>);</span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        tuples.add(objectTypedTuple1);</span><br><span class="line">        tuples.add(objectTypedTuple2);</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().add(<span class="string">&quot;zset&quot;</span>,tuples));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().range(<span class="string">&quot;zset&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  0<br>  [zset-2, zset-1]</p><p>  （6）Long count(K key, double min, double max)</p><p>    通过分数返回有序集合指定区间内的成员个数，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple1 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-1&quot;</span>,<span class="number">3.6</span>);</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple2 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-2&quot;</span>,<span class="number">4.1</span>);</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple3 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-3&quot;</span>,<span class="number">5.7</span>);</span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        tuples.add(objectTypedTuple1);</span><br><span class="line">        tuples.add(objectTypedTuple2);</span><br><span class="line">        tuples.add(objectTypedTuple3);</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().add(<span class="string">&quot;zset&quot;</span>,tuples));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().rangeByScore(<span class="string">&quot;zset&quot;</span>,<span class="number">0</span>,<span class="number">9</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().count(<span class="string">&quot;zset&quot;</span>,<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  1<br>  [zset-1, zset-2, zset-3]<br>  2</p><p>  （7）Long size(K key)</p><p>    获取有序集合的成员数，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple1 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-1&quot;</span>,<span class="number">3.6</span>);</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple2 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-2&quot;</span>,<span class="number">4.1</span>);</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple3 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-3&quot;</span>,<span class="number">5.7</span>);</span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        tuples.add(objectTypedTuple1);</span><br><span class="line">        tuples.add(objectTypedTuple2);</span><br><span class="line">        tuples.add(objectTypedTuple3);</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().add(<span class="string">&quot;zset&quot;</span>,tuples));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().size(<span class="string">&quot;zset&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  0<br>  3  </p><p>  （8）Double score(K key, Object o)</p><p>    获取指定成员的score值，用法见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple1 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-1&quot;</span>,<span class="number">3.6</span>);</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple2 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-2&quot;</span>,<span class="number">4.1</span>);</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple3 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-3&quot;</span>,<span class="number">5.7</span>);</span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        tuples.add(objectTypedTuple1);</span><br><span class="line">        tuples.add(objectTypedTuple2);</span><br><span class="line">        tuples.add(objectTypedTuple3);</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().add(<span class="string">&quot;zset&quot;</span>,tuples));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().score(<span class="string">&quot;zset&quot;</span>,<span class="string">&quot;zset-1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  0<br>  3.6</p><p>  （9）Long removeRange(K key, long start, long end)</p><p>    移除指定索引位置的成员，有序集成员按分数值递增排列，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple1 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-1&quot;</span>,<span class="number">3.6</span>);</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple2 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-2&quot;</span>,<span class="number">4.1</span>);</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple3 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-3&quot;</span>,<span class="number">2.7</span>);</span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        tuples.add(objectTypedTuple1);</span><br><span class="line">        tuples.add(objectTypedTuple2);</span><br><span class="line">        tuples.add(objectTypedTuple3);</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().add(<span class="string">&quot;zset&quot;</span>,tuples));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().range(<span class="string">&quot;zset&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().removeRange(<span class="string">&quot;zset&quot;</span>,<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().range(<span class="string">&quot;zset&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输岀如下结果：</p><p>  2<br>  [zset-3, zset-1, zset-2]<br>  2<br>  [zset-3]</p><p>  （10）Cursor&lt;TypedTuple<V>&gt;scan(K key, ScanOptions options)</p><p>    遍历zset,用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple1 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-1&quot;</span>,<span class="number">3.6</span>);</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple2 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-2&quot;</span>,<span class="number">5.1</span>);</span><br><span class="line">        ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple3 = <span class="keyword">new</span> <span class="title class_">DefaultTypedTuple</span>&lt;&gt;(<span class="string">&quot;zset-3&quot;</span>,<span class="number">2.7</span>);</span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        tuples.add(objectTypedTuple1);</span><br><span class="line">        tuples.add(objectTypedTuple2);</span><br><span class="line">        tuples.add(objectTypedTuple3);</span><br><span class="line">        System.out.println(redisTemplate.opsForZSet().add(<span class="string">&quot;zset&quot;</span>,tuples));</span><br><span class="line">        Cursor&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; cursor = redisTemplate.opsForZSet().scan(<span class="string">&quot;zset&quot;</span>,ScanOptions.NONE);</span><br><span class="line">        <span class="keyword">while</span> (cursor.hasNext()) &#123;</span><br><span class="line">            ZSetOperations.TypedTuple&lt;Object&gt; item = cursor.next();</span><br><span class="line">            System.out.println(item.getValue()+<span class="string">&quot;：&quot;</span>+item.getScore());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试，输出如下结果：</p><p>  2<br>  zset-3：2.7<br>  zset-1：3.6<br>  zset-2：5.1</p><p>  除使用opsForXXX方法外，还可以使用Execute方法。opsForXXX方法的底层，是通过调用Execute方法来实现的。psForXXX方法实际上是封装了 Execute方法，定义了序列化，以便使用起来更简单便捷。</p><h2 id="4-7-比较-RedisTemplate-和-StringRedisTemplate"><a href="#4-7-比较-RedisTemplate-和-StringRedisTemplate" class="headerlink" title="4.7 比较 RedisTemplate 和 StringRedisTemplate"></a>4.7 比较 RedisTemplate 和 StringRedisTemplate</h2><p>StringRedisTemplate继承于RedisTemplate,两者的数据是不相通的。</p><ul><li>StringRedisTemplate 只能管理 StringRedisTemplate 中的数据。</li><li>RedisTemplate 只能管理 RedisTemplate 中的数据。</li></ul><p>  StnngRedisTemplate默认采用的是string的序列化策略，RedisTemplate默认采用的是 JDK的序列化策略。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro认证- SpringBoot（20）</title>
      <link href="/2022/08/10/shiro%E8%AE%A4%E8%AF%81-%20SpringBoot%EF%BC%8820%EF%BC%89/"/>
      <url>/2022/08/10/shiro%E8%AE%A4%E8%AF%81-%20SpringBoot%EF%BC%8820%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-认识shiro"><a href="#1-认识shiro" class="headerlink" title="1.认识shiro"></a>1.认识shiro</h1><p>除Spring Security安全框架外，应用非常广泛的就是Apache的强大又灵活的开源安全框架 Shiro,在国内使用量远远超过Spring Security。它能够用于身份验证、授权、加密和会话管理， 有易于理解的API,可以快速、轻松地构建任何应用程序。而且大部分人觉得从Shiro入门要比 Spring Security 简单。</p><h2 id="1-1-认识Shiro的核心组件"><a href="#1-1-认识Shiro的核心组件" class="headerlink" title="1.1 认识Shiro的核心组件"></a>1.1 认识Shiro的核心组件</h2><p>Shiro有如下核心组件。</p><ul><li>Subject：代表当前“用户”。与当前应用程序交互的任何东西都是Subject,如爬虫、机器人、所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给 SecurityManager，Subject 是一个门面，SecurityManager 是实际的执行者。</li><li>SecurityManager：与安全有关的操作都会与SecurityManager交互。它管理着所有 Subject，是Shiro的核心，员责与其他组件进行交互。</li><li>Realm： Shiro从Realm中获取安全数据(用户、角色、权限)，SecurityManager 需要 从Realm中获取相应的用户信息进行比较用户身份是否合法，也需要从Realm中得到用户 相应的角色&#x2F;权限进行验证，以确定用户是否能进行操作。</li></ul><h1 id="2-实例：用shiro实现管理后台的动态权限功能"><a href="#2-实例：用shiro实现管理后台的动态权限功能" class="headerlink" title="2.实例：用shiro实现管理后台的动态权限功能"></a>2.实例：用shiro实现管理后台的动态权限功能</h1><p>  依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-1-创建实体"><a href="#2-1-创建实体" class="headerlink" title="2.1 创建实体"></a>2.1 创建实体</h2><h3 id="2-1-1-创建管理员实体"><a href="#2-1-1-创建管理员实体" class="headerlink" title="2.1.1 创建管理员实体"></a>2.1.1 创建管理员实体</h3><p>创建管理实体，用于存放管理员信息，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Admin</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@Column(unique = true)</span></span><br><span class="line">    <span class="comment">//账号</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">//名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">//盐加密</span></span><br><span class="line">    <span class="keyword">private</span> String salt;</span><br><span class="line">    <span class="comment">//用户状态：0：创建未认证，等待验证 1：正常状态 2：用户被锁定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> state;</span><br><span class="line">    <span class="meta">@ManyToMany(fetch = FetchType.EAGER)</span></span><br><span class="line">    <span class="meta">@JoinTable(name = &quot;SysUserRole&quot;,joinColumns = &#123;@JoinColumn(name = &quot;uid&quot;)&#125;,</span></span><br><span class="line"><span class="meta">            inverseJoinColumns = &#123;@JoinColumn(name = &quot;roleId&quot;)&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SysRole&gt; rolesList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-创建权限实体"><a href="#2-1-2-创建权限实体" class="headerlink" title="2.1.2 创建权限实体"></a>2.1.2 创建权限实体</h3><p>权限实体用于存放权限数据，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysPermission</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Column(columnDefinition = &quot;enum(&#x27;menu&#x27;,&#x27;button&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String resourceType;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String permission;</span><br><span class="line">    <span class="keyword">private</span> Long parentId;</span><br><span class="line">    <span class="keyword">private</span> String parentIds;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">avaliable</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="meta">@JoinTable(name = &quot;SysRolePermission&quot;,joinColumns = &#123;@JoinColumn(name = &quot;permissionId&quot;)&#125;,</span></span><br><span class="line"><span class="meta">            inverseJoinColumns = &#123;@JoinColumn(name = &quot;roleId&quot;)&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SysRole&gt; rolesList;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-3-创建角色实体"><a href="#2-1-3-创建角色实体" class="headerlink" title="2.1.3 创建角色实体"></a>2.1.3 创建角色实体</h3><p>角色实体是管理员的角色，用于对管理员分组，并通过与权限表映射来确定管理员的权限，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysRole</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@Column(unique = true)</span></span><br><span class="line">    <span class="keyword">private</span> String role;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">available</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line">    <span class="meta">@ManyToMany(fetch = FetchType.EAGER)</span></span><br><span class="line">    <span class="meta">@JoinTable(name = &quot;SysRolePermission&quot;,joinColumns = &#123;@JoinColumn(name = &quot;roleId&quot;)&#125;,</span></span><br><span class="line"><span class="meta">            inverseJoinColumns = &#123;@JoinColumn(name = &quot;permissionId&quot;)&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SysPermission&gt; permissions;</span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="meta">@JoinTable(name = &quot;SysUserRole&quot;,joinColumns = &#123;@JoinColumn(name = &quot;roleId&quot;)&#125;,</span></span><br><span class="line"><span class="meta">            inverseJoinColumns = &#123;@JoinColumn(name = &quot;uid&quot;)&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Admin&gt; admins;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-进行权限配置"><a href="#2-2-进行权限配置" class="headerlink" title="2.2 进行权限配置"></a>2.2 进行权限配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.realm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.Admin;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.SysPermission;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.SysRole;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.ByteSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> &#123;</span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">        <span class="type">Admin</span> <span class="variable">adminInfo</span> <span class="operator">=</span> (Admin) principalCollection.getPrimaryPrincipal();</span><br><span class="line">        <span class="keyword">for</span> (SysRole role : adminInfo.getRolesList()) &#123;</span><br><span class="line">            info.addRole(role.getRole());</span><br><span class="line">            <span class="keyword">for</span> (SysPermission p:role.getPermissions())&#123;</span><br><span class="line">                info.addStringPermission(p.getPermission());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) authenticationToken.getPrincipal();</span><br><span class="line">        System.out.println(authenticationToken.getCredentials());</span><br><span class="line">        <span class="type">Admin</span> <span class="variable">adminInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Admin</span>();</span><br><span class="line">        adminInfo.setUsername(<span class="string">&quot;long&quot;</span>);</span><br><span class="line">        adminInfo.setPassword(<span class="string">&quot;longzhonghua&quot;</span>);</span><br><span class="line">        adminInfo.setSalt(<span class="string">&quot;yan&quot;</span>);</span><br><span class="line">        <span class="type">SimpleAuthenticationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(</span><br><span class="line">                adminInfo,adminInfo.getPassword(),</span><br><span class="line">                ByteSource.Util.bytes(adminInfo.getSalt()),</span><br><span class="line">                getName()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-将shiro注入到spring容器中"><a href="#2-3-将shiro注入到spring容器中" class="headerlink" title="2.3 将shiro注入到spring容器中"></a>2.3 将shiro注入到spring容器中</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.realm.CustomerRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.web.ShiroFilterFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.mgt.DefaultWebSecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.mgt.SecurityManager;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title function_">defaultAdvisorAutoProxyCreator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultAdvisorAutoProxyCreator</span> <span class="variable">defaultAdvisorAutoProxyCreator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAdvisorAutoProxyCreator</span>();</span><br><span class="line">        defaultAdvisorAutoProxyCreator.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span>  defaultAdvisorAutoProxyCreator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将自己验证的方式加入到容器中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomerRealm <span class="title function_">customRealm</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CustomerRealm</span> <span class="variable">customRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomerRealm</span>();</span><br><span class="line">        <span class="keyword">return</span> customRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//权限管理,配置主要是Realm的管理认证</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityManager <span class="title function_">securityManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span>  <span class="variable">defaultSecurityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span> ();</span><br><span class="line">        defaultSecurityManager.setRealm(customRealm());</span><br><span class="line">        <span class="keyword">return</span> defaultSecurityManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">shiroFilterFactoryBean</span><span class="params">(SecurityManager securityManager)</span> &#123;</span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">shiroFilterFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 登出</span></span><br><span class="line">        map.put(<span class="string">&quot;/logout&quot;</span>,<span class="string">&quot;logout&quot;</span>);</span><br><span class="line">        <span class="comment">// 对所有用户进行认证</span></span><br><span class="line">        map.put(<span class="string">&quot;/**&quot;</span>,<span class="string">&quot;authc&quot;</span>);</span><br><span class="line">        <span class="comment">//登录</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">        <span class="comment">// 首页</span></span><br><span class="line">        shiroFilterFactoryBean.setSuccessUrl(<span class="string">&quot;/index&quot;</span>);</span><br><span class="line">        <span class="comment">// 错误页面 认证不通过跳转</span></span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(<span class="string">&quot;/error&quot;</span>);</span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(map);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title function_">authorizationAttributeSourceAdvisor</span><span class="params">(SecurityManager securityManager)</span> &#123;</span><br><span class="line">        <span class="type">AuthorizationAttributeSourceAdvisor</span> <span class="variable">authorizationAttributeSourceAdvisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorizationAttributeSourceAdvisor</span>();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-编写控制层"><a href="#2-4-编写控制层" class="headerlink" title="2.4 编写控制层"></a>2.4 编写控制层</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.controller;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.Admin;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UnknownAccountException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.AuthorizationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.annotation.RequiresPermissions;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.annotation.RequiresRoles;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(Admin user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(user.getUsername()) || StringUtils.isEmpty(user.getPassword())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;请输入用户名和密码&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户认证信息</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">        <span class="type">UsernamePasswordToken</span> <span class="variable">usernamePasswordToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(user.getUsername(),user.getPassword());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 进行验证,这里可以捕获异常,然后返回对应信息</span></span><br><span class="line">            subject.login(usernamePasswordToken);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;用户名不存在&quot;</span>,e);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;用户名不存在&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;账号或者密码错误!&quot;</span>,e);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;账号或者密码错误!&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthorizationException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;没有权限！&quot;</span>,e);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;没有权限&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresRoles(&quot;admin&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/admin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">admin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;admin Success!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;query&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresPermissions(&quot;add&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;add success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-测试权限"><a href="#2-5-测试权限" class="headerlink" title="2.5 测试权限"></a>2.5 测试权限</h2><h3 id="（1）向sql中插入数据"><a href="#（1）向sql中插入数据" class="headerlink" title="（1）向sql中插入数据"></a>（1）向sql中插入数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `admin` (`id`, `name`, `password`, `salt`, `state`, `username`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;管理员&#x27;</span>, <span class="string">&#x27;32baebda76498588dabf64c6e8984097&#x27;</span>, <span class="string">&#x27;yan&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;long&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sys_permission` (`id`, `avaliable`, `name`, `parent_id`, `parent_ids`, `permission`, `resource_type`, `url`) <span class="keyword">VALUES</span> (<span class="number">1</span>, b<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;用户管理&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;0/&#x27;</span>, <span class="string">&#x27;admin:view&#x27;</span>, <span class="string">&#x27;menu&#x27;</span>, <span class="string">&#x27;admin/list&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sys_permission` (`id`, `avaliable`, `name`, `parent_id`, `parent_ids`, `permission`, `resource_type`, `url`) <span class="keyword">VALUES</span> (<span class="number">2</span>, b<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;用户添加&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;0/1&#x27;</span>, <span class="string">&#x27;admin:add&#x27;</span>, <span class="string">&#x27;button&#x27;</span>, <span class="string">&#x27;admin/add&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sys_permission` (`id`, `avaliable`, `name`, `parent_id`, `parent_ids`, `permission`, `resource_type`, `url`) <span class="keyword">VALUES</span> (<span class="number">3</span>, b<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;用户删除&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;0/1&#x27;</span>, <span class="string">&#x27;admin:del&#x27;</span>, <span class="string">&#x27;button&#x27;</span>, <span class="string">&#x27;admin/del&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sys_role` (`id`, `available`, `description`, `role`) <span class="keyword">VALUES</span> (<span class="number">1</span>, b<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;管理员&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sys_role_permission` (`role_id`, `permission_id`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sys_role_permission` (`role_id`, `permission_id`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sys_role_permission` (`role_id`, `permission_id`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sys_user_role` (`role_id`, `uid`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="（2）测试登录"><a href="#（2）测试登录" class="headerlink" title="（2）测试登录"></a>（2）测试登录</h3><p>  <img src="https://image.buretuzi.online/blog/article/springboot/shiro%E8%AE%A4%E8%AF%81-%20SpringBoot%EF%BC%8820%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><h2 id="2-6-对比-Spring-Security-与-Shiro"><a href="#2-6-对比-Spring-Security-与-Shiro" class="headerlink" title="2.6  对比 Spring Security 与 Shiro"></a>2.6  对比 Spring Security 与 Shiro</h2><h3 id="（1）Shiro的特点"><a href="#（1）Shiro的特点" class="headerlink" title="（1）Shiro的特点"></a>（1）Shiro的特点</h3><ul><li>功能强大，且简单、灵活。</li><li>拥有易于理解的API。</li><li>简单的身份认证(登录)，支持多种数据源(LDAP、JDBC、Kerberos、ActiveDirectory等)。</li><li>支持对角色的简单签权，并且支持细粒度的签权。</li><li>支持一级缓存，以提升应用程序的性能。</li><li>内置的基于POJO会话管理，适用于Web,以及非Web环境。</li><li>不跟任何的框架或容器捆绑，可以独立运行。</li></ul><h3 id="（2）Spring-Security-的特点。"><a href="#（2）Spring-Security-的特点。" class="headerlink" title="（2）Spring Security 的特点。"></a>（2）Spring Security 的特点。</h3><ul><li>Shiro的功能它都有</li><li>对防止CSRF跨站、XSS跨站脚本可以很好地实现，对Oauth、OpenlD也有支持。Shiro 则需要开发者自己手动实现_。_</li><li>因为Spring Security是Spring自己的产品，所以对Spring的支持极好，但也正是因为这个，所以仅仅支持自己的产品，导致其捆绑到了 Spring框架，而不支持其他框架。</li><li>Spring Security的权限细粒度更高(这不是绝对的，Shiro也可以实现)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT- SpringBoot（19）</title>
      <link href="/2022/08/10/JWT-%20SpringBoot%EF%BC%8819%EF%BC%89/"/>
      <url>/2022/08/10/JWT-%20SpringBoot%EF%BC%8819%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>  在生产环境中，对发在的API增加授权保护是非常必要的。JWT作为一个无状态的授权校捡技术，非常适合于分布式系统架构。服务器端不需要保存用户状态，因此，无须采用Redis等技术来实现各个服务节点之间共享Session数据。</p><p>  本节通过实例讲解如何用JWT技术进行授权认证和保护。</p><h2 id="1-1-配置安全类"><a href="#1-1-配置安全类" class="headerlink" title="1.1 配置安全类"></a>1.1 配置安全类</h2><h3 id="（1）自定义用户"><a href="#（1）自定义用户" class="headerlink" title="（1）自定义用户"></a>（1）自定义用户</h3><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.intehel.jwt.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Boolean enabled;</span><br><span class="line">    <span class="keyword">private</span> Boolean accountNonExpired;</span><br><span class="line">    <span class="keyword">private</span> Boolean accountNonLocked;</span><br><span class="line">    <span class="keyword">private</span> Boolean credentialsNonExpired;</span><br><span class="line">    <span class="meta">@ManyToMany(fetch = FetchType.EAGER,cascade = CascadeType.PERSIST)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Role role : roles) &#123;</span><br><span class="line">            authorities.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(role.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountNonLocked;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> credentialsNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> enabled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）自定义角色"><a href="#（2）自定义角色" class="headerlink" title="（2）自定义角色"></a>（2）自定义角色</h3><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.intehel.jwt.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity(name = &quot;role&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String nameZh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）JPA"><a href="#（3）JPA" class="headerlink" title="（3）JPA"></a>（3）JPA</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.jwt.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.jwt.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User,Integer&gt; &#123;</span><br><span class="line">    User <span class="title function_">findUserByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.jwt.repository;</span><br><span class="line"><span class="keyword">import</span> com.intehel.jwt.domain.Role;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRoleRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Role,Integer&gt; &#123;</span><br><span class="line">    Role <span class="title function_">findByName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）认证失败和认证成功处理器"><a href="#（4）认证失败和认证成功处理器" class="headerlink" title="（4）认证失败和认证成功处理器"></a>（4）认证失败和认证成功处理器</h3><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.jwt.handler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.https.httpsServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.https.httpsServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>:李自航</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateDate</span>:2022/8/5 10:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@UPdateDate</span>:2022/8/5 10:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>:版本号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationFailHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleUrlAuthenticationFailureHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(httpsServletRequest request, httpsServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        out.write(<span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\t\&quot;status\&quot;:\&quot;error\&quot;,\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\t\&quot;message\&quot;:\&quot;用户名或密码错误\&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.intehel.jwt.handler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.https.httpsServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.https.httpsServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationSuccessHandler</span> <span class="keyword">extends</span> <span class="title class_">SavedRequestAwareAuthenticationSuccessHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(httpsServletRequest request, httpsServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">principal</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">        <span class="keyword">if</span> (principal != <span class="literal">null</span> &amp;&amp; principal <span class="keyword">instanceof</span> UserDetails)&#123;</span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> (UserDetails) principal;</span><br><span class="line">            request.getSession().setAttribute(<span class="string">&quot;userDetail&quot;</span>,user);</span><br><span class="line">            <span class="type">String</span> <span class="variable">role</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = user.getAuthorities();</span><br><span class="line">            <span class="keyword">for</span> (GrantedAuthority authority : authorities)&#123;</span><br><span class="line">                role = authority.getAuthority();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="string">&quot;灌水灌水&quot;</span>;</span><br><span class="line">            response.setHeader(<span class="string">&quot;token&quot;</span>,token);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">            out.write(<span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;\t\&quot;status\&quot;:\&quot;ok\&quot;,\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;\t\&quot;message\&quot;:\&quot;登录成功\&quot;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）配置安全类"><a href="#（5）配置安全类" class="headerlink" title="（5）配置安全类"></a>（5）配置安全类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.jwt.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.jwt.handler.JwtAuthenticationFailHandler;</span><br><span class="line"><span class="keyword">import</span> com.intehel.jwt.handler.JwtAuthenticationSuccessHandler;</span><br><span class="line"><span class="keyword">import</span> com.intehel.jwt.handler.MyAuthenticationFailureHandler;</span><br><span class="line"><span class="keyword">import</span> com.intehel.jwt.handler.MyAuthenticationSuccessHandler;</span><br><span class="line"><span class="keyword">import</span> com.intehel.jwt.service.MyUserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.httpsSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.WebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAuthenticationSuccessHandler myAuthenticationSuccessHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAuthenticationFailHandler myAuthenticationFailureHandler;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailsService jwtDetailsService;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.antMatcher(<span class="string">&quot;/jwt/**&quot;</span>)</span><br><span class="line">                .formLogin()</span><br><span class="line">                .usernameParameter(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .loginPage(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)</span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/register/mobile&quot;</span>).permitAll()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/article/**&quot;</span>).authenticated()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/jwt/tasks/**&quot;</span>).hasRole(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">        https.logout().permitAll();</span><br><span class="line">        https.cors().and().csrf().ignoringAntMatchers(<span class="string">&quot;/jwt/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth.userDetailsService(jwtDetailsService).passwordEncoder(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/jwt/register/mobile&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从上面代码可以看出，此处JWT的安全配置和上面已经讲解过的安全配置并无区别，没有特别的参数需要配置。</p><h2 id="1-2-自定义登录界面"><a href="#1-2-自定义登录界面" class="headerlink" title="1.2 自定义登录界面"></a>1.2 自定义登录界面</h2><p>查看代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;https://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bootstrap-css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#login</span> <span class="selector-class">.container</span> <span class="selector-id">#login-row</span> <span class="selector-id">#login-column</span> <span class="selector-id">#login-box</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#9c9c9c</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#EAEAEA</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-row&quot;</span> <span class="attr">class</span>=<span class="string">&quot;row justify-content-center align-items-center&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-column&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-6&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-box&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-12&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;login-form&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/doLogin&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;text-center text-info&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--/*@thymesVar id=&quot;SPRING_SECURITY_LAST_EXCEPTION&quot; type=&quot;com&quot;*/--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;SPRING_SECURITY_LAST_EXCEPTION&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-info&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-info&quot;</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-info btn-md&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-3-处理注册"><a href="#1-3-处理注册" class="headerlink" title="1.3 处理注册"></a>1.3 处理注册</h2><p>在注册时为了安全，需要将注册的密码经过加密再写入数据库中。</p><p>   spring security 5之后，需要对密码添加这个类型（id），可参考文章<a href="https://www.cnblogs.com/majianming/p/7923604.html">www.cnblogs.com/majianming/p/7923604.html</a></p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/JWT-%20SpringBoot%EF%BC%8819%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.intehel.jwt.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.jwt.domain.Role;</span><br><span class="line"><span class="keyword">import</span> com.intehel.jwt.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.intehel.jwt.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> com.intehel.jwt.repository.UserRoleRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/jwt&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRoleRepository userRoleRepository;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/register/mobile&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">userName</span> <span class="operator">=</span> userRepository.findUserByUsername(user.getUsername());</span><br><span class="line">            <span class="keyword">if</span> (userName != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;用户名已存在&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">BCryptPasswordEncoder</span> <span class="variable">encoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">            user.setPassword(<span class="string">&quot;&#123;bcrypt&#125;&quot;</span>+encoder.encode(user.getPassword()));</span><br><span class="line">            List&lt;Role&gt; roles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">Role</span> <span class="variable">role</span> <span class="operator">=</span> userRoleRepository.findByName(<span class="string">&quot;ROLE_admin&quot;</span>);</span><br><span class="line">            roles.add(role);</span><br><span class="line">            user.setRoles(roles);</span><br><span class="line">            userRepository.save(user);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;出现了异常&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;成果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-处理登录"><a href="#1-4-处理登录" class="headerlink" title="1.4 处理登录"></a>1.4 处理登录</h2><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.intehel.jwt.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.jwt.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.intehel.jwt.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserRepository userRepository;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span><span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.findUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试多方式注册和登录"><a href="#测试多方式注册和登录" class="headerlink" title="测试多方式注册和登录"></a>测试多方式注册和登录</h2><h3 id="1-测试注册功能"><a href="#1-测试注册功能" class="headerlink" title="1.测试注册功能"></a>1.测试注册功能</h3><p>  这里使用测试工具Postman提交POST注册请求</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/JWT-%20SpringBoot%EF%BC%8819%EF%BC%89%EF%BC%882%EF%BC%89.png"></p><p>  数据库插入信息如下</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/JWT-%20SpringBoot%EF%BC%8819%EF%BC%89%EF%BC%883%EF%BC%89.png"></p><h3 id="2-测试登录功能"><a href="#2-测试登录功能" class="headerlink" title="2. 测试登录功能"></a>2. 测试登录功能</h3><p>  浏览器输入<a href="https://localhost:8080/jwt%E8%87%AA%E5%8A%A8%E8%B7%B3%E8%BD%AC%E8%87%B3%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%EF%BC%8C%E8%BE%93%E5%85%A5%E4%BD%BF%E7%94%A8postman%E6%B3%A8%E5%86%8C%E7%9A%84%E8%B4%A6%E5%8F%B7%E5%8D%B3%E5%8F%AF">https://localhost:8080/jwt自动跳转至登录界面，输入使用postman注册的账号即可</a></p><p>  以本博客对spring security的随笔，可实现使用token授权登录，这里不多做解释</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security静态资源过滤（11）</title>
      <link href="/2022/08/10/Spring%20Security%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%BF%87%E6%BB%A4%EF%BC%8811%EF%BC%89/"/>
      <url>/2022/08/10/Spring%20Security%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%BF%87%E6%BB%A4%EF%BC%8811%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>  在一个实际项目中，并非所有的请求都需要经过Spring Security过滤器，有一些特殊的请求，例如静态资源等，一般来说并不需要经过Spring Security过滤器链，用户如果访问这些静态资源，直接返回对应的资源即可。</p><p>  回顾关于WebSecurity的讲解，提到它里边维护了一个ignoredRequests变量, 该变量，记录的就是所有需要被忽略的请求，这些被忽略的请求将不再经过Spring Security过滤器。例如，静态资源目录结构如图4-10所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%BF%87%E6%BB%A4%EF%BC%8811%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><center>图 4-10</center><p>现在这些静态资源的访问不需要经过Spring Security过滤器，具体配置方案如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/mylogin.html&quot;</span>,<span class="string">&quot;/loginNew.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   重写configure(WebSecurity)方法，并配置需要忽略的请求，这些需要忽略的地址，最终都会被添加到ignoredRequests集合中，并最终以过滤器链的形式呈现出来。换句话说，上面的配置中一共包含了五个过滤器链：configure( W eb Security)方法中配置的四个以及httpsSecurity 中配置的一个(即&#x2F;**)。如果大家不能理解为什么会有五个过滤器链，可以回顾关于WebSecurity的分析以及关于FilterChainProxy的分析，这里不再赘述。</p><p>  配置完成后，再次启动项目，此时不需要认证就可以访问&#x2F;login.html页面。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security定义多个过滤器链（10）</title>
      <link href="/2022/08/10/Spring%20Security%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%EF%BC%8810%EF%BC%89/"/>
      <url>/2022/08/10/Spring%20Security%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%EF%BC%8810%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>  在Spring Security中可以同时存在多个过滤器链，一个WebSecurityConfigurerAdapter的实例就可以配置一条过滤器链。</p><p>  我们来看如下一个案例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    UserDetailsService <span class="title function_">us</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">InMemoryUserDetailsManager</span> <span class="variable">users</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">        users.createUser(User.withUsername(<span class="string">&quot;剑气近&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123&quot;</span>).roles(<span class="string">&quot;admin&quot;</span>).build());</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@Order(1)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig01</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">InMemoryUserDetailsManager</span> <span class="variable">users</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">            users.createUser(User.withUsername(<span class="string">&quot;chain1in&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123&quot;</span>).roles(<span class="string">&quot;admin&quot;</span>).build());</span><br><span class="line">            https.antMatcher(<span class="string">&quot;/bar/**&quot;</span>)</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line">                    .anyRequest().authenticated()</span><br><span class="line">                    .and()</span><br><span class="line">                    .formLogin()</span><br><span class="line">                    .loginPage(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                    .loginProcessingUrl(<span class="string">&quot;/bar/login&quot;</span>)</span><br><span class="line">                    .successHandler(((req, resp, auth) -&gt; &#123;</span><br><span class="line">                        resp.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(auth);</span><br><span class="line">                        resp.getWriter().write(s);</span><br><span class="line">                    &#125;))</span><br><span class="line">                    .permitAll()</span><br><span class="line">                    .and()</span><br><span class="line">                    .csrf().disable()</span><br><span class="line">                    .userDetailsService(users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@Order(2)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig02</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            auth.inMemoryAuthentication().withUser(<span class="string">&quot;chain2out&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123&quot;</span>).roles(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">InMemoryUserDetailsManager</span> <span class="variable">users</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">            users.createUser(User.withUsername(<span class="string">&quot;chain2in&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123&quot;</span>).roles(<span class="string">&quot;admin&quot;</span>).build());</span><br><span class="line">            https.antMatcher(<span class="string">&quot;/foo/**&quot;</span>)</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line">                    .anyRequest().authenticated()</span><br><span class="line">                    .and()</span><br><span class="line">                    .formLogin()</span><br><span class="line">                    .loginPage(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                    .loginProcessingUrl(<span class="string">&quot;/foo/login&quot;</span>)</span><br><span class="line">                    .successHandler(((req, resp, auth) -&gt; &#123;</span><br><span class="line">                        resp.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(auth);</span><br><span class="line">                        resp.getWriter().write(s);</span><br><span class="line">                    &#125;))</span><br><span class="line">                    .permitAll()</span><br><span class="line">                    .and()</span><br><span class="line">                    .csrf().disable()</span><br><span class="line">                    .userDetailsService(users);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在SecurityConfig中分别定义两个静态内部类SecurityConfig01和SecurityConfig02,两个配置类都继承自WebSecurityConfigurerAdapter, 可以分别配置一条过滤器链。</p><p>  先来看Security01，在Security01中，我们设置过滤器链的拦截规则是&#x2F;bar&#x2F;**,即如果请求路径是&#x2F;bar&#x2F;**格式的，则进入到Security01的过滤器链中进行处理。同时我们配置了局部 AuthenticationManager 对应的用户是 chain1in&#x2F;123 ,由于没有重写 configure(AuthenticationManagerBuilder)方法，所以注册到 Spring 容器中的 UserDetailsService 将作为局部 AuthenticationManager的parent对应的用户，换句话说，如果登录的路径是&#x2F;bar&#x2F;login,那么升发者可以使用 chain1in&#x2F;123和 剑气近&#x2F;123两个用户进行登录。</p><p>  再来看SecurityConfig02。在Security02中，我们设置过滤器链的拦截规则是&#x2F;foo&#x2F;**，即如果请求路径是&#x2F;foo&#x2F;**格式的，则进入到Secunty02的过滤器链中进行处理，同时我们配置了局部 AuthenticationManager 对应的用户是 chain2in&#x2F;123 ,由于重写了 configure(Authentication ManagerBuilder)方法，在该方法中定义了局部AuthenticationManager的parent对应的用户，此时注册到Spring容器中的UserDetailsService实例对于&#x2F;foo&#x2F;**过滤器链不再生效。换句话说， 如果登录路径是&#x2F;foo&#x2F;login,开发者可以使用chain2in&#x2F;123和 chain2out&#x2F;123两个用户进行登录，而不可以使用 剑气近&#x2F;123进行登录。</p><p>  需要注意的是，如果配置了多个过滤器链，需要使用@Order注解来标记不同配置的优先级（即不同过滤器链的优先级），数字越大优先级越低，当请求到来时，会按照过滤器链的优先级从高往低，依次进行匹配。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ObjectPostProcessor使用与多种用户定义方式（9）</title>
      <link href="/2022/08/09/ObjectPostProcessor%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%A4%9A%E7%A7%8D%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%EF%BC%889%EF%BC%89/"/>
      <url>/2022/08/09/ObjectPostProcessor%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%A4%9A%E7%A7%8D%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%EF%BC%889%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-ObjectPostProcessor-使用"><a href="#1-ObjectPostProcessor-使用" class="headerlink" title="1.ObjectPostProcessor 使用"></a>1.ObjectPostProcessor 使用</h1><p>  前面介绍了 ObjectPostProcessor的基本概念。相信读者已经明白，所有的过滤器都由对应的配置类来负责创建，配置类在将过滤器创建成功之后，会调用父类的postProcess方法，该 方法最终会调用到CompositeObjectPostProcessor对象的postProcess方法，在该方法中，会遍 历 CompositeObjectPostProcessor 对象所维护的 List 集合中存储的所有 ObjectPostProcessor 对 象，并调用其postProcess方法对对象进行后置处理。默认情况下，CompositeObjectPostProcessor 对象中所维护的List集合中只有一个对象那就是AutowireBeanFactoryObjectPostProcessor调用 AutowireBeanFactoryObjectPostProcessor 的 postProcess 方法可以将对象注册到 Spring 容器 中去。</p><p>  升发者可以自定义ObjectPostProcessor对象，并添加到CompositeObjectPostProcessor所维护的List集合中，此时，当一个过滤器在创建成功之后，就会被两个对象后置处理器处理， 第一个是默认的对象后置处理器，负责将对象注册到Spring容器中；第二个是我们自定义的对象后置处理器，可以完成一些个性化配置.</p><p>  自定义ObjectPostProcessor对象比较典型的用法是动态权限配置(权限管理将在后续章节 具体介绍)，为了便于大家理解，笔者这里先通过一个大家熟悉的案例来展示 ObjectPostProcessor的用法，后面在配置动态权限时，ObjectPostProcessor的使用思路是一样的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    https.authorizeRequests()</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        .withObjectPostProcessor(<span class="keyword">new</span> <span class="title class_">ObjectPostProcessor</span>&lt;UsernamePasswordAuthenticationFilter&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;O <span class="keyword">extends</span> <span class="title class_">UsernamePasswordAuthenticationFilter</span>&gt; O <span class="title function_">postProcess</span><span class="params">(O object)</span> &#123;</span><br><span class="line">                object.setUsernameParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                object.setPasswordParameter(<span class="string">&quot;passwd&quot;</span>);</span><br><span class="line">                object.setAuthenticationSuccessHandler(((request, response, authentication) -&gt; &#123;</span><br><span class="line">                    response.getWriter().write(<span class="string">&quot;login Success&quot;</span>);</span><br><span class="line">                &#125;));</span><br><span class="line">                <span class="keyword">return</span> object;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .and()</span><br><span class="line">        .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在这个案例中，调用formLogin方法之后，升启了 FormLoginConfigurer的配置，FormLoginConfigurer 的作用是为了配置 UsernamePasswordAuthenticationFilter 过滤器，在 formLogin 方法执行完毕后，我们调用 withObjectPostProcessor 方法对 UsernamePasswordAuthenticationFilter 过滤器进行二次处理，修改登录参数的key,将登录用户名参数的key改为name,将登录密码参数的key改为passwd,同时配置一个登录成功的处理器。</p><h1 id="2-多种用户定义方式"><a href="#2-多种用户定义方式" class="headerlink" title="2.多种用户定义方式"></a>2.多种用户定义方式</h1><p>在前面的章节中，我们定义用户主要是两种方式:</p><p>  (1)第一种方式是使用的重写configure(AuthenticationManagerBuilder)方法的方式。</p><p>  (2)第二种方式是定义多个数据源时，我们直接向Spring容器中注入了 UserDetailsService 对象。</p><p>那么这两种用户定义方式有什么区别？</p><p>  根据前面的源码分析可知，在Spring Security中存在两种类型的AuthenticationManager, 一种是全局的AuthenticationManager,另一种则是局部的AuthenticationManager局部的 AuthenticationManager，由 httpsSecurity 进行配置，而全局的 AuthenticationManager 可以不用配置，系统会默认提供一个全局的AuthenticationManager对象，也可以通过重写 configure(AuthenticationMaiiagerBuilder)方法进行全局配置。</p><p>  当进行用户身份验证时，首先会通过局部的AuthenticationManager对象进行验证，如果验证失败，则会调用其parent也就是全局的AuthenticationManager再次进行验证。</p><p>  所以开发者在定义用户时，也分为两种情况，一种是针对局部AuthenticationManager定义的用户，另一种则是针对全局AuthenticationManager定义的用户。</p><p>  为了演示方便，接下来的案例我们将采用InMemoryUserDetailsManager来构建用户对象, 读者也可以自行使用基于MyBatis或者Spring Data JPA定义的UserDetailsService实例。</p><p>先来看针对局部AuthenticationManager定义的用户：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">InMemoryUserDetailsManager</span> <span class="variable">users</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">    users.createUser(User.withUsername(<span class="string">&quot;buretuzi&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123&quot;</span>).roles(<span class="string">&quot;admin&quot;</span>).build());</span><br><span class="line">    https.authorizeRequests()</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        .permitAll()</span><br><span class="line">        .and()</span><br><span class="line">        .userDetailsService(users)</span><br><span class="line">        .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在上面这段代码中，我们基于内存来管理用户，并向users中添加了一个用户，将配置好的users对象添加到httpsSecurity中，也就是配置到局部的AuthenticationManager中。</p><p>  配置完成后，启动项目。项目启动成功后，我们就可以使用buretuzi&#x2F;123来登录系统了。 但是注意，当我们启动项目时，在IDEA控制台输出的日志中可以看到如下内容：</p><p>  Using generated security password: cfc7f8b5-8346-492e-b25c-90c2c4501350</p><p>  这个是系统自动生成的用户，那么我们是否可以使用系统自动生成的用户进行登录呢？答案是可以的，为什么呢？</p><p>  系统自动提供的用户对象实际上就是往Spring容器中注册了一个 InMemoryUserDetailsManager 对象. 而在前面的代码中，我们没有重写 configure(AuthenticationManagerBuilder)_方法,_这意味着全局的 AuthenticationManager 是通过 AuthenticationConfignration#getAuthenticationManager 方法自动生成的，在生成的过程中，会 从Spring容器中查找对应的UserDetailsService实例进行配置(具体配置在InitializeUserDetailsManagerConfigurer类中)。所以系统自动提供的用户实际上相当于是全局AuthenticationManager对应的用户。</p><p>  以上面的代码为例，当我们开始执行登录后,Spring Security首先会调用局部Authentication Manager去进行登录校验，如果登录的用户名&#x2F;密码是buretuzi&#x2F;123,那就直接登录成功，否则登录失败，当登录失败后,会继续调用局部AuthenticationManager的parent继续进行校验，此时如果登录的用户名&#x2F;密码是user&#x2F;cfc7f8b5-8346-492e-b25c-90c2c4501350,则登录成功，否则登录失败。</p><p>  这是针对局部AuthenticationManager定义的用户，我们也可以将定义的用户配置给全局 的AuthenticationManager,由于默认的全局AuthenticationManager在配置时会从Spring容器中 査找UserDetailsService实例，所以我们如果针对全局AuthenticationManager配置用户，只需要往Spring容器中注入一个UserDetailsService实例即可，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">UserDetailsService <span class="title function_">us</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">InMemoryUserDetailsManager</span> <span class="variable">users</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">    users.createUser(User.withUsername(<span class="string">&quot;李文若&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123&quot;</span>).roles(<span class="string">&quot;admin&quot;</span>).build());</span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">InMemoryUserDetailsManager</span> <span class="variable">users</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">    users.createUser(User.withUsername(<span class="string">&quot;buretuzi&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123&quot;</span>).roles(<span class="string">&quot;admin&quot;</span>).build());</span><br><span class="line">    https.authorizeRequests()</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        .permitAll()</span><br><span class="line">        .and()</span><br><span class="line">        .userDetailsService(users)</span><br><span class="line">        .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   配置完成后，当我们启动项目时，全局的AuthenticationManager在配置时会去Spring容器中查找UserDetailsService实例，找到的就是我们自定义的UserDetailsService实例。当我们进行登录时，系统拿着我们输入的用户名&#x2F;密码，首先和buretuzi&#x2F;123进行匹配，如果匹配不上的话，再去和 李文若&#x2F;123进行匹配。</p><p>  当然,升发者也可以不使用Spring Security提供的默认的全局AuthenticationManager对象, 而是通过重写 Configure(AuthenticationManagerBuilder)方法来自定义全局 Authentication Manager 对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    auth.inMemoryAuthentication().withUser(<span class="string">&quot;剑气近&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123&quot;</span>).roles(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">InMemoryUserDetailsManager</span> <span class="variable">users</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">    users.createUser(User.withUsername(<span class="string">&quot;buretuzi&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123&quot;</span>).roles(<span class="string">&quot;admin&quot;</span>).build());</span><br><span class="line">    https.authorizeRequests()</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        .permitAll()</span><br><span class="line">        .and()</span><br><span class="line">        .userDetailsService(users)</span><br><span class="line">        .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  根据对 WebSecurityConfigurerAdapter的源码分析可知，一旦我们重写了 configure(AuthenticationManagerBuilder)方法，则全局的 AuthenticationManager 对象将不再通过 AuthenticationConfiguration#getAuthenticationManager 方法来构建，而是通过 WebSecurityConfigiuerAdapter中的localConfigureAuthenticationBuilder变量来构建，该变量也是我们重写的 configure(AuthenticationManagerBuilder)方法的参数。</p><p>  配置完成后，当我们启动项目时，全局的AuthenticationManager在构建时会直接使用 configure(AutheuticationManagerBuilder)方法的auth变量去构建，使用的用户也是我们配置给 auth变量的用户，当我们进行登录时，系统会将所输入的用户名&#x2F;密码，首先和buretuzi&#x2F;123进 行匹配，如果匹配不上的话，再去和 剑气近&#x2F;123进行匹配。</p><p>  需要注意的是，一旦重写了 configure(AuthenticationManagerBuilder)方法，那么全局 AuthenticationManager对象中使用的用户，将以 configure(AuthenticationManagerBuilder)方法中定义的用户为准。此时，如果我们还向Spring容器中注入了另外一个UserDetailsService实例，那么该实例中定义的用户将不会生效(因为 AuthenticationConfiguration#getAuthenticationManager方法没有被调用)。</p><p>  这就是Spring Security中几种不同的用户定义方式，相信通过这几个案例，读者对于全局 AuthenticationManager和局部AuthenticationManager对象会有更加深刻的理解。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security过滤器链分析-初始化流程（8）</title>
      <link href="/2022/08/07/Spring%20Security%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%EF%BC%888%EF%BC%89/"/>
      <url>/2022/08/07/Spring%20Security%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%EF%BC%888%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="过滤器链分析"><a href="#过滤器链分析" class="headerlink" title="过滤器链分析"></a>过滤器链分析</h1><p>  提起Spring Security的实现原理，很多读者都会想到过滤器链。因为Spring Security中的所有功能都是通过过滤器来实现的，这些过滤器组成一个完整的过滤器链。那么，这些过滤器 链是如何初始化的？我们前面反复提到的AuthenticationManager又是如何初始化的？通过前面章节的学习，相信读者己经有了一些认识，本章我们将从头开始，分析Spring Security的初始化流程，同时再通过六个案例来让读者深入理解并且学会如何制作过滤器链。由于初始化流程相对复杂，因此我们没有选择在一开始就讲解Spring Security初始化流程，而是放到本节。当读者对于Spring Security有一个基本的认知之后再来讲解，此时相对来说就会比较容易理解。</p><p>本章涉及的主要知识点有：</p><ul><li>初始化流程分析。</li><li>ObjectPostProcessor 的使用。</li><li>多种用户定义方式。</li><li>定义多个过滤器链。</li><li>静态资源过滤。</li><li>使用JSON格式登录。</li><li>添加登录验证码。</li></ul><h1 id="1-初始化流程分析"><a href="#1-初始化流程分析" class="headerlink" title="1. 初始化流程分析"></a>1. 初始化流程分析</h1><p>  Spring Security初始化流程整体上来说理解起来并不难,但是这里涉及许多零碎的知识点， 把这些零碎的知识点搞懂了，再来梳理初始化流程就会容易很多。因此，这里先介绍一下SpringSecurity中一些常见的关键组件，在理解这些组件的基础上，再来分析初始化流程，就能加深对其的理解。</p><h2 id="1-1-ObjectPostProcessor"><a href="#1-1-ObjectPostProcessor" class="headerlink" title="1.1 ObjectPostProcessor"></a>1.1 ObjectPostProcessor</h2><p>  ObjectPostProcessor是Spring Security中使用频率最高的组件之一，它是一个对象后置处理器，也就是当一个对象创建成功后，如果还有一些额外的事情需要补充，那么可以通过 ObjectPostProcessor来进行处理。这个接口中默认只有一个方法postProcess,该方法用来完成对对象的二次处理，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectPostProcessor</span>&lt;T&gt; &#123;</span><br><span class="line">&lt;O <span class="keyword">extends</span> <span class="title class_">T</span>&gt; O <span class="title function_">postProcess</span><span class="params">(O object)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  ObjectPostProcessor默认有两个继承类，如图4-1所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%EF%BC%888%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><center>图 4-1</center><ul><li>AutowireBeanFactoryObjectPostProcessor:由于 Spring Security 中大量采用了 Java 配置， 许多过滤器都是直接new出来的，这些直接new出来的对象并不会自动注入到Spring 容器中。Spring Security这样做的本意是为了简化配置，但是却带来了另外一个问题就是, 大量new出来的对象需要我们手动注册到Spring客器中去。AutowireBeanFactoryObjectPostProcessor对象所承担的就是这件事，一个对象new出来之后，只要调用 AutowireBeanFactoryObjectPostProcessor.postProcess 方法，就可以成功注入到 Spring 容器中，它的实现原理就是通过调用Spring容器中的AutowireCapableBeanFactory对象将一个new出来的对象注入到Spring容器中去。</li><li>CompositeObjectPostProcessor:这是ObjectPostProcessor 的另一个实现，一个对象可以有一个后置处理器，开发者也可以自定义多个对象后置处理器。 CompositeObjectPostProcessor是一个组合的对象后置处理器,它里边维护了一个List集合，集合中存放了某一个对象的所有后置处理器，当需要执行对象的后置处理器时，会遍历集合中的所有ObjectPostProcessor实例，分别调用实例的postProcess方法进行对象后置处理。在Spring Security框架中，最终使用的对象后置处理器其实就是 CompositeObjectPostProcessor ,它里边的集合默认只有一个对象，就是 AutowireBeanFactoryObjectPostProcessor。</li></ul><p>  在Spring Security中，开发者可以灵活地配置项目中需要哪些Spring Security过滤器，一 旦选定过滤器之后，每一个过滤器都会有一个对应的配置器，叫作xxxConfigurer (例如CorsConfigurer. CsrfConfigurer等)，过滤器都是在 xxxConfigurer 中 new 出来的，然后在 postProcess方法中处理一遍，就将这些过滤器注入到Spring容器中了。这是对象后置处理器ObjectPostProcessor的主要作用。</p><h2 id="1-2-SecurityFilterChain"><a href="#1-2-SecurityFilterChain" class="headerlink" title="1.2 SecurityFilterChain"></a>1.2 SecurityFilterChain</h2><p>从名称上可以看出，SecurityFilterChain就是Spring Security中的过滤器链对象。下面来看一下 SecurityFilterChain的源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityFilterChain</span> &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(httpsServletRequest request)</span>;</span><br><span class="line">List&lt;Filter&gt; <span class="title function_">getFilters</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，SecurityFilterChain中有两个方法：</p><ul><li>matches:该方法用来判断request请求是否应该被当前过滤器链所处理心</li><li>getFilters：该方法返回一个List集合，集合中存放的就是Spring Security中的过滤器。换言之，如果matches方法返回true,那么request请求就会在getFilters方法所返回的Filter 集合中被处理。</li></ul><p>SecurityFilterChain只有一个默认的实现类就是DefaultSecurityFilterChain，其中定义了两 个属性，并具体实现了 SecurityFilterChain中的两个方法：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DefaultSecurityFilterChain</span> <span class="keyword">implements</span> <span class="title class_">SecurityFilterChain</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(DefaultSecurityFilterChain.class);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RequestMatcher requestMatcher;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Filter&gt; filters;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultSecurityFilterChain</span><span class="params">(RequestMatcher requestMatcher, Filter... filters)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(requestMatcher, Arrays.asList(filters));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultSecurityFilterChain</span><span class="params">(RequestMatcher requestMatcher, List&lt;Filter&gt; filters)</span> &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Creating filter chain: &quot;</span> + requestMatcher + <span class="string">&quot;, &quot;</span> + filters);</span><br><span class="line"><span class="built_in">this</span>.requestMatcher = requestMatcher;</span><br><span class="line"><span class="built_in">this</span>.filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(filters);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> RequestMatcher <span class="title function_">getRequestMatcher</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> requestMatcher;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;Filter&gt; <span class="title function_">getFilters</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> filters;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(httpsServletRequest request)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> requestMatcher.matches(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;[ &quot;</span> + requestMatcher + <span class="string">&quot;, &quot;</span> + filters + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，在DefaultSecurityFilterChain的构造方法中，需要传入两个对象，一个是请求 匹配器requestMatcher,另一个则是过滤器集合或者过滤器数组filters。这个实现类比较简单, 这里就不再赘述了。</p><p>  需要注意的是，在一个Spring Security项目中，SecurityFilterChain的实例可能会有多个，在后面的小节中会详细分析，并演示多个SecurityFilterChain实例的情况。</p><h2 id="1-3-SecurityBuilder"><a href="#1-3-SecurityBuilder" class="headerlink" title="1.3 SecurityBuilder"></a>1.3 SecurityBuilder</h2><p>Spring Security中所有需要构建的对象都可以通过SecurityBuilder来实现，默认的过滤器 链、代理过滤器AuthenticationManager 等，都可以通过 SecurityBuilder来构建。SecurityBuilder的实现类如图4-2所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%EF%BC%888%EF%BC%89%EF%BC%882%EF%BC%89.png"></p><center>图 4-2</center><p>  SecurityBuilder：</p><p>  我们先来看SecurityBuilder的源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityBuilder</span>&lt;O&gt; &#123;</span><br><span class="line">O <span class="title function_">build</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由上述代码可以看到，SecurityBuilder中只有一个build方法，就是对象构建方法。build 方法的返回值，就是具体构建的对象泛型O,也就是说不同的SecurityBuilder将来会构建出不同的对象。</p><p>  httpsSecurityBuiIder：</p><p>  httpsSecurityBuilder是用来构建 httpsSecurity对象的，httpsSecurityBuilder 的定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">httpsSecurityBuilder</span>&lt;H <span class="keyword">extends</span> <span class="title class_">httpsSecurityBuilder</span>&lt;H&gt;&gt; <span class="keyword">extends</span></span><br><span class="line"><span class="title class_">SecurityBuilder</span>&lt;DefaultSecurityFilterChain&gt; &#123;</span><br><span class="line">&lt;C <span class="keyword">extends</span> <span class="title class_">SecurityConfigurer</span>&lt;DefaultSecurityFilterChain, H&gt;&gt; C <span class="title function_">getConfigurer</span><span class="params">(</span></span><br><span class="line"><span class="params">Class&lt;C&gt; clazz)</span>;</span><br><span class="line">    </span><br><span class="line">&lt;C <span class="keyword">extends</span> <span class="title class_">SecurityConfigurer</span>&lt;DefaultSecurityFilterChain, H&gt;&gt; C <span class="title function_">removeConfigurer</span><span class="params">(</span></span><br><span class="line"><span class="params">Class&lt;C&gt; clazz)</span>;</span><br><span class="line"></span><br><span class="line">&lt;C&gt; <span class="keyword">void</span> <span class="title function_">setSharedObject</span><span class="params">(Class&lt;C&gt; sharedType, C object)</span>;</span><br><span class="line"></span><br><span class="line">&lt;C&gt; C <span class="title function_">getSharedObject</span><span class="params">(Class&lt;C&gt; sharedType)</span>;</span><br><span class="line"></span><br><span class="line">H <span class="title function_">authenticationProvider</span><span class="params">(AuthenticationProvider authenticationProvider)</span>;</span><br><span class="line"></span><br><span class="line">H <span class="title function_">userDetailsService</span><span class="params">(UserDetailsService userDetailsService)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">H <span class="title function_">addFilterAfter</span><span class="params">(Filter filter, Class&lt;? extends Filter&gt; afterFilter)</span>;</span><br><span class="line"></span><br><span class="line">H <span class="title function_">addFilterBefore</span><span class="params">(Filter filter, Class&lt;? extends Filter&gt; beforeFilter)</span>;</span><br><span class="line"></span><br><span class="line">H <span class="title function_">addFilter</span><span class="params">(Filter filter)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们简单分析一下这段源码：</p><ul><li>httpsSecurityBuilder对象本身在定义时就有一个泛型，这个泛型是httpsSecurityBuilder 的子类，由于默认情况下httpsSecurityBuilder的实现类只有一个httpsSecurity，所以可以暂且把接口中的H都当成httpsSecurity来理解。</li><li>httpsSecurityBuilder 继承自 SecurityBuilder 接口，同时也指定了 SecurityBuilder 中的泛型为DefaultSecurityFilterChain,也就是说，httpsSecurityBuilder最终想要构建的对象是 DefaultSecurityFilterChain。</li><li>getConfigurer方法用来获取一个配置器，所谓的配置器就是xxxConfigurer，我们将在下一小节中详细介绍配置器，</li><li>removeConfigurer方法用来移除一个配置器(相当于从Spring Security过滤器链中移 除一个过滤器)。</li><li>setSharedObject&#x2F;getSharedObject这两个方法用来设置或者获取一个可以在多个配置器之间共享的对象。</li><li>authenticationProvider 方法可以用来配置一个认证器 AuthenticationProvider。</li><li>userDetailsService 方法可以用来配置一个数据源 UserDetailsService。</li><li>addFilterAfter&#x2F;addFilterBefore方法表示在某一个过滤器之后或者之前添加一个自定义的过滤器。</li><li>addFilter方法可以添加一个过滤器，这个过滤器必须是Spring Security框架提供的 过滤器的一个实例或者其扩展，添加完成后，会自动进行过滤器的排序。</li></ul><p>AbstractSecurityBuilder：</p><p>  AbstractSecurityBuilder实现了 SecurityBuilder 接口，并对 build 做了完善，确保只 build 一次。我们来看—下 AbstractSecurityBuilder 源码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSecurityBuilder</span>&lt;O&gt; <span class="keyword">implements</span> <span class="title class_">SecurityBuilder</span>&lt;O&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">building</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> O object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> O <span class="title function_">build</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.building.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line"><span class="built_in">this</span>.object = doBuild();</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.object;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AlreadyBuiltException</span>(<span class="string">&quot;This object has already been built&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> O <span class="title function_">getObject</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.building.get()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This object has not been built&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> O <span class="title function_">doBuild</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上述代码可以看到，在AbstractSecurityBuilder类中:</p><ul><li>首先声明了 building变量，可以确保即使在多线程环境下，配置类也只构建一次。</li><li>对build方法进行重写，并II设置为final,这样在AbstractSecurityBuilder的了类中 将不能再次重写build方法，在build方法内部，通过building变量来控制配置类只构建一次, 具体的构建工作则交给doBuild方法去完成。</li><li>getObject方法用来返回构建的对象。</li><li>doBuild方法则是具体的构建方法，该方法在AbstractSecurityBuilder中是一个抽象方法，具体的实现在其子类中。</li></ul><p>一言以蔽之，AbstractSecurityBuilder的作用是确保目标对象只被构建一次。</p><p>  AbstractConfiguredSecurityBuilder：</p><p>  AbstractConfiguredSecurityBuilder类的源码就稍微长一点，我们分别来看，首先在AbstractConfiguredSecurityBuilder中声明了一个枚举类，用来描述构建过程的不同状态：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">BuildState</span> &#123;</span><br><span class="line">    UNBUILT(<span class="number">0</span>),</span><br><span class="line">    INITIALIZING(<span class="number">1</span>),</span><br><span class="line">    CONFIGURING(<span class="number">2</span>),</span><br><span class="line">    BUILDING(<span class="number">3</span>),</span><br><span class="line">    BUILT(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> order;</span><br><span class="line">    BuildState(<span class="type">int</span> order) &#123;</span><br><span class="line">        <span class="built_in">this</span>.order = order;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInitializing</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INITIALIZING.order == order;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConfigured</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> order &gt;= CONFIGURING.order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，整个构建过程一共有五种不同的状态：</p><ul><li>UNBUILT：配置类构建前。</li><li>INITIALIZING：初始化中(初始化完成之前是这个状态)。</li><li>CONFIGURING：配置中(开始构建之前是这个状态)。</li><li>BUILDING：构建中。</li><li>BUILT：构建完成。</li></ul><p>这个枚举类里边还提供了两个判断方法 islnitializing 表示是否正在初始化中, isConfigured 方法表示是否已完成配置。</p><p>AbstractConfiguredSecurityBuilder中还声明了 configurers变量，用来保存所有的配置类。针对configurers变量，我们可以进行添加配置、移除配置等操作，相关方法如下：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractConfiguredSecurityBuilder</span>&lt;O, B <span class="keyword">extends</span> <span class="title class_">SecurityBuilder</span>&lt;O&gt;&gt;</span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">AbstractSecurityBuilder</span>&lt;O&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(getClass());</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">SecurityConfigurer</span>&lt;O, B&gt;&gt;, List&lt;SecurityConfigurer&lt;O, B&gt;&gt;&gt; configurers = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">SecurityConfigurer</span>&lt;O, B&gt;&gt;, List&lt;SecurityConfigurer&lt;O, B&gt;&gt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;SecurityConfigurer&lt;O, B&gt;&gt; configurersAddedInInitializing = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SecurityConfigurer&lt;O, B&gt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt;, Object&gt; sharedObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt;, Object&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> allowConfigurersOfSameType;</span><br><span class="line"><span class="keyword">private</span> <span class="type">BuildState</span> <span class="variable">buildState</span> <span class="operator">=</span> BuildState.UNBUILT;</span><br><span class="line"><span class="keyword">private</span> ObjectPostProcessor&lt;Object&gt; objectPostProcessor;</span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractConfiguredSecurityBuilder</span><span class="params">(</span></span><br><span class="line"><span class="params">ObjectPostProcessor&lt;Object&gt; objectPostProcessor)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(objectPostProcessor, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractConfiguredSecurityBuilder</span><span class="params">(</span></span><br><span class="line"><span class="params">ObjectPostProcessor&lt;Object&gt; objectPostProcessor,</span></span><br><span class="line"><span class="params"><span class="type">boolean</span> allowConfigurersOfSameType)</span> &#123;</span><br><span class="line">Assert.notNull(objectPostProcessor, <span class="string">&quot;objectPostProcessor cannot be null&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.objectPostProcessor = objectPostProcessor;</span><br><span class="line"><span class="built_in">this</span>.allowConfigurersOfSameType = allowConfigurersOfSameType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> O <span class="title function_">getOrBuild</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (isUnbuilt()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Failed to perform build. Returning null&quot;</span>, e);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;C <span class="keyword">extends</span> <span class="title class_">SecurityConfigurerAdapter</span>&lt;O, B&gt;&gt; C <span class="title function_">apply</span><span class="params">(C configurer)</span></span><br><span class="line"><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">configurer.addObjectPostProcessor(objectPostProcessor);</span><br><span class="line">configurer.setBuilder((B) <span class="built_in">this</span>);</span><br><span class="line">add(configurer);</span><br><span class="line"><span class="keyword">return</span> configurer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;C <span class="keyword">extends</span> <span class="title class_">SecurityConfigurer</span>&lt;O, B&gt;&gt; C <span class="title function_">apply</span><span class="params">(C configurer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">add(configurer);</span><br><span class="line"><span class="keyword">return</span> configurer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; <span class="keyword">void</span> <span class="title function_">setSharedObject</span><span class="params">(Class&lt;C&gt; sharedType, C object)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.sharedObjects.put(sharedType, object);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; C <span class="title function_">getSharedObject</span><span class="params">(Class&lt;C&gt; sharedType)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (C) <span class="built_in">this</span>.sharedObjects.get(sharedType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt;, Object&gt; getSharedObjects() &#123;</span><br><span class="line"><span class="keyword">return</span> Collections.unmodifiableMap(<span class="built_in">this</span>.sharedObjects);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> &lt;C <span class="keyword">extends</span> <span class="title class_">SecurityConfigurer</span>&lt;O, B&gt;&gt; <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(C configurer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Assert.notNull(configurer, <span class="string">&quot;configurer cannot be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">SecurityConfigurer</span>&lt;O, B&gt;&gt; clazz = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">SecurityConfigurer</span>&lt;O, B&gt;&gt;) configurer</span><br><span class="line">.getClass();</span><br><span class="line"><span class="keyword">synchronized</span> (configurers) &#123;</span><br><span class="line"><span class="keyword">if</span> (buildState.isConfigured()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot apply &quot;</span> + configurer</span><br><span class="line">+ <span class="string">&quot; to already built object&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;SecurityConfigurer&lt;O, B&gt;&gt; configs = allowConfigurersOfSameType ? <span class="built_in">this</span>.configurers</span><br><span class="line">.get(clazz) : <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">configs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SecurityConfigurer&lt;O, B&gt;&gt;(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">configs.add(configurer);</span><br><span class="line"><span class="built_in">this</span>.configurers.put(clazz, configs);</span><br><span class="line"><span class="keyword">if</span> (buildState.isInitializing()) &#123;</span><br><span class="line"><span class="built_in">this</span>.configurersAddedInInitializing.add(configurer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;C <span class="keyword">extends</span> <span class="title class_">SecurityConfigurer</span>&lt;O, B&gt;&gt; List&lt;C&gt; <span class="title function_">getConfigurers</span><span class="params">(Class&lt;C&gt; clazz)</span> &#123;</span><br><span class="line">List&lt;C&gt; configs = (List&lt;C&gt;) <span class="built_in">this</span>.configurers.get(clazz);</span><br><span class="line"><span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(configs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;C <span class="keyword">extends</span> <span class="title class_">SecurityConfigurer</span>&lt;O, B&gt;&gt; List&lt;C&gt; <span class="title function_">removeConfigurers</span><span class="params">(Class&lt;C&gt; clazz)</span> &#123;</span><br><span class="line">List&lt;C&gt; configs = (List&lt;C&gt;) <span class="built_in">this</span>.configurers.remove(clazz);</span><br><span class="line"><span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(configs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;C <span class="keyword">extends</span> <span class="title class_">SecurityConfigurer</span>&lt;O, B&gt;&gt; C <span class="title function_">getConfigurer</span><span class="params">(Class&lt;C&gt; clazz)</span> &#123;</span><br><span class="line">List&lt;SecurityConfigurer&lt;O, B&gt;&gt; configs = <span class="built_in">this</span>.configurers.get(clazz);</span><br><span class="line"><span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (configs.size() != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Only one configurer expected for type &quot;</span></span><br><span class="line">+ clazz + <span class="string">&quot;, but got &quot;</span> + configs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (C) configs.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;C <span class="keyword">extends</span> <span class="title class_">SecurityConfigurer</span>&lt;O, B&gt;&gt; C <span class="title function_">removeConfigurer</span><span class="params">(Class&lt;C&gt; clazz)</span> &#123;</span><br><span class="line">List&lt;SecurityConfigurer&lt;O, B&gt;&gt; configs = <span class="built_in">this</span>.configurers.remove(clazz);</span><br><span class="line"><span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (configs.size() != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Only one configurer expected for type &quot;</span></span><br><span class="line">+ clazz + <span class="string">&quot;, but got &quot;</span> + configs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (C) configs.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> O <span class="title function_">objectPostProcessor</span><span class="params">(ObjectPostProcessor&lt;Object&gt; objectPostProcessor)</span> &#123;</span><br><span class="line">Assert.notNull(objectPostProcessor, <span class="string">&quot;objectPostProcessor cannot be null&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.objectPostProcessor = objectPostProcessor;</span><br><span class="line"><span class="keyword">return</span> (O) <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;P&gt; P <span class="title function_">postProcess</span><span class="params">(P object)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.objectPostProcessor.postProcess(object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们解析一下这段源码：</p><ul><li>首先声明了一个configurers变量，用来保存所有的配置类，key是配置类Class对象, 值是一个List集合中放着配置类。</li><li>apply方法有两个，参数类型略有差异，主要功能基本一致，都是向configurers变量中添加配置类，具体的添加过程则是调用add方法。</li><li>add方法用来将所有的配置类保存到configurers中，在添加的过程中，如果 allowConfigurersOfSameType变量为true，则表示允许相同类型的配置类存在，也就是List集合中可以存在多个相同类型的配置类。默认情况下，如果是普通配置类， allowConfigurersOfSameType是false，所以List集合中的配置类始终只有一个配置类；如果在 AuthenticationManagerBuilder 中设置 allowConfigurersOfSameType 为 true,此时相同类型的配置类可以有多个(下文会详细分析AuthenticationManagerBuilder)。</li><li>getConfigurers(Class<C>)方法可以从configurers中返回某一个配置类对应的所有实例</li><li>removeConfigurers方法可以从configurers中移除某一个配置类对应的所有实例，并返回被移除掉的配置类实例集合，</li><li>getConfigurer方法也是获取配置类实例，但是只获取集合中第一项。</li><li>removeConfigurer方法可以从configurers中移除某一个配置类对应的所有配置类实例，并返回被移除掉的配置类实例中的第一项。</li><li>getConfigurers方法是一个私有方法，主要是把所有的配置类实例放到一个集合中返 回.在配置类初始化和配置的时候，会调用到该方法，</li></ul><p>这些就是 AbstractConfiguredSecurityBuilder 中关于 configurers 的所有操作。</p><p>接下来就是AbstractConfiguredSecurityBuilder中的doBuild方法了，这是核心的构建方法。</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> O <span class="title function_">doBuild</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (configurers) &#123;</span><br><span class="line">        buildState = BuildState.INITIALIZING;</span><br><span class="line">        beforeInit();</span><br><span class="line">        init();</span><br><span class="line">        buildState = BuildState.CONFIGURING;</span><br><span class="line">        beforeConfigure();</span><br><span class="line">        configure();</span><br><span class="line">        buildState = BuildState.BUILDING;</span><br><span class="line">        <span class="type">O</span> <span class="variable">result</span> <span class="operator">=</span> performBuild();</span><br><span class="line">        buildState = BuildState.BUILT;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeInit</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeConfigure</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> O <span class="title function_">performBuild</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Collection&lt;SecurityConfigurer&lt;O, B&gt;&gt; configurers = getConfigurers();</span><br><span class="line">    <span class="keyword">for</span> (SecurityConfigurer&lt;O, B&gt; configurer : configurers) &#123;</span><br><span class="line">        configurer.init((B) <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (SecurityConfigurer&lt;O, B&gt; configurer : configurersAddedInInitializing) &#123;</span><br><span class="line">        configurer.init((B) <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Collection&lt;SecurityConfigurer&lt;O, B&gt;&gt; configurers = getConfigurers();</span><br><span class="line">    <span class="keyword">for</span> (SecurityConfigurer&lt;O, B&gt; configurer : configurers) &#123;</span><br><span class="line">        configurer.configure((B) <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Collection&lt;SecurityConfigurer&lt;O, B&gt;&gt; <span class="title function_">getConfigurers</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;SecurityConfigurer&lt;O, B&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SecurityConfigurer&lt;O, B&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (List&lt;SecurityConfigurer&lt;O, B&gt;&gt; configs : <span class="built_in">this</span>.configurers.values()) &#123;</span><br><span class="line">        result.addAll(configs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isUnbuilt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (configurers) &#123;</span><br><span class="line">        <span class="keyword">return</span> buildState == BuildState.UNBUILT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在doBuild方法中，一边更新构建状态，一边执行构建方法由构建方法中,beforeInit 是一个空的初始化方法，如果需要在初始化之前做一些准备工作，可以通过重写该方法实现,</p></li><li><p>init方法是所有配置类的初始化方法，在该方法中，遍历所有的配置类，并调用其 init方法完成初始化操作。</p></li><li><p>beforeConfigure方法可以在configure方法执行之前做一些准备操作心该方法默认也是一个空方法，</p></li><li><p>configure方法用来完成所有配置类的配置，在configure方法中，遍历所有的配置类,分别调用其configure方法完成配置。</p></li><li><p>performBuild方法用来做最终的构建操作，前面的准备工作完成后，最后在 performBuild方法中完成构建，这是一个抽象方法，具体的实现则在不同的配置类中。</p><p>这些就是AbstractConfiguredSecurityBuilder中最主要的几个方法，其他一些方法比较简单，这里就不一一赘述了</p></li></ul><p>ProviderManagerBuilder：</p><p>  ProviderManagerBuilder继承自 SecurityBuilder接口，并制定了构建的对象是 AuthenticationManager, 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProviderManagerBuilder</span>&lt;B <span class="keyword">extends</span> <span class="title class_">ProviderManagerBuilder</span>&lt;B&gt;&gt; <span class="keyword">extends</span></span><br><span class="line"><span class="title class_">SecurityBuilder</span>&lt;AuthenticationManager&gt; &#123;</span><br><span class="line">B <span class="title function_">authenticationProvider</span><span class="params">(AuthenticationProvider authenticationProvider)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，ProviderManagerBuilder 中增加 了一个 authenticationProvider 方法，同时通过泛型指定了构建的对象为AuthenticationManager。</p><p>AuthenticationManagerBuilder：</p><p>AuthenticationManagerBuilder 用来构建 AuthenticationManager 对象，它继承自 AbstractConfiguredSecurityBuilder,并且实现了 ProviderManagerBuilder接口，源码比较长，我们截取部分常用代码，代码如下：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationManagerBuilder</span></span><br><span class="line"><span class="keyword">extends</span></span><br><span class="line"><span class="title class_">AbstractConfiguredSecurityBuilder</span>&lt;AuthenticationManager, AuthenticationManagerBuilder&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">ProviderManagerBuilder</span>&lt;AuthenticationManagerBuilder&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(getClass());</span><br><span class="line"><span class="keyword">private</span> AuthenticationManager parentAuthenticationManager;</span><br><span class="line"><span class="keyword">private</span> List&lt;AuthenticationProvider&gt; authenticationProviders = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> UserDetailsService defaultUserDetailsService;</span><br><span class="line"><span class="keyword">private</span> Boolean eraseCredentials;</span><br><span class="line"><span class="keyword">private</span> AuthenticationEventPublisher eventPublisher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AuthenticationManagerBuilder</span><span class="params">(ObjectPostProcessor&lt;Object&gt; objectPostProcessor)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(objectPostProcessor, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> AuthenticationManagerBuilder <span class="title function_">parentAuthenticationManager</span><span class="params">(</span></span><br><span class="line"><span class="params">AuthenticationManager authenticationManager)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (authenticationManager <span class="keyword">instanceof</span> ProviderManager) &#123;</span><br><span class="line">eraseCredentials(((ProviderManager) authenticationManager)</span><br><span class="line">.isEraseCredentialsAfterAuthentication());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.parentAuthenticationManager = authenticationManager;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> AuthenticationManagerBuilder <span class="title function_">authenticationEventPublisher</span><span class="params">(</span></span><br><span class="line"><span class="params">AuthenticationEventPublisher eventPublisher)</span> &#123;</span><br><span class="line">Assert.notNull(eventPublisher, <span class="string">&quot;AuthenticationEventPublisher cannot be null&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.eventPublisher = eventPublisher;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> AuthenticationManagerBuilder <span class="title function_">eraseCredentials</span><span class="params">(<span class="type">boolean</span> eraseCredentials)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.eraseCredentials = eraseCredentials;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> InMemoryUserDetailsManagerConfigurer&lt;AuthenticationManagerBuilder&gt; <span class="title function_">inMemoryAuthentication</span><span class="params">()</span></span><br><span class="line"><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> apply(<span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManagerConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> JdbcUserDetailsManagerConfigurer&lt;AuthenticationManagerBuilder&gt; <span class="title function_">jdbcAuthentication</span><span class="params">()</span></span><br><span class="line"><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> apply(<span class="keyword">new</span> <span class="title class_">JdbcUserDetailsManagerConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">UserDetailsService</span>&gt; DaoAuthenticationConfigurer&lt;AuthenticationManagerBuilder, T&gt; <span class="title function_">userDetailsService</span><span class="params">(</span></span><br><span class="line"><span class="params">T userDetailsService)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="built_in">this</span>.defaultUserDetailsService = userDetailsService;</span><br><span class="line"><span class="keyword">return</span> apply(<span class="keyword">new</span> <span class="title class_">DaoAuthenticationConfigurer</span>&lt;&gt;(</span><br><span class="line">userDetailsService));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> LdapAuthenticationProviderConfigurer&lt;AuthenticationManagerBuilder&gt; <span class="title function_">ldapAuthentication</span><span class="params">()</span></span><br><span class="line"><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> apply(<span class="keyword">new</span> <span class="title class_">LdapAuthenticationProviderConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> AuthenticationManagerBuilder <span class="title function_">authenticationProvider</span><span class="params">(</span></span><br><span class="line"><span class="params">AuthenticationProvider authenticationProvider)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.authenticationProviders.add(authenticationProvider);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ProviderManager <span class="title function_">performBuild</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">if</span> (!isConfigured()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;No authenticationProviders and no parentAuthenticationManager defined. Returning null.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ProviderManager</span> <span class="variable">providerManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProviderManager</span>(authenticationProviders,</span><br><span class="line">parentAuthenticationManager);</span><br><span class="line"><span class="keyword">if</span> (eraseCredentials != <span class="literal">null</span>) &#123;</span><br><span class="line">providerManager.setEraseCredentialsAfterAuthentication(eraseCredentials);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (eventPublisher != <span class="literal">null</span>) &#123;</span><br><span class="line">providerManager.setAuthenticationEventPublisher(eventPublisher);</span><br><span class="line">&#125;</span><br><span class="line">providerManager = postProcess(providerManager);</span><br><span class="line"><span class="keyword">return</span> providerManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConfigured</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> !authenticationProviders.isEmpty() || parentAuthenticationManager != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> UserDetailsService <span class="title function_">getDefaultUserDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.defaultUserDetailsService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;C <span class="keyword">extends</span> <span class="title class_">UserDetailsAwareConfigurer</span>&lt;AuthenticationManagerBuilder, ? <span class="keyword">extends</span> <span class="title class_">UserDetailsService</span>&gt;&gt; C <span class="title function_">apply</span><span class="params">(</span></span><br><span class="line"><span class="params">C configurer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="built_in">this</span>.defaultUserDetailsService = configurer.getUserDetailsService();</span><br><span class="line"><span class="keyword">return</span> (C) <span class="built_in">super</span>.apply(configurer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先在AuthenticationManagerBuilder的构造方法中，调用了父类的构造方法，注意第二个参数传递了true,表示允许相同类型的配置类同时存在(结合 AbstractConfiguredSecurityBuilder 的源码来理解)</li><li>parentAuthenticationManager 方法用来给一个 AuthenticationManager 设置 parents</li><li>inMemoryAuthentication方法用来配置基于内存的数据源，该方法会自动创建 InMemoryUserDetailsManagerConfigurer配置类，并最终将该配置类添加到父类的configurers 变量中。由于设置了允许相同类型的配置类同时存在，因此inMemoryAuthentication方法可以反复调用多次</li><li>jdbcAuthentication 以及 userDetailsService 方法与 inMemoryAuthentication 方法类似, 也是用来配置数据源的，这里不再赘述。</li><li>authenticationProvider 方法用来向 authenticationProviders 集合中添加 AuthenticationProvider对象，根据前面第3节的介绍，我们己经知道一个AuthenticationManager实例中包含多个 AuthenticationProvider 实例，那么多个 AuthenticationProvider 实例可以通过 authenticationProvider方法进行添加。</li><li>performBuild方法则执行具体的构建工作，常用的AuthenticationManager实例就是 ProviderManager，所以这里创建 ProviderManager 对象，并旦配置 authenticationProviders 和 parentAuthenticationManager对象，ProviderManager对象创建成功之后，再去对象后置处理器中处理一遍再返回。</li></ul><p>这就是AuthenticationManagerBuilder中的一个大致逻辑。</p><p>httpsSecurity：</p><p>  httpsSecurity的主要作用是用来构建一条过滤器链，并反映到代码上，也就是构建一个 DefaultSecurityFilterChain 对象，一个 DefaultSecurityFilterChain 对象包含一个路径匹配器和多个Spring Security 过滤器，httpsSecurity 中通过收集各种各样的 xxxConfigurer,将 Spring Security 过滤器对应的配置类收集起来，并保存到父类AbstractConfiguredSecurityBuilder的configurers 变量中，在后续的构建过程中，再将这些xxxConfigurer构建为具体的Spring Security过滤器, 同时添加到httpsSecurity的filters对象中。</p><p>  由于httpsSecurity中存在大量功能类似的方法，因此这里挑选一个作为例子用来说明httpsSecurity的配置原理，代码如下：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">httpsSecurity</span> <span class="keyword">extends</span></span><br><span class="line"><span class="title class_">AbstractConfiguredSecurityBuilder</span>&lt;DefaultSecurityFilterChain, httpsSecurity&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">SecurityBuilder</span>&lt;DefaultSecurityFilterChain&gt;,</span><br><span class="line">httpsSecurityBuilder&lt;httpsSecurity&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RequestMatcherConfigurer requestMatcherConfigurer;</span><br><span class="line"><span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="type">RequestMatcher</span> <span class="variable">requestMatcher</span> <span class="operator">=</span> AnyRequestMatcher.INSTANCE;</span><br><span class="line"><span class="keyword">private</span> <span class="type">FilterComparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterComparator</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">httpsSecurity</span><span class="params">(ObjectPostProcessor&lt;Object&gt; objectPostProcessor,</span></span><br><span class="line"><span class="params">AuthenticationManagerBuilder authenticationBuilder,</span></span><br><span class="line"><span class="params">Map&lt;Class&lt;? extends Object&gt;, Object&gt; sharedObjects)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(objectPostProcessor);</span><br><span class="line">Assert.notNull(authenticationBuilder, <span class="string">&quot;authenticationBuilder cannot be null&quot;</span>);</span><br><span class="line">setSharedObject(AuthenticationManagerBuilder.class, authenticationBuilder);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt;, Object&gt; entry : sharedObjects</span><br><span class="line">.entrySet()) &#123;</span><br><span class="line">setSharedObject((Class&lt;Object&gt;) entry.getKey(), entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> (ApplicationContext) sharedObjects</span><br><span class="line">.get(ApplicationContext.class);</span><br><span class="line"><span class="built_in">this</span>.requestMatcherConfigurer = <span class="keyword">new</span> <span class="title class_">RequestMatcherConfigurer</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ApplicationContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getSharedObject(ApplicationContext.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> OpenIDLoginConfigurer&lt;httpsSecurity&gt; <span class="title function_">openidLogin</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">OpenIDLoginConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> HeadersConfigurer&lt;httpsSecurity&gt; <span class="title function_">headers</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">HeadersConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CorsConfigurer&lt;httpsSecurity&gt; <span class="title function_">cors</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">CorsConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> SessionManagementConfigurer&lt;httpsSecurity&gt; <span class="title function_">sessionManagement</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">SessionManagementConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> PortMapperConfigurer&lt;httpsSecurity&gt; <span class="title function_">portMapper</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">PortMapperConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> JeeConfigurer&lt;httpsSecurity&gt; <span class="title function_">jee</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">JeeConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> X509Configurer&lt;httpsSecurity&gt; <span class="title function_">x509</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">X509Configurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> RememberMeConfigurer&lt;httpsSecurity&gt; <span class="title function_">rememberMe</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">RememberMeConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ExpressionUrlAuthorizationConfigurer&lt;httpsSecurity&gt;.ExpressionInterceptUrlRegistry <span class="title function_">authorizeRequests</span><span class="params">()</span></span><br><span class="line"><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> getContext();</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">ExpressionUrlAuthorizationConfigurer</span>&lt;&gt;(context))</span><br><span class="line">.getRegistry();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> RequestCacheConfigurer&lt;httpsSecurity&gt; <span class="title function_">requestCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">RequestCacheConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ExceptionHandlingConfigurer&lt;httpsSecurity&gt; <span class="title function_">exceptionHandling</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">ExceptionHandlingConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> SecurityContextConfigurer&lt;httpsSecurity&gt; <span class="title function_">securityContext</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">SecurityContextConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ServletApiConfigurer&lt;httpsSecurity&gt; <span class="title function_">servletApi</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">ServletApiConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CsrfConfigurer&lt;httpsSecurity&gt; <span class="title function_">csrf</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> getContext();</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">CsrfConfigurer</span>&lt;&gt;(context));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> LogoutConfigurer&lt;httpsSecurity&gt; <span class="title function_">logout</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">LogoutConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> AnonymousConfigurer&lt;httpsSecurity&gt; <span class="title function_">anonymous</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">AnonymousConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> FormLoginConfigurer&lt;httpsSecurity&gt; <span class="title function_">formLogin</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">FormLoginConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> OAuth2LoginConfigurer&lt;httpsSecurity&gt; <span class="title function_">oauth2Login</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">OAuth2LoginConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ChannelSecurityConfigurer&lt;httpsSecurity&gt;.ChannelRequestMatcherRegistry <span class="title function_">requiresChannel</span><span class="params">()</span></span><br><span class="line"><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> getContext();</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">ChannelSecurityConfigurer</span>&lt;&gt;(context))</span><br><span class="line">.getRegistry();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> httpsBasicConfigurer&lt;httpsSecurity&gt; <span class="title function_">httpsBasic</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> getOrApply(<span class="keyword">new</span> <span class="title class_">httpsBasicConfigurer</span>&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; <span class="keyword">void</span> <span class="title function_">setSharedObject</span><span class="params">(Class&lt;C&gt; sharedType, C object)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.setSharedObject(sharedType, object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeConfigure</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">setSharedObject(AuthenticationManager.class, getAuthenticationRegistry().build());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> DefaultSecurityFilterChain <span class="title function_">performBuild</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Collections.sort(filters, comparator);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSecurityFilterChain</span>(requestMatcher, filters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> httpsSecurity <span class="title function_">authenticationProvider</span><span class="params">(</span></span><br><span class="line"><span class="params">AuthenticationProvider authenticationProvider)</span> &#123;</span><br><span class="line">getAuthenticationRegistry().authenticationProvider(authenticationProvider);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> httpsSecurity <span class="title function_">userDetailsService</span><span class="params">(UserDetailsService userDetailsService)</span></span><br><span class="line"><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">getAuthenticationRegistry().userDetailsService(userDetailsService);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AuthenticationManagerBuilder <span class="title function_">getAuthenticationRegistry</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getSharedObject(AuthenticationManagerBuilder.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> httpsSecurity <span class="title function_">addFilterAfter</span><span class="params">(Filter filter, Class&lt;? extends Filter&gt; afterFilter)</span> &#123;</span><br><span class="line">comparator.registerAfter(filter.getClass(), afterFilter);</span><br><span class="line"><span class="keyword">return</span> addFilter(filter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> httpsSecurity <span class="title function_">addFilterBefore</span><span class="params">(Filter filter,</span></span><br><span class="line"><span class="params">Class&lt;? extends Filter&gt; beforeFilter)</span> &#123;</span><br><span class="line">comparator.registerBefore(filter.getClass(), beforeFilter);</span><br><span class="line"><span class="keyword">return</span> addFilter(filter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> httpsSecurity <span class="title function_">addFilter</span><span class="params">(Filter filter)</span> &#123;</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">Filter</span>&gt; filterClass = filter.getClass();</span><br><span class="line"><span class="keyword">if</span> (!comparator.isRegistered(filterClass)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line"><span class="string">&quot;The Filter class &quot;</span></span><br><span class="line">+ filterClass.getName()</span><br><span class="line">+ <span class="string">&quot; does not have a registered order and cannot be added without a specified order. Consider using addFilterBefore or addFilterAfter instead.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.filters.add(filter);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> httpsSecurity <span class="title function_">addFilterAt</span><span class="params">(Filter filter, Class&lt;? extends Filter&gt; atFilter)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.comparator.registerAt(filter.getClass(), atFilter);</span><br><span class="line"><span class="keyword">return</span> addFilter(filter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> RequestMatcherConfigurer <span class="title function_">requestMatchers</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> requestMatcherConfigurer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> httpsSecurity <span class="title function_">requestMatcher</span><span class="params">(RequestMatcher requestMatcher)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.requestMatcher = requestMatcher;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> httpsSecurity <span class="title function_">antMatcher</span><span class="params">(String antPattern)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> requestMatcher(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(antPattern));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> httpsSecurity <span class="title function_">mvcMatcher</span><span class="params">(String mvcPattern)</span> &#123;</span><br><span class="line"><span class="type">HandlerMappingIntrospector</span> <span class="variable">introspector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMappingIntrospector</span>(getContext());</span><br><span class="line"><span class="keyword">return</span> requestMatcher(<span class="keyword">new</span> <span class="title class_">MvcRequestMatcher</span>(introspector, mvcPattern));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> httpsSecurity <span class="title function_">regexMatcher</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> requestMatcher(<span class="keyword">new</span> <span class="title class_">RegexRequestMatcher</span>(pattern, <span class="literal">null</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MvcMatchersRequestMatcherConfigurer</span> <span class="keyword">extends</span> <span class="title class_">RequestMatcherConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">MvcMatchersRequestMatcherConfigurer</span><span class="params">(ApplicationContext context,</span></span><br><span class="line"><span class="params">List&lt;MvcRequestMatcher&gt; matchers)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(context);</span><br><span class="line"><span class="built_in">this</span>.matchers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> RequestMatcherConfigurer <span class="title function_">servletPath</span><span class="params">(String servletPath)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (RequestMatcher matcher : <span class="built_in">this</span>.matchers) &#123;</span><br><span class="line">((MvcRequestMatcher) matcher).setServletPath(servletPath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMatcherConfigurer</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">AbstractRequestMatcherRegistry</span>&lt;RequestMatcherConfigurer&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> List&lt;RequestMatcher&gt; matchers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">RequestMatcherConfigurer</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">setApplicationContext(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MvcMatchersRequestMatcherConfigurer <span class="title function_">mvcMatchers</span><span class="params">(httpsMethod method,</span></span><br><span class="line"><span class="params">String... mvcPatterns)</span> &#123;</span><br><span class="line">List&lt;MvcRequestMatcher&gt; mvcMatchers = createMvcMatchers(method, mvcPatterns);</span><br><span class="line">setMatchers(mvcMatchers);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MvcMatchersRequestMatcherConfigurer</span>(getContext(), mvcMatchers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MvcMatchersRequestMatcherConfigurer <span class="title function_">mvcMatchers</span><span class="params">(String... patterns)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mvcMatchers(<span class="literal">null</span>, patterns);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> RequestMatcherConfigurer <span class="title function_">chainRequestMatchers</span><span class="params">(</span></span><br><span class="line"><span class="params">List&lt;RequestMatcher&gt; requestMatchers)</span> &#123;</span><br><span class="line">setMatchers(requestMatchers);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setMatchers</span><span class="params">(List&lt;? extends RequestMatcher&gt; requestMatchers)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.matchers.addAll(requestMatchers);</span><br><span class="line">requestMatcher(<span class="keyword">new</span> <span class="title class_">OrRequestMatcher</span>(<span class="built_in">this</span>.matchers));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> httpsSecurity <span class="title function_">and</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> httpsSecurity.<span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> &lt;C <span class="keyword">extends</span> <span class="title class_">SecurityConfigurerAdapter</span>&lt;DefaultSecurityFilterChain, httpsSecurity&gt;&gt; C <span class="title function_">getOrApply</span><span class="params">(</span></span><br><span class="line"><span class="params">C configurer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">C</span> <span class="variable">existingConfig</span> <span class="operator">=</span> (C) getConfigurer(configurer.getClass());</span><br><span class="line"><span class="keyword">if</span> (existingConfig != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> existingConfig;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> apply(configurer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以form表单登录配置为例，在httpsSecurity中有两个重载方法可以进行配置：第一个是一个无参的formLogin方法，该方法的返回值是一个FormLoginConfigurer<httpsSecurity> 对象，开发者可以在该对象的基础上继续完善对form表单的配置，我们在前面章节中配置的表单登录都是通过这种方式来进行配置的。第二个是一个有参的formLogin方法，该方法的参数是一个FormLoginConfigurer对象，返回值则是一个httpsSecurity对象，也就是说开发者可以提前在外面配置好FormLoginConfigurer对象，然后直接传进来进行配置即可，返回值 httpsSecurity对象则可以在方法返回后直接进行其他过滤器的配置。无论是有参还是无参，最终都会调用到getOrApply方法，该方法会调用父类的getConfigurer方法去查看是否己经有对应的配置类了，如果有，则直接返回；如果没有，则调用apply方法添加到父类的configurer变量中 httpsSecurity 中其他过滤器的配置都和form表单登录配置类似，这里就不再赘述了。</li><li>每一套过滤器链都会有一个AuthenticationManager对象来进行认证操作(如果认证失败，则会调用AuthenticationManager的parent再次进行认证)，主要是通过authenticationProvider方法配置执行认证的authenticationProvider对象，通过userDetailsService方法配置 UserDetailsService,最后在 beforeConfigure 方法中触发 AuthenticationManager 对象的构建。</li><li>performBuild方法则是进行DefaultSecurityFilterChain对象的构建，传入请求匹配器和过滤器集合filters,在构建之前，会先按照既定的顺序对filters进行排序。</li><li>通过addFilterAfter、addFilterBefore两个方法，我们可以在某一个过滤器之后或者之前添加一个自定义的过滤器(该方法巳在httpsSecurityBuilder中声明，此处是具体实现)。</li><li>addFilter方法可以向过滤器链中添加一个过滤器，这个过滤器必须是Spring Security 框架提供的过滤器的一个实例或者其扩展，实际上，在每一个xxxConfigurer的configure方法中，都会调用addFilter方法将构建好的过滤器添加到httpsSecurity中的filters集合中(addFilter 方法已在httpsSecurityBuilder中声明，此处是具体实现)。</li><li>addFilterAt方法可以在指定位置添加一个过滤器。需要注意的是，在同一个位置添加多个过滤器并不会覆盖现有的过滤器。</li></ul><p>  这便是httpsSecurity的基本功能。</p><p>WebSecurity：</p><p>  相比于httpsSecurity, WebSecurity是在一个更大的层面上去构建过滤器。一个httpsSecurity 对象可以构建一个过滤器链，也就是一个DefaultSecurityFilterChain对象，而一个项目中可以存在多个httpsSecurity对象，也就可以构建多个DefaultSecurityFilterChain过滤器链。</p><p>WebSecurity 负责将 httpsSecurity 所构建的 DefaultSecurityFilterChain 对象(可能有多个)， 以及其他一些需要忽略的请求，再次重新构建为一个FilterChainProxy对象，同时添加上https 防火墙，</p><p>  我们来看一下WebSecurity中的几个关键方法：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WebSecurity</span> <span class="keyword">extends</span></span><br><span class="line"><span class="title class_">AbstractConfiguredSecurityBuilder</span>&lt;Filter, WebSecurity&gt; <span class="keyword">implements</span></span><br><span class="line"><span class="title class_">SecurityBuilder</span>&lt;Filter&gt;, ApplicationContextAware &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;RequestMatcher&gt; ignoredRequests = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;SecurityBuilder&lt;? <span class="keyword">extends</span> <span class="title class_">SecurityFilterChain</span>&gt;&gt; securityFilterChainBuilders = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SecurityBuilder&lt;? <span class="keyword">extends</span> <span class="title class_">SecurityFilterChain</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IgnoredRequestConfigurer ignoredRequestRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> FilterSecurityInterceptor filterSecurityInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> httpsFirewall httpsFirewall;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> debugEnabled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> WebInvocationPrivilegeEvaluator privilegeEvaluator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">DefaultWebSecurityExpressionHandler</span> <span class="variable">defaultWebSecurityExpressionHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityExpressionHandler</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SecurityExpressionHandler&lt;FilterInvocation&gt; expressionHandler = defaultWebSecurityExpressionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Runnable</span> <span class="variable">postBuildAction</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">WebSecurity</span><span class="params">(ObjectPostProcessor&lt;Object&gt; objectPostProcessor)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(objectPostProcessor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> IgnoredRequestConfigurer <span class="title function_">ignoring</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ignoredRequestRegistry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> WebSecurity <span class="title function_">httpsFirewall</span><span class="params">(httpsFirewall httpsFirewall)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.httpsFirewall = httpsFirewall;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> WebSecurity <span class="title function_">debug</span><span class="params">(<span class="type">boolean</span> debugEnabled)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.debugEnabled = debugEnabled;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> WebSecurity <span class="title function_">addSecurityFilterChainBuilder</span><span class="params">(</span></span><br><span class="line"><span class="params">SecurityBuilder&lt;? extends SecurityFilterChain&gt; securityFilterChainBuilder)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.securityFilterChainBuilders.add(securityFilterChainBuilder);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> WebSecurity <span class="title function_">privilegeEvaluator</span><span class="params">(</span></span><br><span class="line"><span class="params">WebInvocationPrivilegeEvaluator privilegeEvaluator)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.privilegeEvaluator = privilegeEvaluator;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> WebSecurity <span class="title function_">expressionHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">SecurityExpressionHandler&lt;FilterInvocation&gt; expressionHandler)</span> &#123;</span><br><span class="line">Assert.notNull(expressionHandler, <span class="string">&quot;expressionHandler cannot be null&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.expressionHandler = expressionHandler;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> SecurityExpressionHandler&lt;FilterInvocation&gt; <span class="title function_">getExpressionHandler</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> expressionHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> WebInvocationPrivilegeEvaluator <span class="title function_">getPrivilegeEvaluator</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (privilegeEvaluator != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> privilegeEvaluator;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> filterSecurityInterceptor == <span class="literal">null</span> ? <span class="literal">null</span></span><br><span class="line">: <span class="keyword">new</span> <span class="title class_">DefaultWebInvocationPrivilegeEvaluator</span>(filterSecurityInterceptor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> WebSecurity <span class="title function_">securityInterceptor</span><span class="params">(FilterSecurityInterceptor securityInterceptor)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.filterSecurityInterceptor = securityInterceptor;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> WebSecurity <span class="title function_">postBuildAction</span><span class="params">(Runnable postBuildAction)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.postBuildAction = postBuildAction;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Filter <span class="title function_">performBuild</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Assert.state(</span><br><span class="line">!securityFilterChainBuilders.isEmpty(),</span><br><span class="line"><span class="string">&quot;At least one SecurityBuilder&lt;? extends SecurityFilterChain&gt; needs to be specified. Typically this done by adding a @Configuration that extends WebSecurityConfigurerAdapter. More advanced users can invoke &quot;</span></span><br><span class="line">+ WebSecurity.class.getSimpleName()</span><br><span class="line">+ <span class="string">&quot;.addSecurityFilterChainBuilder directly&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">chainSize</span> <span class="operator">=</span> ignoredRequests.size() + securityFilterChainBuilders.size();</span><br><span class="line">List&lt;SecurityFilterChain&gt; securityFilterChains = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">chainSize);</span><br><span class="line"><span class="keyword">for</span> (RequestMatcher ignoredRequest : ignoredRequests) &#123;</span><br><span class="line">securityFilterChains.add(<span class="keyword">new</span> <span class="title class_">DefaultSecurityFilterChain</span>(ignoredRequest));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (SecurityBuilder&lt;? <span class="keyword">extends</span> <span class="title class_">SecurityFilterChain</span>&gt; securityFilterChainBuilder : securityFilterChainBuilders) &#123;</span><br><span class="line">securityFilterChains.add(securityFilterChainBuilder.build());</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">FilterChainProxy</span> <span class="variable">filterChainProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterChainProxy</span>(securityFilterChains);</span><br><span class="line"><span class="keyword">if</span> (httpsFirewall != <span class="literal">null</span>) &#123;</span><br><span class="line">filterChainProxy.setFirewall(httpsFirewall);</span><br><span class="line">&#125;</span><br><span class="line">filterChainProxy.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line"><span class="type">Filter</span> <span class="variable">result</span> <span class="operator">=</span> filterChainProxy;</span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;\n\n&quot;</span></span><br><span class="line">+ <span class="string">&quot;********************************************************************\n&quot;</span></span><br><span class="line">+ <span class="string">&quot;**********        Security debugging is enabled.       *************\n&quot;</span></span><br><span class="line">+ <span class="string">&quot;**********    This may include sensitive information.  *************\n&quot;</span></span><br><span class="line">+ <span class="string">&quot;**********      Do not use in a production system!     *************\n&quot;</span></span><br><span class="line">+ <span class="string">&quot;********************************************************************\n\n&quot;</span>);</span><br><span class="line">result = <span class="keyword">new</span> <span class="title class_">DebugFilter</span>(filterChainProxy);</span><br><span class="line">&#125;</span><br><span class="line">postBuildAction.run();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MvcMatchersIgnoredRequestConfigurer</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">IgnoredRequestConfigurer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;MvcRequestMatcher&gt; mvcMatchers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">MvcMatchersIgnoredRequestConfigurer</span><span class="params">(ApplicationContext context,</span></span><br><span class="line"><span class="params">List&lt;MvcRequestMatcher&gt; mvcMatchers)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(context);</span><br><span class="line"><span class="built_in">this</span>.mvcMatchers = mvcMatchers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> IgnoredRequestConfigurer <span class="title function_">servletPath</span><span class="params">(String servletPath)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (MvcRequestMatcher matcher : <span class="built_in">this</span>.mvcMatchers) &#123;</span><br><span class="line">matcher.setServletPath(servletPath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IgnoredRequestConfigurer</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">AbstractRequestMatcherRegistry</span>&lt;IgnoredRequestConfigurer&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">IgnoredRequestConfigurer</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">setApplicationContext(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MvcMatchersIgnoredRequestConfigurer <span class="title function_">mvcMatchers</span><span class="params">(httpsMethod method,</span></span><br><span class="line"><span class="params">String... mvcPatterns)</span> &#123;</span><br><span class="line">List&lt;MvcRequestMatcher&gt; mvcMatchers = createMvcMatchers(method, mvcPatterns);</span><br><span class="line">WebSecurity.<span class="built_in">this</span>.ignoredRequests.addAll(mvcMatchers);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MvcMatchersIgnoredRequestConfigurer</span>(getApplicationContext(),</span><br><span class="line">mvcMatchers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MvcMatchersIgnoredRequestConfigurer <span class="title function_">mvcMatchers</span><span class="params">(String... mvcPatterns)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mvcMatchers(<span class="literal">null</span>, mvcPatterns);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> IgnoredRequestConfigurer <span class="title function_">chainRequestMatchers</span><span class="params">(</span></span><br><span class="line"><span class="params">List&lt;RequestMatcher&gt; requestMatchers)</span> &#123;</span><br><span class="line">WebSecurity.<span class="built_in">this</span>.ignoredRequests.addAll(requestMatchers);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> WebSecurity <span class="title function_">and</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> WebSecurity.<span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span></span><br><span class="line"><span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="built_in">this</span>.defaultWebSecurityExpressionHandler</span><br><span class="line">.setApplicationContext(applicationContext);</span><br><span class="line"><span class="built_in">this</span>.ignoredRequestRegistry = <span class="keyword">new</span> <span class="title class_">IgnoredRequestConfigurer</span>(applicationContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先在WebSecurity中声明了 ignoredRequests集合，这个集合中保存了所有被忽略的请求，因为在实际项目中，并非所有的请求都需要经过Spring Security过滤器链，有一些静态资源可能不需要权限认证，直接返回给客户端即可，那么这些需要忽略的请求可以直接保存 在 ignoredRequests 变量中。</li><li>接下来声明了一个securityFilterChainBuilders集合，该集合用来保存所有的 httpsSecurity 对象，每一个 httpsSecurity 对象创建成功之后，通过 addSecurityFliterChainBuilder 方法将 httpsSecurity 对象添加到 securityFilterChainBuilders 集合中。</li><li>httpsFirewall方法可以用来配置请求防火墙，关于请求防火墙，我们会在后面的章节中专门讲解。</li><li>performBuild方法则是具体的构建方法，在该方法中，首先统计出过滤器链的总个数(被忽略的请求个数+通过httpsSecurity创建出来的过滤器链个数)，然后创建一个集合 securityFilterChains,遍历被忽略的请求并分别构建成DefaultSecurityFilterChain对象保存到 securityFilterChains集合中。需要注意的是，对于被忽略的请求，在构建DefaultSecurityFilterChain对象时，只是传入了请求匹配器，而没有传入对应的过滤器链，这就意味着这些被忽略掉的请求，将来不必经过Spring Security过滤器链；接下来再遍历securityFilterChainBuilders集合，调用每个对象的build方法构建DefaultSecurityFilterChain并存入securityFilterChains集合中，然后传入securityFilterChains集合构建FilterChainProxy对象，最后再设置https 防火墙。所有设置完成之后，最后返回filterChainProxy对象。</li></ul><p>  FilterChainProxy就是我们最终构建出来的代理过滤器链，通过Spring提供的DelegatingFilterProxy将FilterChainProxy对象嵌入到WebFilter中(原生过滤器链中)。</p><p>  读者可以回忆一下前面我们绘制的FilterChainProxy架构图，对照着来理解上面的源码应该就很容易了，如图4-3所示。</p><p>  至此，关于SecurityBuilder体系中的几个关键类就介绍完了 ,至于httpsSecurity和 WebSecurity是怎么配置到一起的，我们将在后面的章节中进行分析。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%EF%BC%888%EF%BC%89%EF%BC%883%EF%BC%89.png"></p><center>图 4-3</center><h2 id="1-4-FilterChainProxy"><a href="#1-4-FilterChainProxy" class="headerlink" title="1.4 FilterChainProxy"></a>1.4 FilterChainProxy</h2><p>FilterChainProxy 通过 DelegatingFilterProxy 代理过滤器被集成到 WebFilter 中, DelegatingFilterProxy作为一个代理对象，相信很多读者可能都用过(例如在Spring中整合Shiro 就会用到)，它不承载具体的业务。所以，Spring Security中的过滤器链的最终执行，就是在FilterChainProxy中，因此这里也 来分析一下FilterChainProxy的源码。</p><p>  FilterChainProxy的源码比较长，我们一段一段来看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;SecurityFilterChain&gt; filterChains;</span><br><span class="line"><span class="keyword">private</span> <span class="type">FilterChainValidator</span> <span class="variable">filterChainValidator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullFilterChainValidator</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">httpsFirewall</span> <span class="variable">firewall</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StricthttpsFirewall</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FilterChainProxy</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FilterChainProxy</span><span class="params">(SecurityFilterChain chain)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Arrays.asList(chain));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FilterChainProxy</span><span class="params">(List&lt;SecurityFilterChain&gt; filterChains)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.filterChains = filterChains;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先声明了三个变量：</p><ul><li>由于在Spring Security中可以同时存在多个过滤器链,filterchains就是用来保存过滤器链的，注意保存的是过滤器链，而不是一个个具体的过滤器，</li><li>FilterChainValidator是一个过滤器链配置完成后的验证器，默认使用 NullFilterChainValidator其实没有做任何验证。</li><li>创建了一个默认的防火墙对象firewall。</li></ul><p>在构造方法中传入过滤器链的集合，并赋值给filterChains变量。</p><p>由于FilterChainProxy本质上就是一个过滤器，因此它的核心方法就是doFilter方法，接下来我们来看一下doFilter方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">                     FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">clearContext</span> <span class="operator">=</span> request.getAttribute(FILTER_APPLIED) == <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (clearContext) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">            doFilterInternal(request, response, chain);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            SecurityContextHolder.clearContext();</span><br><span class="line">            request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        doFilterInternal(request, response, chain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  doFilter方法相当于是整个Spring Security过滤器链的入口，我们在前面章节中所涉及的 一些具体的过滤器如SecurityContextPersistenceFilter,都是在该doFilter方法之后执行的。作 为整个过滤器链的入口，这里多了一个clearContext变量，如果是第一次执行该doFilter方法, 执行完成后，在finally代码块中需要从SecurityContextHolder里清除用户信息，这个主要是为了防止用户没有正确配置SecurityContextPersistenceFilter,从而导致登录用户信息没有被正确清除，进而发生内存泄漏。</p><p>  在doFilter方法中，过滤器的具体执行则交给了 doFilterlnternal方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">                              FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException</span><br><span class="line">                              </span><br><span class="line">    <span class="type">FirewalledRequest</span> <span class="variable">fwRequest</span> <span class="operator">=</span> firewall.getFirewalledRequest((httpsServletRequest) request);</span><br><span class="line">    <span class="type">httpsServletResponse</span> <span class="variable">fwResponse</span> <span class="operator">=</span> firewall.getFirewalledResponse((httpsServletResponse) response);</span><br><span class="line"></span><br><span class="line">    List&lt;Filter&gt; filters = getFilters(fwRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filters == <span class="literal">null</span> || filters.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(UrlUtils.buildRequestUrl(fwRequest)</span><br><span class="line">                         + (filters == <span class="literal">null</span> ? <span class="string">&quot; has no matching filters&quot;</span></span><br><span class="line">                            : <span class="string">&quot; has an empty filter list&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        fwRequest.reset();</span><br><span class="line">        chain.doFilter(fwRequest, fwResponse);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">VirtualFilterChain</span> <span class="variable">vfc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VirtualFilterChain</span>(fwRequest, chain, filters);</span><br><span class="line">    vfc.doFilter(fwRequest, fwResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在doFilterlnternal方法中，首先会将request对象转换为一个FirewalledRequest对象，这个转换过程会进行https防火墙处理(https防火墙将在后面详细介绍),同时将response对象也转为httpsServletResponse。接下来调用getFilters方法获取当前请求对应的过滤器链， getFilters方法会遍历filterchains集合，进而判断出当前请求和哪一个过滤器链是对应的，如果找到的过滤器链filters为null,或者filters中没有元素，说明当前请求并不需要经过SpringSecurity过滤器链，此时执行Request.reset方法对https防火墙中的属性进行重置，再执行 chain.doFilter方法，回到WebFilter中，Spring Security过滤器链将被跳过(回忆上一小结 WebSecurity中配置的忽略请求)。如果filters集合中是有元素的，也就是说当前请求需要经过filters集合中元素所构成的过滤器链,那么构建一个虚拟的过滤器链对象VirtualFilterChain，  并执行其doFilter方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">VirtualFilterChain</span> <span class="keyword">implements</span> <span class="title class_">FilterChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FilterChain originalChain;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Filter&gt; additionalFilters;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FirewalledRequest firewalledRequest;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentPosition</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">VirtualFilterChain</span><span class="params">(FirewalledRequest firewalledRequest,</span></span><br><span class="line"><span class="params">                               FilterChain chain, List&lt;Filter&gt; additionalFilters)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.originalChain = chain;</span><br><span class="line">        <span class="built_in">this</span>.additionalFilters = additionalFilters;</span><br><span class="line">        <span class="built_in">this</span>.size = additionalFilters.size();</span><br><span class="line">        <span class="built_in">this</span>.firewalledRequest = firewalledRequest;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentPosition == size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(UrlUtils.buildRequestUrl(firewalledRequest)</span><br><span class="line">                             + <span class="string">&quot; reached end of additional filter chain; proceeding with original chain&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.firewalledRequest.reset();</span><br><span class="line">            originalChain.doFilter(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            currentPosition++;</span><br><span class="line">            <span class="type">Filter</span> <span class="variable">nextFilter</span> <span class="operator">=</span> additionalFilters.get(currentPosition - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(UrlUtils.buildRequestUrl(firewalledRequest)</span><br><span class="line">                             + <span class="string">&quot; at position &quot;</span> + currentPosition + <span class="string">&quot; of &quot;</span> + size</span><br><span class="line">                             + <span class="string">&quot; in additional filter chain; firing Filter: &#x27;&quot;</span></span><br><span class="line">                             + nextFilter.getClass().getSimpleName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            nextFilter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VirtualFilterChain中首先声明了五个变量:</p><ul><li>originalChain：表示原生的过滤器链，执行它的doFilter方法会回到WebFilter中。</li><li>additionalFilters：这个List集合中存储的Filter就是本次请求的Filter。</li><li>firewalledRequest:当前请求对象。</li><li>size：过滤器链的大小。</li><li>currentPosition：过滤器链执行的下标。</li></ul><p>  在VirtualFilterChain的构造方法中，会给相应的变量赋值。</p><p>  在doFilter方法中，会首先判断当前执行的下标是否等于过滤器链的大小，如果相等，则说明整个过滤器链中的所有过滤器都已经挨个走一遍了，此时先对https防火墙中的属性进行重置，然后调用。originalChain.doFilter 方法跳出Spring Security Filter,回到 WebFilter；如果不相等，则currentPosition自增，然后从过滤器链集合中取出一个过滤器去执行，注意执行的时候第三个参数this表示当前对象(即VirtualFilterChain),这样在每一个过滤器执行完之后， 最后的chain.doFilter方法又会回到当前doFilter方法中，继续下一个过滤器的调用.</p><p>  这就是FilterChainProxy的一个大致工作原理。</p><h2 id="1-5-SecurityConfigurer"><a href="#1-5-SecurityConfigurer" class="headerlink" title="1.5 SecurityConfigurer"></a>1.5 SecurityConfigurer</h2><p>SecurityConfigurer中有两个核心方法，一个是init方法，用来完成配置类的初始化操作， 另外一个是configure方法，进行配置类的配置。上一小结介绍的 AbstractConfiguredSecurityBuilder类，里边的init方法和configure其实就是在遍历执行不同配 置类的init和configure方法。</p><p>  SecurityConfigurer的实现类比较多，这里主要梳理一下常见的SecurityConfigurer实现类, 我们分别来看一下。</p><p>  SecurityConfigurer：</p><p>  先来看源码,代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityConfigurer</span>&lt;O, B <span class="keyword">extends</span> <span class="title class_">SecurityBuilder</span>&lt;O&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(B builder)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(B builder)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，SecurityConfigurer只有两个方法：init和configure,两个方法的参数都是 SecurityBuilder对象，也就是说在这两个方法中对SecurityBuilder进行初始化和配置。</p><p>  SecurityConfigurer的类非常多，因为每一个过滤器都有自己对应的xxxConfigiuer,这 里着重介绍几个关键的实现类，如图4-4所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%EF%BC%888%EF%BC%89%EF%BC%884%EF%BC%89.png"></p><center>图 4-4</center><p>  我们分别来看这几个实现类：</p><p>  SecurityConfigurerAdapter</p><p>  SecurityConfigurerAdapter 实现了 SecurityConfigurer 接口，它的源码如下：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SecurityConfigurerAdapter</span>&lt;O, B <span class="keyword">extends</span> <span class="title class_">SecurityBuilder</span>&lt;O&gt;&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">SecurityConfigurer</span>&lt;O, B&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> B securityBuilder;</span><br><span class="line"><span class="keyword">private</span> <span class="type">CompositeObjectPostProcessor</span> <span class="variable">objectPostProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompositeObjectPostProcessor</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(B builder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(B builder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> B <span class="title function_">and</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getBuilder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> B <span class="title function_">getBuilder</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (securityBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;securityBuilder cannot be null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> securityBuilder;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">postProcess</span><span class="params">(T object)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (T) <span class="built_in">this</span>.objectPostProcessor.postProcess(object);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObjectPostProcessor</span><span class="params">(ObjectPostProcessor&lt;?&gt; objectPostProcessor)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.objectPostProcessor.addObjectPostProcessor(objectPostProcessor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuilder</span><span class="params">(B builder)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.securityBuilder = builder;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CompositeObjectPostProcessor</span> <span class="keyword">implements</span></span><br><span class="line"><span class="title class_">ObjectPostProcessor</span>&lt;Object&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;ObjectPostProcessor&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt;&gt; postProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ObjectPostProcessor&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcess</span><span class="params">(Object object)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (ObjectPostProcessor opp : postProcessors) &#123;</span><br><span class="line">Class&lt;?&gt; oppClass = opp.getClass();</span><br><span class="line">Class&lt;?&gt; oppType = GenericTypeResolver.resolveTypeArgument(oppClass,</span><br><span class="line">ObjectPostProcessor.class);</span><br><span class="line"><span class="keyword">if</span> (oppType == <span class="literal">null</span> || oppType.isAssignableFrom(object.getClass())) &#123;</span><br><span class="line">object = opp.postProcess(object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addObjectPostProcessor</span><span class="params">(</span></span><br><span class="line"><span class="params">ObjectPostProcessor&lt;? extends Object&gt; objectPostProcessor)</span> &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.postProcessors.add(objectPostProcessor);</span><br><span class="line">Collections.sort(postProcessors, AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   从这段源码中，我们可以分析出SecurityConfigurerAdapter主要做了如下几件事：</p><ul><li>提供了一个SecurityBuilder对象，为每一个配置类都提供一个SecurityBuilder对象, 将来通过SecurityBuilder构建出具体的配置对象；通过and方法返回SecurityBuilder对象，这样方便不同的配置类在配置时，可以进行链式配置(第2章中我们在定义SecurityConfig时所使用的and方法)。</li><li>定义了内部类CompositeObjectPostProcessor这是一个复合的对象后置处理器。</li><li>提供了一个addObjectPostProcessor方法，通过该方法可以向复合的对象后置处理器中添加新的ObjectPostProcessor实例。</li></ul><p>  这是SecurityConfigurerAdapter提供的主要功能。</p><p>  UserDetailsAwareConfigurer：</p><p>  UserDetailsAwareConfigurer的子类主要负责配置用户认证相关的组件，如UserDetailsService 等，UserDetailsAwareConfigurer 中提供了获取 UserDetailsService 的抽象方法，具体实现则在它的子类中，UserDetailsAwareConfigurer的子类如图4-5所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%EF%BC%888%EF%BC%89%EF%BC%885%EF%BC%89.png"></p><center>图 4-5</center><ul><li>AbstractDaoAuthenticationConfigurer： 完成时 DaoAuthenticationProvider 的配置。</li><li>UserDetailsServiceConfigurer:完成对 UserDetailsService 的配置。</li><li>UserDetailsManagerConfigurer :使用 UserDetailsManager 构建用户 对象，完成对 AuthenticationManagerBuilder 的填充。</li><li>JdbcUserDetailsManagerConfigurer：配置 JdbcUserDetailsManager 并填充到 AuthenticationManagerBuilder</li><li>InMemoryUserDetailsManagerConfigurer:配置 InMemoryUserDetailsManager。</li><li>DaoAuthenticationConfigurer: 完成对 DaoAuthenticationProvider 的配置。</li></ul><p>  AbstracthttpsConfigurer：</p><p>  AbstracthttpsConfigurer主要是为了给在httpsSecurity中使用的配置类添加一个方便的父类，提取岀共同的操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstracthttpsConfigurer</span>&lt;T <span class="keyword">extends</span> <span class="title class_">AbstracthttpsConfigurer</span>&lt;T, B&gt;, B <span class="keyword">extends</span> <span class="title class_">httpsSecurityBuilder</span>&lt;B&gt;&gt;</span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">SecurityConfigurerAdapter</span>&lt;DefaultSecurityFilterChain, B&gt; &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> B <span class="title function_">disable</span><span class="params">()</span> &#123;</span><br><span class="line">getBuilder().removeConfigurer(getClass());</span><br><span class="line"><span class="keyword">return</span> getBuilder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">withObjectPostProcessor</span><span class="params">(ObjectPostProcessor&lt;?&gt; objectPostProcessor)</span> &#123;</span><br><span class="line">addObjectPostProcessor(objectPostProcessor);</span><br><span class="line"><span class="keyword">return</span> (T) <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，提取出来的方法其实就两个：一个disable表示禁用某一个配置(前面章节中我们配置的.csrf().disable。),本质上就是从构建器的configurers集合中移除某一个配置类，这样在将来构建的时候就不存在该配置类，那么对应的功能也就不存在(被禁用)；另一个 withObjectPostProcessor表示给某一个对象添加一个对象后置处理器，由于该方法的返回值是当前对象，所以该方法可以用在链式配置中。</p><p>  AbstracthttpsConfigurer的实现类比较多，基本上都用来配置务种各样的过滤器，参见表 4-1。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%EF%BC%888%EF%BC%89%EF%BC%886%EF%BC%89.png"></p><p><img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%EF%BC%888%EF%BC%89%EF%BC%887%EF%BC%89.png"></p><center>表4-1</center><p>GlobalAuthenticationConfigurerAdapter：</p><p>GlobalAuthenticationConfigurerAdapter 主要用于配置全局 AuthenticationManagerBuilder, 在 AuthenticationConfiguration 类中会自动使用 GlobalAuthenticationConfigurerAdapter 提供的 Bean 来配置全局 AuthenticationManagerBuilder。</p><p>  在第3章介绍ProviderManager时曾经提到过，默认情况下ProviderManager有一个parent, 这个parent就是通过这里的全局AuthenticationManagerBuilder来构建的。</p><p>GlobalAuthenticationConfigurerAdapter 有四个不同的子类，如图 4-6 所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%E5%88%86%E6%9E%90-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%EF%BC%888%EF%BC%89%EF%BC%888%EF%BC%89.png"></p><center>图 4-6</center><ul><li>InitializeAuthenticationProviderBeanManagerConfigurer: 初始化全局的 AuthenticationProvider对象。</li><li>InitializeAuthenticationProviderManagerConfigurer:配置全局的 AuthenticationProvider对象，配置过程就是从Spring容器中查找 AuthenticationProvider并设置给全局的 AuthenticationManagerBuilder 对象。</li><li>InitializeUserDetailsBeanManagerConfigurer：初始化全局的 UserDetailsService 对象。</li><li>InitializeUserDetailsManagerConfigurer:配置全局的 UserDetailsService 对象，配置过程就是从 Spring 容器中查找 UserDetailsService,并设置给全局的 AuthenticationManagerBuilder 对象。</li><li>EnableGlobalAuthenticationAutowiredConfigurer：从 Spring 容器中加载被@EnableGlobalAuthentication注解标记的Bean。</li></ul><p>  WebSecurityConfigurer：</p><p>  WebSecurityConfigurer是一个空接口，我们可以通过它来自定义 WebSecurity。 WebSecurityConfigurer 只有一个实现类就是 WebSecurityConfigurerAdapter,在大多数情况下, 升发者通过继承WebSecurityConfigurerAdapter来实现对WebSecurity的自定义配置。</p><p>  WebSecurityConfigurerAdapter：</p><p>  WebSecurityConfigurerAdapter 是一个可以方便创建 WebSecurityConfigurer 实例的基类， 开发者可以通过覆盖 WebSecurityConfigurerAdapter中的方法完成对httpsSecurity和 WebSecurity的定制，在前面的章节中，我们所定制的Spring Security登录都是通过自定义类继承 WebSecurityConfigurerAdapter来实现的。</p><p>  在 WebSecurityConfiginerAdapter 中声明了 两个 AuthenticationManagerBuilder 对象用来构 建 AuthenticationManager：</p><p>  private AuthenticationManagerBuilder authenticationBuilder;</p><p>  private AuthenticationManagerBuilder localConfigureAuthenticationBuilder;</p><p>  其中，localConfigureAuthenticationBuilder对象负责构建全局的 AuthenticationManager,而 authenticationBuilder 则负责构建局部的 AutlienticationManager。 局部的 AuthenticationManager 是和每一个httpsSecurity对象绑定的，而全局的AuthenticationManager对象则是所有局部AuthenticationManager 的 parent。需要注意的足，localConfigureAuthenticationBuilder并非总是有用,在开发者没有重写configure(AuthenticationManagerBuilder)方法的情况下，全局的 AuthenticationManager 对象是由 Authenticationconfiguration 类中的 getAuthenticationManager 方法提供的，如果用户重写了 configure(AuthenticationManagerBuilder)方法，则全局的 AuthenticationManager 就由 localConfigureAuthenticationBuilder负责构建。这里可能会感觉有点绕，在后面的小节中，我们将通过实际的例子展示全局AuthenticationManager对象的构建。</p><p>  WebSecurityConfigurerAdapter 类的初始化方法如下：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="title function_">WebSecurityConfigurerAdapter</span><span class="params">(<span class="type">boolean</span> disableDefaults)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.logger = LogFactory.getLog(WebSecurityConfigurerAdapter.class);</span><br><span class="line">    <span class="built_in">this</span>.contentNegotiationStrategy = <span class="keyword">new</span> <span class="title class_">HeaderContentNegotiationStrategy</span>();</span><br><span class="line">    <span class="built_in">this</span>.objectPostProcessor = <span class="keyword">new</span> <span class="title class_">ObjectPostProcessor</span>&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">postProcess</span><span class="params">(T object)</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ObjectPostProcessor.class.getName() + <span class="string">&quot; is a required bean. Ensure you have used @EnableWebSecurity and @Configuration&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.trustResolver = <span class="keyword">new</span> <span class="title class_">AuthenticationTrustResolverImpl</span>();</span><br><span class="line">    <span class="built_in">this</span>.disableDefaults = disableDefaults;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="built_in">this</span>.disableLocalConfigureAuthenticationBldr = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> httpsSecurity <span class="title function_">gethttps</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.https != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.https;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">AuthenticationEventPublisher</span> <span class="variable">eventPublisher</span> <span class="operator">=</span> <span class="built_in">this</span>.getAuthenticationEventPublisher();</span><br><span class="line">        <span class="built_in">this</span>.localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);</span><br><span class="line">        <span class="type">AuthenticationManager</span> <span class="variable">authenticationManager</span> <span class="operator">=</span> <span class="built_in">this</span>.authenticationManager();</span><br><span class="line">        <span class="built_in">this</span>.authenticationBuilder.parentAuthenticationManager(authenticationManager);</span><br><span class="line">        Map&lt;Class&lt;?&gt;, Object&gt; sharedObjects = <span class="built_in">this</span>.createSharedObjects();</span><br><span class="line">        <span class="built_in">this</span>.https = <span class="keyword">new</span> <span class="title class_">httpsSecurity</span>(<span class="built_in">this</span>.objectPostProcessor, <span class="built_in">this</span>.authenticationBuilder, sharedObjects);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.disableDefaults) &#123;</span><br><span class="line">            ((httpsSecurity)((DefaultLoginPageConfigurer)((httpsSecurity)((httpsSecurity)((httpsSecurity)((httpsSecurity)((httpsSecurity)((httpsSecurity)((httpsSecurity)((httpsSecurity)<span class="built_in">this</span>.https.csrf().and()).addFilter(<span class="keyword">new</span> <span class="title class_">WebAsyncManagerIntegrationFilter</span>()).exceptionHandling().and()).headers().and()).sessionManagement().and()).securityContext().and()).requestCache().and()).anonymous().and()).servletApi().and()).apply(<span class="keyword">new</span> <span class="title class_">DefaultLoginPageConfigurer</span>())).and()).logout();</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="built_in">this</span>.context.getClassLoader();</span><br><span class="line">            List&lt;AbstracthttpsConfigurer&gt; defaulthttpsConfigurers = SpringFactoriesLoader.loadFactories(AbstracthttpsConfigurer.class, classLoader);</span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">var6</span> <span class="operator">=</span> defaulthttpsConfigurers.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                <span class="type">AbstracthttpsConfigurer</span> <span class="variable">configurer</span> <span class="operator">=</span> (AbstracthttpsConfigurer)var6.next();</span><br><span class="line">                <span class="built_in">this</span>.https.apply(configurer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.configure(<span class="built_in">this</span>.https);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.https;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebSecurityConfigurerAdapter</span>.AuthenticationManagerDelegator(<span class="built_in">this</span>.authenticationBuilder, <span class="built_in">this</span>.context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.authenticationManagerInitialized) &#123;</span><br><span class="line">        <span class="built_in">this</span>.configure(<span class="built_in">this</span>.localConfigureAuthenticationBldr);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.disableLocalConfigureAuthenticationBldr) &#123;</span><br><span class="line">            <span class="built_in">this</span>.authenticationManager = <span class="built_in">this</span>.authenticationConfiguration.getAuthenticationManager();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.authenticationManager = (AuthenticationManager)<span class="built_in">this</span>.localConfigureAuthenticationBldr.build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.authenticationManagerInitialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.authenticationManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">httpsSecurity</span> <span class="variable">https</span> <span class="operator">=</span> <span class="built_in">this</span>.gethttps();</span><br><span class="line">    web.addSecurityFilterChainBuilder(https).postBuildAction(() -&gt; &#123;</span><br><span class="line">        <span class="type">FilterSecurityInterceptor</span> <span class="variable">securityInterceptor</span> <span class="operator">=</span> (FilterSecurityInterceptor)https.getSharedObject(FilterSecurityInterceptor.class);</span><br><span class="line">        web.securityInterceptor(securityInterceptor);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Using default configure(httpsSecurity). If subclassed this will potentially override subclass configure(httpsSecurity).&quot;</span>);</span><br><span class="line">    ((httpsSecurity)((httpsSecurity)((AuthorizedUrl)https.authorizeRequests().anyRequest()).authenticated().and()).formLogin().and()).httpsBasic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在init方法中，首先调用gethttps方法获取一个httpsSecurity实例，并将获取到的实例添加到WebSecurity对象中，再由WebSecurity对象进行构建。</li><li>在gethttps方法中，如果https对象已经初始化，则直接返回，否则进行初始化操作。 在初始化的过程中，给localConfigureAuthenticationBuilder设置事件发布器，并调用 authenticationManager 方法获取全局的 AuthenticationManager 对象。</li><li>在 authenticationManager 方法中，如果全局的 AuthenticationManager 对象还没有初始化，则先调用configure方法，该方法的逻辑很简单，就是将disableLocalConfigureAuthenticationBIdr变量:由 false 变为 true,接下来就会进入到 authenticationManager 方法的 if 分支中，通 过调用 authenticationConfiguration.getAuthenticationManager()方法获取全局的 AuthenticationManager 对象并返回也如果开发者自己重写了 configure(AuthenticationManager Builder)方法，则 disableLocalConfigureAuthenticationBldr 变量就一直是 false,没有机会变为 true,这样就会进入到else分支中，通过localConfignreAuthenticationBldr变量来构建 authenticationManager 对象。</li><li>再次回到gethttps方法中，获取到全局的authenticationManager对象之后，设置给 autheuticationBuilder,然后创建一个httpsSecurity实例岀来，并为其配置上默认的过滤器。默认的配置完成后，调用configure(httpsSecurity)方法进行扩展配置，WebSecurityConfigurer Adapter中对configure(httpsSecurity)方法提供了默认的实现，开发者也可以自定义该方法。</li></ul><p>  这就是 WebSecurityConfigurerAdapter的初始化方法，其实就是创建并配置一个 httpsSecurity实例，之后添加到WebSecurity中。</p><p>  WebSecurityConfigurerAdapter中的configure方法是一个空方法，可以用来配置 WebSecurity,代码如下：</p><p>  public void configure(WebSecurity web) throws Exception {</p><p>  }</p><p>  一般来说，如果我们有一些静态资源不需要经过Spring Security过滤器，就可以通过重写该方法实现。</p><p>  至此，在Spring Security初始化过程中，几个重要的组件都介绍完了，单纯的源码读者看起来可能会比较枯燥，在后面的小节中，我会结合大量的应用案例，来帮助大家深入理解源码。</p><p>  不过在讲解具体的案例之前，我们还是先来分析一遍Sprmg Security的初始化流程，将前面讲的这些知识点串起来。</p><h2 id="1-6-初始化流程分析"><a href="#1-6-初始化流程分析" class="headerlink" title="1.6 初始化流程分析"></a>1.6 初始化流程分析</h2><p>在Spring Boot中使用Spring Security,初始化就从Spring Security的自动化配置类中开始:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DefaultAuthenticationEventPublisher.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(SecurityProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; SpringBootWebSecurityConfiguration.class, WebSecurityEnablerConfiguration.class,</span></span><br><span class="line"><span class="meta">SecurityDataConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(AuthenticationEventPublisher.class)</span></span><br><span class="line"><span class="keyword">public</span> DefaultAuthenticationEventPublisher <span class="title function_">authenticationEventPublisher</span><span class="params">(ApplicationEventPublisher publisher)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultAuthenticationEventPublisher</span>(publisher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，在自动化配置类SecurityAutoConfiguration中,最重要的就是导入了三个配置类，并且定义了一个默认的事件发布器。</p><p>  导入的三个配置类中，SpringBootWebSecurityConfiguration的主要作用是在开发者没有提 供 WebSecurityConfigurerAdapter实例的情况下，由其负责提供一个默认的 WebSecurity</p><p>  ConfigurerAdapter 实例，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(WebSecurityConfigurerAdapter.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(WebSecurityConfigurerAdapter.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootWebSecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Order(SecurityProperties.BASIC_AUTH_ORDER)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultConfigurerAdapter</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  另一个导入的配置类 SecurityDataConfiguration 主要提供了 一个 SecurityEvaluationcontextExtension实例，以便通过SpEL为经过身份验证的用户提供数据查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(SecurityEvaluationContextExtension.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityDataConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> SecurityEvaluationContextExtension <span class="title function_">securityEvaluationContextExtension</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecurityEvaluationContextExtension</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  最后一个导入的配置类WebSecurityEnablerConfigination则是我们分析的重点.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(WebSecurityConfigurerAdapter.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = BeanIds.SPRING_SECURITY_FILTER_CHAIN)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityEnablerConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  WebSecurityEnablerConfiguration 配置类中添加了 @EnableWebSecurity 注解，而该注解的 定义，引入了关键的配置类WebSecurityConfiguration。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value = &#123; java.lang.annotation.ElementType.TYPE &#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123; WebSecurityConfiguration.class,</span></span><br><span class="line"><span class="meta">SpringWebMvcImportSelector.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableGlobalAuthentication</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebSecurity &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Controls debugging support for Spring Security. Default is false.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> if true, enables debug support with Spring Security</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">debug</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，@EnableWebSecurity是一个组合注解，首先导入了三个配置类：</p><ul><li>WebSecurityConfiguration:用来配置 WebSecurity (重点分析)。</li><li>SpringWebMvcImportSelector:判断当前环境是否存在Spring MVC,如果存在,则引入相关配置。</li><li>OAuth2ImportSelector:判断当前环境是否存在OAuth2,如果存在，则引入相关配置</li></ul><p>另外还有一个@EnableGlobalAuthentication注解，用来开启全局配置，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value = &#123; java.lang.annotation.ElementType.TYPE &#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AuthenticationConfiguration.class)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableGlobalAuthentication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，@EnableGlobalAuthentication注解的主要功能是导入了配置类AuthenticationConfiguration。</p><p>  从上面的源码中我们可以看到，Spring Security的自动化配置类主要导入了两个类： WebSecurityConfiguration 和 AuthenticationConfiguration 接下来我们就来分析这两个类。</p><h3 id="1-6-1-WebSecurityConfiguration"><a href="#1-6-1-WebSecurityConfiguration" class="headerlink" title="1.6.1 WebSecurityConfiguration"></a>1.6.1 WebSecurityConfiguration</h3><p>  WebSecurityConfiguration配置类的功能，主要就是为了构建Spring Security过滤器链代理对象FilterChainProxy。根据前面的分析，FiIterChainProxy是由Web Security来构建的，所以 在WebSecurityConfiguration中会首先构建WebSecurity对象，再利用WebSecurity对象构建岀 FilterChainProxy。</p><p>  我们先来看一下WebSecurityConfiguration中定义的属性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> WebSecurity webSecurity;</span><br><span class="line"><span class="keyword">private</span> Boolean debugEnabled;</span><br><span class="line"><span class="keyword">private</span> List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers;</span><br><span class="line"><span class="keyword">private</span> ClassLoader beanClassLoader;</span><br><span class="line"><span class="meta">@Autowired(</span></span><br><span class="line"><span class="meta">    required = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">private</span> ObjectPostProcessor&lt;Object&gt; objectObjectPostProcessor;</span><br></pre></td></tr></table></figure><ul><li>WebSecurityConfiguration 类实现了 ImportAware 接口。ImportAware 接口一般是和 @Import注解一起使用，实现了 ImportAware接口的配置类可以方便地通过setlmportMetadata 方法获取到导入类中的数据配置。换句话说，WebSecurityConfignration实现了 ImportAware接口，使用@Iniport 注解在@EnableWebSecurity 上导入 WebSecurityConfigination 之后，在 WebSecurityConfigination 的 setlmportMetadata 方法中可以方便的获取到@EnableWebSecurity 注解中的属性值，这里主要是debug属性。另一方面，WebSecuityConfiguration类通过实现 BeanClassLoaderAware 接口可以方便地获取到 ClassLoader对象。</li><li>webSecurity 对象是 WebSecurityConfiguration 中需要构建的 WebSecurity 对象。</li><li>webSecurityConfigurers 集合中保存了所有的配置类，也就是 WebSecurityConfignrerAdapter 对象，一个 WebSecurityConfigurerAdapter 对象可以创建一个 httpsSecurity,进而构建出一条过滤器链，多个WebSecurityConfigurerAdapter对象就可以构建出多条过滤器链。</li><li>beanClassLoader 是一个 ClassLoader。</li><li>objectObjectPostProcessor是一个对象后置处理器，注意这个对象是直接从Spring容器中注入的。下一小节会分析对象后置姓理器是什么时候初始化并注册到Sptmg容器中去的，</li></ul><p>这是 WebSecurityConfiguration类中定义的属性。接下来，我们来看一下 setFilterChainProxySecurityConfigurer 方法，该方法主要用来构建一个 WebSecurity 对象，并且加载所有的配置类对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFilterChainProxySecurityConfigurer</span><span class="params">(ObjectPostProcessor&lt;Object&gt; objectPostProcessor, <span class="meta">@Value(&quot;#&#123;@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()&#125;&quot;)</span> List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="built_in">this</span>.webSecurity = (WebSecurity)objectPostProcessor.postProcess(<span class="keyword">new</span> <span class="title class_">WebSecurity</span>(objectPostProcessor));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.debugEnabled != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.webSecurity.debug(<span class="built_in">this</span>.debugEnabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    webSecurityConfigurers.sort(WebSecurityConfiguration.AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">previousOrder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">previousConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    Iterator var5;</span><br><span class="line">    SecurityConfigurer config;</span><br><span class="line">    <span class="keyword">for</span>(var5 = webSecurityConfigurers.iterator(); var5.hasNext(); previousConfig = config) &#123;</span><br><span class="line">        config = (SecurityConfigurer)var5.next();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">order</span> <span class="operator">=</span> WebSecurityConfiguration.AnnotationAwareOrderComparator.lookupOrder(config);</span><br><span class="line">        <span class="keyword">if</span> (previousOrder != <span class="literal">null</span> &amp;&amp; previousOrder.equals(order)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;@Order on WebSecurityConfigurers must be unique. Order of &quot;</span> + order + <span class="string">&quot; was already used on &quot;</span> + previousConfig + <span class="string">&quot;, so it cannot be used on &quot;</span> + config + <span class="string">&quot; too.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        previousOrder = order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var5 = webSecurityConfigurers.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">        config = (SecurityConfigurer)var5.next();</span><br><span class="line">        <span class="built_in">this</span>.webSecurity.apply(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.webSecurityConfigurers = webSecurityConfigurers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  setFilterChainProxySecurityConfigurer 方法有两个参数，第一个参数 objectPostProcessor 是一个对象后置处理器，由于该方法有一个@Autowired注解，会自动查找需要注入的参数，所以objectPostProcessor参数会自动注入进来。需要注意的是，@Autowired注解的required属性为false,所以在方法参数注入的时候，有就注入，没有则忽略。required属性设置为false主要是针对第二个参数webSecurityConfigurers ,因为该参数的值是通过调用 autowiredWebSecurityConfigurersIgnoreParents 对象的 getWebSecurityConfigurers 方法获取的。 autowiredWebSecurityConfigurersIgnoreParents 对象也是在当前类中注入到 Spring 容器中的，我们来看一下它的 getWebSecurityConfigurers 方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; <span class="title function_">getWebSecurityConfigurers</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    Map&lt;String, WebSecurityConfigurer&gt; beansOfType = <span class="built_in">this</span>.beanFactory.getBeansOfType(WebSecurityConfigurer.class);</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var3</span> <span class="operator">=</span> beansOfType.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, WebSecurityConfigurer&gt; entry = (Entry)var3.next();</span><br><span class="line">        webSecurityConfigurers.add(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> webSecurityConfigurers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，在 getWebSecurityConfigurers方法中主要是通过调用 beanFactory.getBeansOfType 方法来获取 Spring 容器中所有的 WebSecurityConfigurer 实例，也就是开发者自定义的各种各样继承自WebSecurityConfigurerAdapter的配置类。如果开发者没有自定义任何配置类，那么这里获取到的就是前面所讲的SprmgBootWebSecurityConfiguration 类中提供的默认配置类，将获取到的所有配置类实例放入webSecurityConfigurers集合中并返回。</p><p>  返回setFilterChainProxySecurityConfigurer方法中，现在我们已经明白了第二个参数 webSecurityConfigruers的含义了，在该方法中，首先创建一个WebSecurity实例，创建出来之后去对象后置处理器中走一圈，这样就将webSecurity对象注册到Spring容器中了。接下来， 根据每一个配置类的@Order注解对webSecurityConfigurers集合中的所有配置类进行排序，因 为一个配置类对应一个过滤器链，当请求到来后，需要先和哪个过滤器链进行匹配，这里必然存在一个优先级问题，所以如果开发者自定义了多个配置类，则需要通过@Order注解标记 多个配置类的优先级。排序完成后，进入到for循环中，检查是否存在优先级相等的配置类， 如果存在，则直接抛出异常。最后再去遍历所有的配置类，调用webSecurity.apply方法将其添加到webSecurity父类中的configurers集合中(将来遍历该集合并分别调用配置类的init和configure方法完成配置类的初始化操作)。</p><p>  这是setFiltetChainProxySecurityConfigurer方法的执行逻辑，该方法主要用来初始化 WebSecurity对象，同时收集到所有的自定义配置类。</p><p>  有了 WebSecurity对象和配置类，接下来就可以构建过滤器FilterChainProxy 了。我们来看一下 springSecurityFilterChain 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Filter <span class="title function_">springSecurityFilterChain</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasConfigurers</span> <span class="operator">=</span> <span class="built_in">this</span>.webSecurityConfigurers != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.webSecurityConfigurers.isEmpty();</span><br><span class="line">    <span class="keyword">if</span> (!hasConfigurers) &#123;</span><br><span class="line">        <span class="type">WebSecurityConfigurerAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> (WebSecurityConfigurerAdapter)<span class="built_in">this</span>.objectObjectPostProcessor.postProcess(<span class="keyword">new</span> <span class="title class_">WebSecurityConfigurerAdapter</span>() &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.webSecurity.apply(adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (Filter)<span class="built_in">this</span>.webSecurity.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里首先判断webSecurityConfigurers集合中是否存在配置类，如果不存在，则立马创建 一个匿名的 WebSecurityConfigurerAdapter对象并注册到Spring容器中，否则就直接调用 WebSecurity的build方法进行构建。</p><p>  根据前面小节的介绍，了解了 WebSecurity对象的build方法执行后，首先会对所有的配置类即 WebSecurityConfigurerAdapter 实例进行构建，在 WebSecurityConfigurerAdapter 的 init 方法中，又会完成httpsSecurity的构建，而httpsSecurity的构建过程中，则会完成局部 AuthenticationManager对象以及每一个具体的过滤器的构建。</p><p>  这就是整个过滤器链的构建流程。</p><h3 id="1-6-2-Authenticationconfiguration"><a href="#1-6-2-Authenticationconfiguration" class="headerlink" title="1.6.2 Authenticationconfiguration"></a>1.6.2 Authenticationconfiguration</h3><p>在Spring Security自动化配置类中导入的另外一个配置类是Authenticationconfiguration, 该类的功能主要是做全局的配置，同时提供-个全局的AuthenticationManager实例。首先我们来看 AuthenticationConfiguration 类的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Import(&#123;ObjectPostProcessorConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationConfiguration</span></span><br></pre></td></tr></table></figure><p>  可以看到，AuthenticationConfiguration 类的定义中，导入了ObjectPostProcessorConfiguration配置，而ObjectPostProcessorConfiguration配置则提供了一个基本的对象后置处理器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Role(2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectPostProcessorConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObjectPostProcessorConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Role(2)</span></span><br><span class="line">    <span class="keyword">public</span> ObjectPostProcessor&lt;Object&gt; <span class="title function_">objectPostProcessor</span><span class="params">(AutowireCapableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutowireBeanFactoryObjectPostProcessor</span>(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，ObjectPostProcessorConfiguration 类主要提供了一个 ObjectPostProcessor 实例， 具体的实现类是AutowireBeanFactoiyObjectPostProcessor,根据前面的介绍，该实现类主要用来将一个对象注册到Spring容器中去，我们在其他配置类中所见到的ObjectPostProcessor 实例其实都是这里提供的。</p><p>  这是 AuthenticationConfiguration 类的定义部分，AuthenticationConfigiuation 类中的方法比较多，我们挑选出关键的部分分析一下：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> AuthenticationManagerBuilder <span class="title function_">authenticationManagerBuilder</span><span class="params">(ObjectPostProcessor&lt;Object&gt; objectPostProcessor, ApplicationContext context)</span> &#123;</span><br><span class="line">    AuthenticationConfiguration.<span class="type">LazyPasswordEncoder</span> <span class="variable">defaultPasswordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthenticationConfiguration</span>.LazyPasswordEncoder(context);</span><br><span class="line">    <span class="type">AuthenticationEventPublisher</span> <span class="variable">authenticationEventPublisher</span> <span class="operator">=</span> (AuthenticationEventPublisher)getBeanOrNull(context, AuthenticationEventPublisher.class);</span><br><span class="line">    AuthenticationConfiguration.<span class="type">DefaultPasswordEncoderAuthenticationManagerBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthenticationConfiguration</span>.DefaultPasswordEncoderAuthenticationManagerBuilder(objectPostProcessor, defaultPasswordEncoder);</span><br><span class="line">    <span class="keyword">if</span> (authenticationEventPublisher != <span class="literal">null</span>) &#123;</span><br><span class="line">        result.authenticationEventPublisher(authenticationEventPublisher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> GlobalAuthenticationConfigurerAdapter <span class="title function_">enableGlobalAuthenticationAutowiredConfigurer</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthenticationConfiguration</span>.EnableGlobalAuthenticationAutowiredConfigurer(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InitializeUserDetailsBeanManagerConfigurer <span class="title function_">initializeUserDetailsBeanManagerConfigurer</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InitializeUserDetailsBeanManagerConfigurer</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InitializeAuthenticationProviderBeanManagerConfigurer <span class="title function_">initializeAuthenticationProviderBeanManagerConfigurer</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InitializeAuthenticationProviderBeanManagerConfigurer</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> AuthenticationManager <span class="title function_">getAuthenticationManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.authenticationManagerInitialized) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.authenticationManager;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">AuthenticationManagerBuilder</span> <span class="variable">authBuilder</span> <span class="operator">=</span> (AuthenticationManagerBuilder)<span class="built_in">this</span>.applicationContext.getBean(AuthenticationManagerBuilder.class);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.buildingAuthenticationManager.getAndSet(<span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthenticationConfiguration</span>.AuthenticationManagerDelegator(authBuilder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="built_in">this</span>.globalAuthConfigurers.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                <span class="type">GlobalAuthenticationConfigurerAdapter</span> <span class="variable">config</span> <span class="operator">=</span> (GlobalAuthenticationConfigurerAdapter)var2.next();</span><br><span class="line">                authBuilder.apply(config);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="built_in">this</span>.authenticationManager = (AuthenticationManager)authBuilder.build();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.authenticationManager == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.authenticationManager = <span class="built_in">this</span>.getAuthenticationManagerBean();</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="built_in">this</span>.authenticationManagerInitialized = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.authenticationManager;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 首先定义了一个AuthenticationManagerBuilder实例，目的是为了构建全局的 AuthenticationManager 对象，这个过程中会从 Spring 容器中査找 AuthenticationEventPublisher 实例设置给 AuthenticationManagerBuilder 对象。</p><ul><li>接下来构建了三个Bean,这三个Bean的作用在前面小节中已经介绍过了，这里就不再赘述了.</li><li>getAuthenticationManager 方法则用来构建具体的 AuthenticationManager 对象，在该方法内部，会首先判断AuthenticationManager对象是否已经初始化，如果已经初始化，则直接 返回 AuthenticationManager 对象，否则就先从 Spring 容器中获取到 AuthenticationManagerBuilder对象。注意这里还多了一个AuthenticationManagerDelegator对象，这个主要是为了防止在初始化AuthenticationManager时进行无限递归，拿到authBuilder对象之后，接下来遍历 globalAuthConfigurers配置类集合(也就是第二点中所说的三个配置类)，将配置类分别添加到authBuilder对象中，然后进行构建，最终将构建结果返回。</li></ul><p>这是全局AuthenticationManager的构建过程。</p><p>整体来说，AuthenticationConfiguration的作用主要体现在两方面：第一就是导入了 ObjectPostProcessorConfiguration 配置类；第二则是提供 了一个全局的 AuthenticationManager 对象。</p><p>如果升发者在自定义配置类中重写了 configure(AuthenticationManagerBuilder)方法，这里的全局AuthenticationManager对象将不会生效，而大部分情况下，开发者都会重写 configure(AuthenticationManagerBuilder)方法。</p><p>至此，Spring Security初始化就讲解完了。然而这里的架构复杂，概念繁多，可能有读者看完之后还是理解不到位，因此，接下来我们将通过几个不同的案例，展示前面这些组件的不同用法，加深大家对Spring Security基础组件的理解。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security配置多个数据源并添加登录验证码（7）</title>
      <link href="/2022/08/04/Spring%20Security%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90%E5%B9%B6%E6%B7%BB%E5%8A%A0%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%887%EF%BC%89/"/>
      <url>/2022/08/04/Spring%20Security%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90%E5%B9%B6%E6%B7%BB%E5%8A%A0%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%887%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-配置多个数据源"><a href="#1-配置多个数据源" class="headerlink" title="1.配置多个数据源"></a>1.配置多个数据源</h1><p>  多个数据源是指在同一个系统中，用户数据来自不同的表，在认证时，如果第一张表没有查找到用户，那就去第二张表中査询，依次类推。</p><p>  看了前面的分析，要实现这个需求就很容易了，认证要经过AuthenticationProvider,每一 个 AuthenticationProvider 中都配置了一个 UserDetailsService,而不同的 UserDetailsService 则可以代表不同的数据源，所以我们只需要手动配置多个AuthenticationProvider,并为不同的 AuthenticationProvider 提供不同的 UserDetailsService 即可。</p><p>  为了方便起见，这里通过 InMemoryUserDetailsManager 来提供 UserDetailsService 实例， 在实际开发中，只需要将UserDetailsService换成自定义的即可，具体配置如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    UserDetailsService <span class="title function_">us1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(User.builder().username(<span class="string">&quot;testuser1&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123&quot;</span>)</span><br><span class="line">                .roles(<span class="string">&quot;admin&quot;</span>).build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    UserDetailsService <span class="title function_">us2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(User.builder().username(<span class="string">&quot;testuser2&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123&quot;</span>)</span><br><span class="line">                .roles(<span class="string">&quot;user&quot;</span>).build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DaoAuthenticationProvider</span> <span class="variable">dao1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DaoAuthenticationProvider</span>();</span><br><span class="line">        dao1.setUserDetailsService(us1());</span><br><span class="line">        <span class="type">DaoAuthenticationProvider</span> <span class="variable">dao2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DaoAuthenticationProvider</span>();</span><br><span class="line">        dao2.setUserDetailsService(us2());</span><br><span class="line">        <span class="type">ProviderManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProviderManager</span>(dao1, dao2);</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  首先定义了两个UserDetailsService实例，不同实例中存储了不同的用户；然后重写 authenticationManagerBean 方法，在该方法中，定义了两个 DaoAuthenticationProvider 实例并分别设置了不同的UserDetailsService ；最后构建ProviderManager实例并传入两个 DaoAuthenticationProvider，当系统进行身份认证操作时，就会遍历ProviderManager中不同的 DaoAuthenticationProvider,进而调用到不同的数据源。</p><h1 id="2-添加登录验证码"><a href="#2-添加登录验证码" class="headerlink" title="2. 添加登录验证码"></a>2. 添加登录验证码</h1><p>登录验证码也是项目中一个常见的需求，但是Spring Security对此并未提供自动化配置方案，需要开发者自行定义，一般来说，有两种实现登录验证码的思路：</p><ul><li>自定义过滤器。</li><li>自定义认证逻辑。</li></ul><p>通过自定义过滤器来实现登录验证码，这种方案我们会在后面的过滤器中介绍, 这里先来看如何通过自定义认证逻辑实现添加登录验证码功能。</p><p>生成验证码，可以自定义一个生成工具类，也可以使用一些现成的开源库来实现，这里 采用开源库kaptcha,首先引入kaptcha依赖，代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.penggle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kaptcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后对kaptcha进行配置:</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.code.kaptcha.Producer;</span><br><span class="line"><span class="keyword">import</span> com.google.code.kaptcha.impl.DefaultKaptcha;</span><br><span class="line"><span class="keyword">import</span> com.google.code.kaptcha.util.Config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KaptchaConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Producer <span class="title function_">kaptcha</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.width&quot;</span>, <span class="string">&quot;150&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.height&quot;</span>, <span class="string">&quot;50&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.char.string&quot;</span>, <span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.char.length&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>(properties);</span><br><span class="line">        <span class="type">DefaultKaptcha</span> <span class="variable">defaultKaptcha</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultKaptcha</span>();</span><br><span class="line">        defaultKaptcha.setConfig(config);</span><br><span class="line">        <span class="keyword">return</span> defaultKaptcha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  配置一个Producer实例，主要配置一下生成的图片验证码的宽度、长度、生成字符、验证码的长度等信息，配置完成后，我们就可以在Controller中定义一个验证码接口了。</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.code.kaptcha.Producer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.https.httpsServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.https.httpsSession;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Producer producer;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/vc.jpg&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getVerifyCode</span><span class="params">(httpsServletResponse resp, httpsSession session)</span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> producer.createText();</span><br><span class="line">        session.setAttribute(<span class="string">&quot;kaptcha&quot;</span>,text);</span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> producer.createImage(text);</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> resp.getOutputStream()) &#123;</span><br><span class="line">            ImageIO.write(image,<span class="string">&quot;jpg&quot;</span>,out);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个验证码接口中，我们主要做了两件事：</p><ul><li>生成验证码文本，并将文本存入httpsSession中。</li><li>根据验证码文本生成验证码图片，并通过IO流写出到前端。</li></ul><p>接下来修改登录表单，加入验证码，代码如下:</p><p>查看代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;https://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bootstrap-css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#login</span> <span class="selector-class">.container</span> <span class="selector-id">#login-row</span> <span class="selector-id">#login-column</span> <span class="selector-id">#login-box</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#9c9c9c</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#EAEAEA</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-row&quot;</span> <span class="attr">class</span>=<span class="string">&quot;row justify-content-center align-items-center&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-column&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-6&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-box&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-12&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;login-form&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/doLogin&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;text-center text-info&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--/*@thymesVar id=&quot;SPRING_SECURITY_LAST_EXCEPTION&quot; type=&quot;com&quot;*/--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;SPRING_SECURITY_LAST_EXCEPTION&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-info&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uname&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-info&quot;</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;kaptcha&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-info&quot;</span>&gt;</span>验证码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;kaptcha&quot;</span> <span class="attr">id</span>=<span class="string">&quot;kaptcha&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/vc.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-info btn-md&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  登录表单中增加一个验证码输入框，验证码的图片地址就是我们在Controller中定义的验证码接口地址。</p><p>  接下来就是验证码的校验了。经过前面的介绍，读者已经了解到，身份认证实际上就是在AuthenticationProvider.authenticate方法中完成的。所以，验证码的校验，我们可以在该方法执行之前进行，需要配置如下类：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationServiceException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.dao.DaoAuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.https.httpsServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KaptchaAuthenticationProvider</span> <span class="keyword">extends</span> <span class="title class_">DaoAuthenticationProvider</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="type">httpsServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">kaptcha</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;kaptcha&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">serssionKaptcha</span> <span class="operator">=</span> (String) req.getSession().getAttribute(<span class="string">&quot;kaptcha&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (kaptcha != <span class="literal">null</span> &amp;&amp; serssionKaptcha != <span class="literal">null</span> &amp;&amp; kaptcha.equalsIgnoreCase(serssionKaptcha))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.authenticate(authentication);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationServiceException</span>(<span class="string">&quot;验证码输入错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里重写authenticate方法，在authenticate方法中，从RequestContextHolder中获取当前请求，进而获取到验证码参数和存储在httpsSession中的验证码文本进行比较，比较通过则继续执行父类的authenticate方法，比较不通过，就抛出异常。</p><p>  你可能会想到通过重写 DaoAuthenticationProvider类的 additionalAuthenticationChecks 方法来完成验证码的校验，这个从技术上来说是没有问题的，但是这会让验证码失去存在的意义，因为当additionalAuthenticationChecks方法被调用时，数据库查询已经做了，仅仅剩下密码没有校验，此时，通过验证码来拦截恶意登录的功能就已经失效了。</p><p>  最后，在 SecurityConfig 中配置 AuthenticationManager,代码如下:</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.Service.MyUserDetailsService;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.handler.MyAuthenticationFailureHandler;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.provider.KaptchaAuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.ProviderManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.httpsSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.util.matcher.AntPathRequestMatcher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.util.matcher.OrRequestMatcher;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailsService myUserDetailsService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/vc.jpg&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/index.html&quot;</span>)</span><br><span class="line">                .failureHandler(<span class="keyword">new</span> <span class="title class_">MyAuthenticationFailureHandler</span>())</span><br><span class="line">                .usernameParameter(<span class="string">&quot;uname&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                .logoutRequestMatcher(<span class="keyword">new</span> <span class="title class_">OrRequestMatcher</span>(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout1&quot;</span>,<span class="string">&quot;GET&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout2&quot;</span>,<span class="string">&quot;POST&quot;</span>)))</span><br><span class="line">                .invalidatehttpsSession(<span class="literal">true</span>)</span><br><span class="line">                .clearAuthentication(<span class="literal">true</span>)</span><br><span class="line">                .defaultLogoutSuccessHandlerFor((req,resp,auth)-&gt;&#123;</span><br><span class="line">                    resp.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">                    Map&lt;String,Object&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">                    result.put(<span class="string">&quot;status&quot;</span>,<span class="number">200</span>);</span><br><span class="line">                    result.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;使用logout1注销成功！&quot;</span>);</span><br><span class="line">                    <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> om.writeValueAsString(result);</span><br><span class="line">                    resp.getWriter().write(s);</span><br><span class="line">                &#125;,<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout1&quot;</span>,<span class="string">&quot;GET&quot;</span>))</span><br><span class="line">                .defaultLogoutSuccessHandlerFor((req,resp,auth)-&gt;&#123;</span><br><span class="line">                    resp.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">                    Map&lt;String,Object&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">                    result.put(<span class="string">&quot;status&quot;</span>,<span class="number">200</span>);</span><br><span class="line">                    result.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;使用logout2注销成功！&quot;</span>);</span><br><span class="line">                    <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> om.writeValueAsString(result);</span><br><span class="line">                    resp.getWriter().write(s);</span><br><span class="line">                &#125;,<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout1&quot;</span>,<span class="string">&quot;GET&quot;</span>))</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    AuthenticationProvider <span class="title function_">kaptchaAuthenticationProvider</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">KaptchaAuthenticationProvider</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KaptchaAuthenticationProvider</span>();</span><br><span class="line">        provider.setUserDetailsService(myUserDetailsService);</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ProviderManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProviderManager</span>(kaptchaAuthenticationProvider());</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里配置分三步：首先配置UserDetailsService提供数据源；然后提供一个 AuthenticationProvider 实例并配置 UserDetailsService；最后重写 authenticationManagerBean 方 法_，_提供一个自己的PioviderManager并使用自定义的AuthenticationProvider实例。</p><p>  另外需要注意，在configure(httpsSecurity)方法中给验证码接口配置放行，permitAll表示这个接口不需要登录就可以访问。</p><p>  配置完成后，启动项目，浏览器中输入任意地址都会跳转到登录页面，如图3-5所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90%E5%B9%B6%E6%B7%BB%E5%8A%A0%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%887%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><center>图 3-5</center><p>此时，输入用户名、密码以及验证码就可以成功登录。如果验证码输入错误，则登录页面会自动展示错误信息，如下：</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90%E5%B9%B6%E6%B7%BB%E5%8A%A0%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%887%EF%BC%89%EF%BC%882%EF%BC%89.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security认证流程分析（6）</title>
      <link href="/2022/08/04/Spring%20Security%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%886%EF%BC%89/"/>
      <url>/2022/08/04/Spring%20Security%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%886%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-认证流程分析"><a href="#1-认证流程分析" class="headerlink" title="1.认证流程分析"></a>1.认证流程分析</h1><p>  Spring Security中默认的一套登录流程是非常完善并且严谨的。但是项目需求非常多样化, 很多时候，我们可能还需要对Spring Secinity登录流程进行定制，定制的前提是开发者先深刻理解Spring Security登录流程，然后在此基础之上，完成对登录流程的定制。本文将从头梳理 Spring Security登录流程，并通过几个常见的登录定制案例，深刻地理解Spring Security登录流程。</p><p>  本章涉及的主要知识点有：</p><ul><li>登录流程分析。</li><li>配置多个数据源。</li><li>添加登录验证码。</li></ul><h2 id="1-1登录流程分析"><a href="#1-1登录流程分析" class="headerlink" title="1.1登录流程分析"></a>1.1登录流程分析</h2><p>要搞清楚Spring Security认证流程，我们得先认识与之相关的三个基本组件（Authentication 对象在前面文章种己经做过介绍，这里不再赘述）:AuthenticationManager、ProviderManager以及AuthenticationProvider,同时还要去了解接入认证功能的过滤器 AbstractAuthenticationProcessingFilter,这四个类搞明白了，基本上认证流程也就清楚了，下面我们逐个分析一下。</p><h3 id="1-1-1-AuthenticationManager"><a href="#1-1-1-AuthenticationManager" class="headerlink" title="1.1.1 AuthenticationManager"></a>1.1.1 AuthenticationManager</h3><p>从名称上可以看出，AuthenticationManager是一个认证管理器，它定义了 Spring Security 过滤器要如何执行认证操作。AuthenticationManager在认证成功后，会返回一个Authentication对象，这个Authentication对象会被设置到SecurityContextHolder中。如果开发者不想用Spring Security提供的一套认证机制，那么也可以自定义认证流程，认证成功后，手动将Authentication 存入 SecurityContextHolder 中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationManager</span> &#123;</span><br><span class="line">    Authentication <span class="title function_">authenticate</span><span class="params">(Authentication var1)</span> <span class="keyword">throws</span> AuthenticationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从 AuthenticationManager 的源码中可以看到，AuthenticationManager 对传入的 Authentication对象进行身份认证，此时传入的Authentication参数只有用户名&#x2F;密码等简单的属性，如果认证成功，返回的Authentication的属性会得到完全填充，包括用户所具备的角色信息。AuthenticationManager是一个接口，它有着诸多的实现类，开发者也可以自定义 AuthenticationManager的实现类，不过在实际应用中，我们使用最多的是ProviderManager，在 Spring S ecurity 框架中，默认也是使用 ProviderManager。</p><h3 id="1-1-2-AuthenticationProvider"><a href="#1-1-2-AuthenticationProvider" class="headerlink" title="1.1.2 AuthenticationProvider"></a>1.1.2 AuthenticationProvider</h3><p>Spring Security支持多种不同的认证方式，不同的认证方式对应不同的身份 类型，AuthenticationProvider就是针对不同的身份类型执行具体的身份认证。例如，常见的 DaoAuthenticationProvider 用来支持用户名&#x2F;密码登录认证，RememberMeAuthenticationProvider 用来支持“记住我”的认证。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line">    Authentication <span class="title function_">authenticate</span><span class="params">(Authentication var1)</span> <span class="keyword">throws</span> AuthenticationException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>authenticate方法用来执行具体的身份忧证。</li><li>supports方法用来判断当前AuthenticationProvider是否支持对应的身份类型。</li></ul><p>  当使用用户名&#x2F;密码的方式登录时，对应的AuthenticationProvider实现类是 DaoAuthenticationProvider , 而 DaoAuthenticationProvider 继承自 AbstractUserDetailsAuthenticationProvider并且没有重写authenticate方法，所以具体的认证逻辑在AbstractUserDetailsAuthenticationProvider 的 authenticate 方法中。我们就从 AbstractUserDetailsAuthenticationProvider开始看起：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractUserDetailsAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationProvider</span>, InitializingBean, MessageSourceAware &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(<span class="built_in">this</span>.getClass());</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">MessageSourceAccessor</span> <span class="variable">messages</span> <span class="operator">=</span> SpringSecurityMessageSource.getAccessor();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserCache</span> <span class="variable">userCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullUserCache</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">forcePrincipalAsString</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="variable">hideUserNotFoundExceptions</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDetailsChecker</span> <span class="variable">preAuthenticationChecks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractUserDetailsAuthenticationProvider</span>.DefaultPreAuthenticationChecks();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDetailsChecker</span> <span class="variable">postAuthenticationChecks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbstractUserDetailsAuthenticationProvider</span>.DefaultPostAuthenticationChecks();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">GrantedAuthoritiesMapper</span> <span class="variable">authoritiesMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullAuthoritiesMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractUserDetailsAuthenticationProvider</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">additionalAuthenticationChecks</span><span class="params">(UserDetails var1, UsernamePasswordAuthenticationToken var2)</span> <span class="keyword">throws</span> AuthenticationException;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Assert.notNull(<span class="built_in">this</span>.userCache, <span class="string">&quot;A user cache must be set&quot;</span>);</span><br><span class="line">        Assert.notNull(<span class="built_in">this</span>.messages, <span class="string">&quot;A message source must be set&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.doAfterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;</span>, <span class="string">&quot;Only UsernamePasswordAuthenticationToken is supported&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authentication.getPrincipal() == <span class="literal">null</span> ? <span class="string">&quot;NONE_PROVIDED&quot;</span> : authentication.getName();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">cacheWasUsed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.userCache.getUserFromCache(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            cacheWasUsed = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                user = <span class="built_in">this</span>.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UsernameNotFoundException var6) &#123;</span><br><span class="line">                <span class="built_in">this</span>.logger.debug(<span class="string">&quot;User &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; not found&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.hideUserNotFoundExceptions) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>, <span class="string">&quot;Bad credentials&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">throw</span> var6;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            Assert.notNull(user, <span class="string">&quot;retrieveUser returned null - a violation of the interface contract&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.preAuthenticationChecks.check(user);</span><br><span class="line">            <span class="built_in">this</span>.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException var7) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line">                <span class="keyword">throw</span> var7;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            cacheWasUsed = <span class="literal">false</span>;</span><br><span class="line">            user = <span class="built_in">this</span>.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">            <span class="built_in">this</span>.preAuthenticationChecks.check(user);</span><br><span class="line">            <span class="built_in">this</span>.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">this</span>.postAuthenticationChecks.check(user);</span><br><span class="line">        <span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line">            <span class="built_in">this</span>.userCache.putUserInCache(user);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="type">Object</span> <span class="variable">principalToReturn</span> <span class="operator">=</span> user;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.forcePrincipalAsString) &#123;</span><br><span class="line">            principalToReturn = user.getUsername();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Authentication <span class="title function_">createSuccessAuthentication</span><span class="params">(Object principal, Authentication authentication, UserDetails user)</span> &#123;</span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(principal, authentication.getCredentials(), <span class="built_in">this</span>.authoritiesMapper.mapAuthorities(user.getAuthorities()));</span><br><span class="line">        result.setDetails(authentication.getDetails());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doAfterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> UserCache <span class="title function_">getUserCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userCache;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isForcePrincipalAsString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.forcePrincipalAsString;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHideUserNotFoundExceptions</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.hideUserNotFoundExceptions;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> UserDetails <span class="title function_">retrieveUser</span><span class="params">(String var1, UsernamePasswordAuthenticationToken var2)</span> <span class="keyword">throws</span> AuthenticationException;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setForcePrincipalAsString</span><span class="params">(<span class="type">boolean</span> forcePrincipalAsString)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.forcePrincipalAsString = forcePrincipalAsString;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHideUserNotFoundExceptions</span><span class="params">(<span class="type">boolean</span> hideUserNotFoundExceptions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hideUserNotFoundExceptions = hideUserNotFoundExceptions;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessageSource</span><span class="params">(MessageSource messageSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messages = <span class="keyword">new</span> <span class="title class_">MessageSourceAccessor</span>(messageSource);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserCache</span><span class="params">(UserCache userCache)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userCache = userCache;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> UserDetailsChecker <span class="title function_">getPreAuthenticationChecks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.preAuthenticationChecks;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPreAuthenticationChecks</span><span class="params">(UserDetailsChecker preAuthenticationChecks)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preAuthenticationChecks = preAuthenticationChecks;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> UserDetailsChecker <span class="title function_">getPostAuthenticationChecks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.postAuthenticationChecks;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPostAuthenticationChecks</span><span class="params">(UserDetailsChecker postAuthenticationChecks)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.postAuthenticationChecks = postAuthenticationChecks;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthoritiesMapper</span><span class="params">(GrantedAuthoritiesMapper authoritiesMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.authoritiesMapper = authoritiesMapper;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DefaultPostAuthenticationChecks</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsChecker</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">DefaultPostAuthenticationChecks</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(UserDetails user)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!user.isCredentialsNonExpired()) &#123;</span><br><span class="line">                AbstractUserDetailsAuthenticationProvider.<span class="built_in">this</span>.logger.debug(<span class="string">&quot;User account credentials have expired&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CredentialsExpiredException</span>(AbstractUserDetailsAuthenticationProvider.<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.credentialsExpired&quot;</span>, <span class="string">&quot;User credentials have expired&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DefaultPreAuthenticationChecks</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsChecker</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">DefaultPreAuthenticationChecks</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(UserDetails user)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!user.isAccountNonLocked()) &#123;</span><br><span class="line">                AbstractUserDetailsAuthenticationProvider.<span class="built_in">this</span>.logger.debug(<span class="string">&quot;User account is locked&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LockedException</span>(AbstractUserDetailsAuthenticationProvider.<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.locked&quot;</span>, <span class="string">&quot;User account is locked&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!user.isEnabled()) &#123;</span><br><span class="line">                AbstractUserDetailsAuthenticationProvider.<span class="built_in">this</span>.logger.debug(<span class="string">&quot;User account is disabled&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DisabledException</span>(AbstractUserDetailsAuthenticationProvider.<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.disabled&quot;</span>, <span class="string">&quot;User is disabled&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!user.isAccountNonExpired()) &#123;</span><br><span class="line">                AbstractUserDetailsAuthenticationProvider.<span class="built_in">this</span>.logger.debug(<span class="string">&quot;User account is expired&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccountExpiredException</span>(AbstractUserDetailsAuthenticationProvider.<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.expired&quot;</span>, <span class="string">&quot;User account has expired&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一开始先声明一个用户缓存对象userCache,默认情况下没有启用缓存对象。</li><li>hideUserNotFoundExceptions表示是否隐藏用户名查找失败的异常，默认为true，为了确保系统安全，用户在登录失败时只会给出一个模糊提示，例如“用户名或密码输入错误“ 在Spring Security内部，如果用户名查找失败,则会抛出UsernameNotFoundException异常， 但是该异常会被自动隐藏，转而通过一个BadCredentialsException异常来代替它，这样，开发者在处理登录失败异常时，无论是用户名输入错误还是密码输入错误，收到的总是 BadCredentialsException，这样做的一个好处是可以避免新手程序员将用户名输入错误和密码输入错误两个异常分开提示。</li><li>forcePrincipalAsString表示是否强制将Principal对象当成字符串来处理，默认是falser，Authentication中的Principal属性类型是一个Object，正常来说，通过Principal属性可以获取到当前登录用户对象(即UserDetails)，但是如果forcePrincipalAsString设置为true，则 Authentication中的Principal属性返回就是当前登录用户名，而不是用户对象。</li><li>preAuthenticationChecks对象则是用于做用户状态检査，在用户认证过程中，需要检验用户状态是否正常，例如账户是否被锁定、账户是否可用、账户是否过期等。</li><li>postAuthenticationChecks对象主要负责在密码校验成功后，检査密码是否过期。</li><li>additionalAuthenticationChecks是一个抽象方法，主要就是校验密码，具体的实现在 DaoAuthenticationProvider 中。</li><li>authenticate方法就是核心的校验方法了。在方法中，首先从登录数据中获取用户名， 然后根据用户名去缓存中查询用户对象，如果査询不到，则根据用户名调用retrieveUser方法从数据库中加载用户；如果没有加载到用户，则抛出异常(用户不存在异常会被隐藏)。拿到用户对象之后，首先调用check方法进行用户状态检査，然后调用 additionalAuthenticationChecks 方法进行密码的校验操作，最后调用 postAuthenticationChecks.check方法检査密码是否过期，当所有步骤都顺利完成后，调用createSuccessAuthentication 方法创建一个认证后的 UsernamePasswordAuthenticationToken 对象并返回，认证后的对象中包含了认证主体、凭证以及角色等信息。</li></ul><p>  这就是 AbstractUserDetailsAuthenticationProvider类的工作流程，有几个抽象方法是在 DaoAuthenticationProvider 中实现的，我们再来看一下 DaoAuthenticationProvider中的定义：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoAuthenticationProvider</span> <span class="keyword">extends</span> <span class="title class_">AbstractUserDetailsAuthenticationProvider</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER_NOT_FOUND_PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;userNotFoundPassword&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String userNotFoundEncodedPassword;</span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">    <span class="keyword">private</span> UserDetailsPasswordService userDetailsPasswordService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DaoAuthenticationProvider</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setPasswordEncoder(PasswordEncoderFactories.createDelegatingPasswordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="keyword">if</span> (authentication.getCredentials() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Authentication failed: no credentials provided&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>, <span class="string">&quot;Bad credentials&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">presentedPassword</span> <span class="operator">=</span> authentication.getCredentials().toString();</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line">                <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Authentication failed: password does not match stored value&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>, <span class="string">&quot;Bad credentials&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doAfterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        Assert.notNull(<span class="built_in">this</span>.userDetailsService, <span class="string">&quot;A UserDetailsService must be set&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title function_">retrieveUser</span><span class="params">(String username, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="built_in">this</span>.prepareTimingAttackProtection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">loadedUser</span> <span class="operator">=</span> <span class="built_in">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">            <span class="keyword">if</span> (loadedUser == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalAuthenticationServiceException</span>(<span class="string">&quot;UserDetailsService returned null, which is an interface contract violation&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> loadedUser;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UsernameNotFoundException var4) &#123;</span><br><span class="line">            <span class="built_in">this</span>.mitigateAgainstTimingAttack(authentication);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InternalAuthenticationServiceException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalAuthenticationServiceException</span>(var6.getMessage(), var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Authentication <span class="title function_">createSuccessAuthentication</span><span class="params">(Object principal, Authentication authentication, UserDetails user)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">upgradeEncoding</span> <span class="operator">=</span> <span class="built_in">this</span>.userDetailsPasswordService != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.passwordEncoder.upgradeEncoding(user.getPassword());</span><br><span class="line">        <span class="keyword">if</span> (upgradeEncoding) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">presentedPassword</span> <span class="operator">=</span> authentication.getCredentials().toString();</span><br><span class="line">            <span class="type">String</span> <span class="variable">newPassword</span> <span class="operator">=</span> <span class="built_in">this</span>.passwordEncoder.encode(presentedPassword);</span><br><span class="line">            user = <span class="built_in">this</span>.userDetailsPasswordService.updatePassword(user, newPassword);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.createSuccessAuthentication(principal, authentication, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareTimingAttackProtection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.userNotFoundEncodedPassword == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.userNotFoundEncodedPassword = <span class="built_in">this</span>.passwordEncoder.encode(<span class="string">&quot;userNotFoundPassword&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mitigateAgainstTimingAttack</span><span class="params">(UsernamePasswordAuthenticationToken authentication)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (authentication.getCredentials() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">presentedPassword</span> <span class="operator">=</span> authentication.getCredentials().toString();</span><br><span class="line">            <span class="built_in">this</span>.passwordEncoder.matches(presentedPassword, <span class="built_in">this</span>.userNotFoundEncodedPassword);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPasswordEncoder</span><span class="params">(PasswordEncoder passwordEncoder)</span> &#123;</span><br><span class="line">        Assert.notNull(passwordEncoder, <span class="string">&quot;passwordEncoder cannot be null&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.passwordEncoder = passwordEncoder;</span><br><span class="line">        <span class="built_in">this</span>.userNotFoundEncodedPassword = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> PasswordEncoder <span class="title function_">getPasswordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.passwordEncoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDetailsService</span><span class="params">(UserDetailsService userDetailsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDetailsService = userDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> UserDetailsService <span class="title function_">getUserDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDetailsPasswordService</span><span class="params">(UserDetailsPasswordService userDetailsPasswordService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDetailsPasswordService = userDetailsPasswordService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先定义了 USER_NOT_FOUND_PASSWORD常量，这个是当用户查找失败时的默认密码；passwordEncoder是一个密码加密和比对工具，这个在后面会有专门的介绍，这里先不做过多解释；userNotFoundEncodedPassword变量则用来保存默认密码加密后的值； userDetailsService是一个用户查找工具，userDetailsService在前面己经讲过，这里不再赘述； userDetailsPasswordService则用来提供密码修改服务。</p></li><li><p>在DaoAuthenticationProvider的构造方法中，默认就会指定PasswordEncoder,当然开发者也可以通过set方法自定义PasswordEncoder。</p></li><li><p>additionalAuthenticationchecks方法主要进行密码校验，该方法第一个参数userDetails 是从数据库中查询出来的用户对象，第二个参数authentication则是登录用户输入的参数。从这两个参数中分别提取出来用户密码，然后调用passwordEncoder.matches方法进行密码比对。</p></li><li><p>retrieveUser方法则是获取用户对象的方法，具体做法就是调用 UserDetailsService#loadUserByUsername 方法去数据库中查询。</p></li><li><p>在retrieveUser方法中，有一个值得关注的地方。在该方法一开始，首先会调用 prepareTimingAttackProtection 方法，该方法的作用是使用 PasswordEncoder 对常量 USER_NOT_FOUND_PASSWORD 进行加密，将加密结果保存在 userNotFoundEncodedPassword变量中。当根据用户名查找用户时_，_如果抛出了 UsernameNotFoundException异常， 则调用mitigateAgainstTimingAttack方法进行密码比对由有读者会说，用户都没查找到，怎么 比对密码？需要注意，在调用mitigateAgainstTimingAttack方法进行密码比对时，使用了 userNotFoundEncodedPassword变量作为默认密码和登录请求传来的用户密码进行比对，这是 一个一开始就注定要失败的密码比对，那么为什么还要进行比对呢？这主要是为了避免旁道攻击(Side-channel attack)。如果根据用户名査找用户失败，就直接抛出异常而不进行密码比对, 那么黑客经过大量的测试，就会发现有的请求耗费时间明显小于其他请求，那么进而可以得出该请求的用户名是一个不存在的用户名(因为用户名不存在，所以不需要密码比对，进而节省时间)，这样就可以获取到系统信息。为了避免这一问题，所以当用户查找失败时，也会调用 mitigateAgainstTimingAttack方法进行密码比对,这样就可以迷惑黑客。</p></li><li><p>createSuccessAuthentication方法则是在登录成功后，创建一个全新的 UsernamePasswordAuthenticationToken对象，同时会判断是否需要进行密码升级，如果需要进行密码升级，就会在该方法中进行加密方案升級。通过对 AbstractUserDetailsAuthenticationProvider 和 DaoAuthenticationProvider 的讲解，相信你己经很明白AuthenticationProvider中的认证逻辑了。</p></li></ul><p>  在密码学中，旁道攻击(Side-channel attack )又称侧信道攻击、边信道攻击。这种攻击方式不是暴力破解或者是研究加密算法的弱点。它是基于从密码系统的物理实现中获取信息， 比如时间、功率消耗、电磁泄漏等，这些信息可被利用于对系统的进一步破解。</p><h3 id="1-1-3-ProviderManager"><a href="#1-1-3-ProviderManager" class="headerlink" title="1.1.3 ProviderManager"></a>1.1.3 ProviderManager</h3><p>  ProviderManager是AuthenticationManager的一个重要实现类，正在开始学习之前，我们先通过一幅图来了解一下ProviderManager和AuthenticationProvider之间的关系，如图3-1所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%886%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><center>图 3-1</center>  在Spring Security中，由于系统可能同时支持多种不同的认证方式，例如同时支持用户名 /密码认证、RememberMe认证、手机号码动态认证等，而不同的认证方式对应了不同的 AuthenticationProvider，所以一个完整的认证流程可能由多个AuthenticationProvider来提供。<p>  多个AuthenticationProvider将组成一个列表，这个列表将由ProviderManager代理。换句话说，在 ProviderManager 中存在一个 AuthenticationProvider 列表，在 ProviderManager 中遍历列表中的每一个AuthenticationProvider去执行身份认证，最终得到认证结果。</p><p>  ProviderManager 本身也可以再配置一个 AuthenticationManager 作为 parent，这样当 ProviderManager认证失败之后，就可以进入到parent中再次进行认证。理论上来说， ProviderManager的parent可以是任意类型的 AuthenticationManager，但是通常都是由 ProviderManager 来扮演 parent 的角色，也就是 ProviderManager 是 ProviderManager 的 parent。</p><p>  ProviderManager本身也可以有多个，多个ProviderManager共用同一个parent,当存在多个过滤器链的时候非常有用。当存在多个过滤器链时，不同的路径可能对应不同的认证方式, 但是不同路径可能又会同时存在一些共有的认证方式,这些共有的认证方式可以在parent中统 一处理。</p><p>  根据上面的介绍，图 3-2是ProviderManager和AuthenticationProvider关系图。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%886%EF%BC%89%EF%BC%882%EF%BC%89.png"></p><center>图 3-2</center><p>  我们重点看一下ProviderManager中的authenticate方法：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">       Class&lt;? <span class="keyword">extends</span> <span class="title class_">Authentication</span>&gt; toTest = authentication.getClass();</span><br><span class="line">       <span class="type">AuthenticationException</span> <span class="variable">lastException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">AuthenticationException</span> <span class="variable">parentException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Authentication</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Authentication</span> <span class="variable">parentResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">debug</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line">       <span class="type">Iterator</span> <span class="variable">var8</span> <span class="operator">=</span> <span class="built_in">this</span>.getProviders().iterator();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">           <span class="type">AuthenticationProvider</span> <span class="variable">provider</span> <span class="operator">=</span> (AuthenticationProvider)var8.next();</span><br><span class="line">           <span class="keyword">if</span> (provider.supports(toTest)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                   logger.debug(<span class="string">&quot;Authentication attempt using &quot;</span> + provider.getClass().getName());</span><br><span class="line">               &#125;</span><br><span class="line">   </span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   result = provider.authenticate(authentication);</span><br><span class="line">                   <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                       <span class="built_in">this</span>.copyDetails(authentication, result);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InternalAuthenticationServiceException | AccountStatusException var13) &#123;</span><br><span class="line">                   <span class="built_in">this</span>.prepareException(var13, authentication);</span><br><span class="line">                   <span class="keyword">throw</span> var13;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (AuthenticationException var14) &#123;</span><br><span class="line">                   lastException = var14;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">if</span> (result == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               result = parentResult = <span class="built_in">this</span>.parent.authenticate(authentication);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ProviderNotFoundException var11) &#123;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (AuthenticationException var12) &#123;</span><br><span class="line">               parentException = var12;</span><br><span class="line">               lastException = var12;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">this</span>.eraseCredentialsAfterAuthentication &amp;&amp; result <span class="keyword">instanceof</span> CredentialsContainer) &#123;</span><br><span class="line">               ((CredentialsContainer)result).eraseCredentials();</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           <span class="keyword">if</span> (parentResult == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="built_in">this</span>.eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (lastException == <span class="literal">null</span>) &#123;</span><br><span class="line">               lastException = <span class="keyword">new</span> <span class="title class_">ProviderNotFoundException</span>(<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;ProviderManager.providerNotFound&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;toTest.getName()&#125;, <span class="string">&quot;No AuthenticationProvider found for &#123;0&#125;&quot;</span>));</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           <span class="keyword">if</span> (parentException == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="built_in">this</span>.prepareException((AuthenticationException)lastException, authentication);</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           <span class="keyword">throw</span> lastException;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这段源码的逻辑还是非常清晰的，我们分析一下：</p><ul><li>首先获取authentication对象的类型。</li><li>分别定义当前认证过程抛出的异常、parent中认证时抛出的异常、当前认证结果以及parent中认证结果对应的变量。</li><li>getProviders 方法用来获取当前 ProviderManager 所代理的所有 AuthenticationProvider 对象，遍历这些AuthenticationProvider对象进行身份认证。</li><li>判断当前AuthenticationProvider是否支持当前Authentication对象，要是不支持，则继续处理列表中的下一个AuthenticationProvider对象</li><li>调用provider.authenticate方法进行身份认证，如果认证成功，返回认证后的 Authentication对象，同时调用copyDetails方法给Authentication对象的details属性赋值，由于可能是多个AuthenticationProvider执行认证操作，所以如果抛出异常_，_则通过lastException 变量来记录。</li><li>在for循环执行完成后，如果result还是没有值，说明所有的AuthenticationProvider 都认证失败，此时如果parent不为空，则调用parent的authenticate方法进行认证。</li><li>接下来，如果result不为空，就将result中的凭证擦除，防止泄漏，如果使用了用户名&#x2F;密码的方式登录，那么所谓的擦除实际上就是将密码字段设置为null,同时将登录成功的事件发布出去(发布登录成功事件需要parentResult为null。如果parentResult不为null,表示在parent中已经认证成功了，认证成功的事件也己经在parent中发布出去了_，_这样会导致认证成功的事件重复发布)。如果用户认证成功，此时就将result返回，后面的代码也就不再执行了。</li><li>如果前面没能返回result,说明认证失败。如果lastException为null,说明parent为 null或者没有认证亦或者认证失败了但是没有抛出异常,此时构造ProviderNotFoundException 异常赋值给lastException。</li><li>如果parentException为null,发布认证失败事件(如果parentException不为null, 则说明认证失败事件已经发布过了)。</li><li>最后抛出lastException异常。</li></ul><p>  这就是ProviderManager中authenticate方法的身份认证逻辑，其他方法的源码要相对简单很多，在这里就不一一解释了，</p><p>  现在，大家已经熟悉了 Authentication、AuthenticationManager、AuthenticationProvider 以 及ProviderManager的工作原理了，接下来的问题就是这些组件如何跟登录关联起来？这就涉及一个重要的过滤器———————– AbstractAuthenticationProcessingFilter。</p><h3 id="1-1-4-AbstractAuthenticationProcessingFilter"><a href="#1-1-4-AbstractAuthenticationProcessingFilter" class="headerlink" title="1.1.4 AbstractAuthenticationProcessingFilter"></a>1.1.4 AbstractAuthenticationProcessingFilter</h3><p>作为 Spring Security 过滤器链中的一环，AbstractAuthenticationProcessingFilter可以用来处理任何提交给它的身份认证，图3-3描述了 AbstractAuthenticationProcessingFilter的工作流程：</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%886%EF%BC%89%EF%BC%883%EF%BC%89.png"></p><center>图 3-3</center><p>  图中显示的流程是一个通用的架构。</p><p>  AbstractAuthenticationProcessingFilter作为一个抽象类，如果使用用户名&#x2F;密码的方式登录, 那么它对应的实现类是 UsernamePasswordAuthenticationFilter；构造出来的 Authentication 对象则是 UsernamePasswordAuthenticationToken。至于 AuthenticationManager,前面已经说过，一 般情况下它的实现类就是ProviderManager,这里在ProviderManager中进行认证，认证成功就会进入认证成功的回调，否则进入认证失败的回调。因此，我们可以对上面的流程图再做进一 步细化，如图3-4所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%886%EF%BC%89%EF%BC%884%EF%BC%89.png"></p><center>图 3-4</center><p>  前面第2章中所涉及的认证流程基本上就是这样，我们来大致梳理一下：</p><ul><li>当用户提交登录请求时，UsernamePasswordAuthenticationFilter会从当前请求 httpsServletRequest中提取出登录用户名&#x2F;密码，然后创建出一个 UsernamePasswordAuthenticationToken 对象。</li><li>UsernamePasswordAuthenticationToken 对象将被传入 ProviderManager 中进行具体的认证操作。</li><li>如果认证失败，则SecurityContextHolder中相关信息将被清除，登录失败回调也会被调用，</li><li>如果认证成功，则会进行登录信息存储、Session并发处理、登录成功事件发布以及登录成功方法回调等操作。</li></ul><p>  这是认证的一个大致流程。接下来我们结合 AbstractAuthenticationProcessingFilter和 UsernamePasswordAuthenticationFilter的源码来看一下。</p><p>  先来看 AbstractAuthenticationProcessingFilter源码(部分核心代码):</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAuthenticationProcessingFilter</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">ApplicationEventPublisherAware</span>, MessageSourceAware &#123;</span><br><span class="line"><span class="keyword">protected</span> ApplicationEventPublisher eventPublisher;</span><br><span class="line"><span class="keyword">protected</span> AuthenticationDetailsSource&lt;httpsServletRequest, ?&gt; authenticationDetailsSource = <span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>();</span><br><span class="line"><span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">MessageSourceAccessor</span> <span class="variable">messages</span> <span class="operator">=</span> SpringSecurityMessageSource.getAccessor();</span><br><span class="line"><span class="keyword">private</span> <span class="type">RememberMeServices</span> <span class="variable">rememberMeServices</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullRememberMeServices</span>();</span><br><span class="line"><span class="keyword">private</span> RequestMatcher requiresAuthenticationRequestMatcher;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">continueChainBeforeSuccessfulAuthentication</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">SessionAuthenticationStrategy</span> <span class="variable">sessionStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullAuthenticatedSessionStrategy</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">allowSessionCreation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">AuthenticationSuccessHandler</span> <span class="variable">successHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SavedRequestAwareAuthenticationSuccessHandler</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">AuthenticationFailureHandler</span> <span class="variable">failureHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleUrlAuthenticationFailureHandler</span>();</span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractAuthenticationProcessingFilter</span><span class="params">(String defaultFilterProcessesUrl)</span> &#123;</span><br><span class="line">setFilterProcessesUrl(defaultFilterProcessesUrl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractAuthenticationProcessingFilter</span><span class="params">(</span></span><br><span class="line"><span class="params">RequestMatcher requiresAuthenticationRequestMatcher)</span> &#123;</span><br><span class="line">Assert.notNull(requiresAuthenticationRequestMatcher,</span><br><span class="line"><span class="string">&quot;requiresAuthenticationRequestMatcher cannot be null&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.requiresAuthenticationRequestMatcher = requiresAuthenticationRequestMatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">Assert.notNull(authenticationManager, <span class="string">&quot;authenticationManager must be specified&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="type">httpsServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (httpsServletRequest) req;</span><br><span class="line"><span class="type">httpsServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (httpsServletResponse) res;</span><br><span class="line"><span class="keyword">if</span> (!requiresAuthentication(request, response)) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Request is to process authentication&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Authentication authResult;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">authResult = attemptAuthentication(request, response);</span><br><span class="line"><span class="keyword">if</span> (authResult == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">logger.error(</span><br><span class="line"><span class="string">&quot;An internal error occurred while trying to authenticate the user.&quot;</span>,</span><br><span class="line">failed);</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AuthenticationException failed) &#123;</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line">successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">requiresAuthentication</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">httpsServletResponse response)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> requiresAuthenticationRequestMatcher.matches(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">httpsServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException, IOException,</span><br><span class="line">ServletException;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">successfulAuthentication</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">httpsServletResponse response, FilterChain chain, Authentication authResult)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Authentication success. Updating SecurityContextHolder to contain: &quot;</span></span><br><span class="line">+ authResult);</span><br><span class="line">&#125;</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line">rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.eventPublisher != <span class="literal">null</span>) &#123;</span><br><span class="line">eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">InteractiveAuthenticationSuccessEvent</span>(</span><br><span class="line">authResult, <span class="built_in">this</span>.getClass()));</span><br><span class="line">&#125;</span><br><span class="line">successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">unsuccessfulAuthentication</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">httpsServletResponse response, AuthenticationException failed)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">SecurityContextHolder.clearContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Authentication request failed: &quot;</span> + failed.toString(), failed);</span><br><span class="line">logger.debug(<span class="string">&quot;Updated SecurityContextHolder to contain null Authentication&quot;</span>);</span><br><span class="line">logger.debug(<span class="string">&quot;Delegating to authentication failure handler &quot;</span> + failureHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rememberMeServices.loginFail(request, response);</span><br><span class="line"></span><br><span class="line">failureHandler.onAuthenticationFailure(request, response, failed);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先通过requiresAuthentication方法来判断当前请求是不是登录认证请求，如果是认证请求，就执行接下来的认证代码；如果不是认证请求，则直接继续走剩余的过滤器即可。</li><li>调用attemptAuthentication方法来获取一个经过认证后的Authentication对象, attemptAuthentication方法是一个抽象方法，具体实现在它的子类 UsernamePasswordAuthenticationFilter 中。</li><li>认证成功后，通过sessionStrategy.onAuthentication方法来处理session并发问题。</li><li>continueChainBeforeSuccessfulAuthentication变量用来判断请求是否还需要继续向下走，默认情况下该参数的值为false，即认证成功后，后续的过滤器将不再执行了。</li><li>unsuccessfulAuthentication方法用来处理认证失败事宜，主要做了三件事：①从 SecurityContextHolder中清除数据；②清除Cookie等信息；③调用认证失败的回调方法。</li><li>successfulAuthentication方法主要用来处理认证成功事宜，主要做了四件事：①向 SecurityContextHolder中存入用户信息；②处理Cookie；③发布认证成功事件，这个事件类型 InteractiveAuthenticationSuccessEvent,表示通过一些自动交互的方式认证成功，例如通过 RememberMe的方式登录；④调用认证成功的回调方法。</li></ul><p>这就是 AbstractAuthenticationProcessingFilter大致上所做的事情，还有一个抽象方法 attemptAuthentication 是在它的继承类 UsernamePasswordAuthenticationFilter中实现的，接下来我们来看—下UsernamePasswordAuthenticationFilter类:</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsernamePasswordAuthenticationFilter</span> <span class="keyword">extends</span></span><br><span class="line"><span class="title class_">AbstractAuthenticationProcessingFilter</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPRING_SECURITY_FORM_USERNAME_KEY</span> <span class="operator">=</span> <span class="string">&quot;username&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPRING_SECURITY_FORM_PASSWORD_KEY</span> <span class="operator">=</span> <span class="string">&quot;password&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">usernameParameter</span> <span class="operator">=</span> SPRING_SECURITY_FORM_USERNAME_KEY;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">passwordParameter</span> <span class="operator">=</span> SPRING_SECURITY_FORM_PASSWORD_KEY;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">postOnly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UsernamePasswordAuthenticationFilter</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;POST&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">httpsServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"><span class="keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationServiceException</span>(</span><br><span class="line"><span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> obtainUsername(request);</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> obtainPassword(request);</span><br><span class="line"><span class="keyword">if</span> (username == <span class="literal">null</span>) &#123;</span><br><span class="line">username = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (password == <span class="literal">null</span>) &#123;</span><br><span class="line">password = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">username = username.trim();</span><br><span class="line"><span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(</span><br><span class="line">username, password);</span><br><span class="line">setDetails(request, authRequest);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">obtainPassword</span><span class="params">(httpsServletRequest request)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> request.getParameter(passwordParameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">obtainUsername</span><span class="params">(httpsServletRequest request)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> request.getParameter(usernameParameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先声明了默认情况下登录表单的用户名字段和密码字段，用户名字段的key默认是username,密码字段的key默认是password。当然，这两个字段也可以自定义，自定义的方式就是我们在 SecurityConfig 中配置的  .usernameParameter(“uname”)和  .passwordParameter(“passwd”)(参考前几节)</li><li>在UsernamePasswordAuthenticationFilter过滤器构建的时候，指定了当前过滤器只用来处理登录请求，默认的登录请求是&#x2F;login,当然开发者也可以自行配置。</li><li>接下来就是最重要的attemptAuthentication方法了，在该方法中，首先确认请求是 post类型；然后通过obtainUsername和obtainPassword方法分别从请求中提取出用户名和密码, 具体的提取过程就是调用request.getParameter方法；拿到登录请求传来的用户名&#x2F;密码之后， 构造出一个 authRequest,然后调用 getAuthenticationManager().authenticate 方法进行认证，这就进入到我们前面所说的ProviderManager的流程中了，具体认证过程就不再赘述了。</li></ul><p>  以上就是整个认证流程。</p><p>  搞懂了认证流程，那么接下来如果想要自定义一些认证方式，就会非常容易了，比如定义多个数据源、添加登录校验码等。下面，我们将通过两个案例，来活学活用上面所讲的认证流程。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security自定义登录认证与数据持久化（5）</title>
      <link href="/2022/08/03/Spring%20Security%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%885%EF%BC%89/"/>
      <url>/2022/08/03/Spring%20Security%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%885%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-用户定义"><a href="#1-用户定义" class="headerlink" title="1.用户定义"></a>1.用户定义</h1><p> 在前面的案例中，我们的登录用户是基于配置文件来配置的(本质是基于内存)，但是在实际开发中，这种方式肯定是不可取的，在实际项目中，用户信息肯定要存入数据库之中。</p><p>  Spring Security支持多种用户定义方式，接下来我们就逐个来看一下这些定义方式。通过前面的介绍(参见3小节),大家对于UserDetailsService以及它的子类都有了一定的了解, 自定义用户其实就是使用UserDetailsService的不同实现类来提供用户数据，同时将配置好的 UserDetailsService 配置给 AuthenticationManagerBuilder,系统再将 UserDetailsSeivice 提供给 AuthenticationProvider 使用，</p><h2 id="1-1-基于内存"><a href="#1-1-基于内存" class="headerlink" title="1.1 基于内存"></a>1.1 基于内存</h2><p>前面案例中用户的定义本质上还是基于内存，只是我们没有将InMemoryUserDetailsManager类明确抽出来自定义，现在我们通过自定义InMemoryUserDetailsManager来看一下基于内存的用户是如何自定义的。</p><p>    重写 WebSecurityConfigurerAdapter 类的 configure(AuthenticationManagerBuilder)方法，内容如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">InMemoryUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;buretuzi&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123456&quot;</span>).roles(<span class="string">&quot;admin&quot;</span>).build());</span><br><span class="line">    manager.createUser(User.withUsername(<span class="string">&quot;sang&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123&quot;</span>).roles(<span class="string">&quot;user&quot;</span>).build());</span><br><span class="line">    auth.userDetailsService(manager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  首先构造了一个InMemoryUserDetailsManager实例，调用该实例的createUser方法来创建用户对象，我们在这里分别设置了用户名、密码以及用户角色。需要注意的是，用户密码加了 一个{noop}前缀，表示密码不加密，明文存储(关于密码加密问题，会在后面的章节中专门介绍)。</p><p>  配置完成后，启动项目，此时就可以使用这里配置的两个用户登录了。</p><p>  InMemoryUserDetailsManager 的实现原理很简单，它间接实现了 UserDetailsService 接口并重写了它里边的 loadUserByUsername方法，同时它里边维护了 一个HashMap变量，Map的 key 就是用户名，value则是用户对象，createUser就是往这个Map中存储数据，loadUserByUsername方法则是从该Map中读取数据，这里的源码比较简单，就不贴出来了，读者可以自行查看。</p><h2 id="1-2-基于JdbcUserDetailsManager"><a href="#1-2-基于JdbcUserDetailsManager" class="headerlink" title="1.2  基于JdbcUserDetailsManager"></a>1.2  基于JdbcUserDetailsManager</h2><p>JdbcUserDetailsManager支持将用户数据持久化到数据库，同时它封装了一系列操作用户的方法，例如用户的添加、更新、查找等。</p><p>   Spring Security 中为 JdbcUserDetailsManager 提供了数据库脚本，位置在 org&#x2F;springframework&#x2F;security&#x2F;core&#x2F;userdetails&#x2F;jdbc&#x2F;users.ddl 内容如下：（注意将varchar_ignorecase改为varchar）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users(username varchar_ignorecase(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line">                   password varchar_ignorecase(<span class="number">500</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">                   enabled <span class="type">boolean</span> <span class="keyword">not</span> <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> authorities (username varchar_ignorecase(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">                          authority varchar_ignorecase(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">                          <span class="keyword">constraint</span> fk_authorities_users <span class="keyword">foreign</span> key(username) <span class="keyword">references</span> users(username));</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index ix_auth_username <span class="keyword">on</span> authorities (username,authority);</span><br></pre></td></tr></table></figure><p>  可以看到这里一共创建了两张表，users表就是存放用户信息的表，authorities则是存放用户角色的表。但是大家注意SQL的数据类型中有一个varchar_ignorecase，这个其实是针对 HSQLDB 的数据类型，我们这里使用的是MySQL数据库，所以这里手动将varchar_ignorecase 类型修改为varchar类型，然后去数据库中执行修改后的脚本。</p><p>  另一方面，由于要将数据存入数据库中，所以我们的项目也要提供数据库支持， JdbcUserDetailsManager底层实际上是使用JdbcTemplate来完成的，所以这里主要添加两个依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  然后在resources&#x2F;application.yml中配置数据库连接信息：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>  配置完成后，我们重写WebSecurityConfigurerAdapter类的 configure(AuthenticationManagerBuilder auth)方法，内容如下（注意版本，不得低于以下版本）：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.provisioning.JdbcUserDetailsManager;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">JdbcUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcUserDetailsManager</span>(dataSource);</span><br><span class="line">        <span class="keyword">if</span> (!manager.userExists(<span class="string">&quot;buretuzi&quot;</span>))&#123;</span><br><span class="line">            manager.createUser(User.withUsername(<span class="string">&quot;buretuzi&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123456&quot;</span>).roles(<span class="string">&quot;admin&quot;</span>).build());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!manager.userExists(<span class="string">&quot;song&quot;</span>))&#123;</span><br><span class="line">            manager.createUser(User.withUsername(<span class="string">&quot;sang&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123&quot;</span>).roles(<span class="string">&quot;user&quot;</span>).build());</span><br><span class="line">        &#125;</span><br><span class="line">        auth.userDetailsService(manager);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当引入spring-boot-starter-jdbc并配置了数据库连接信息后，一个DataSource实例就有了，这里首先引入DataSource实例。</li><li>在 configure 方法中，创建一个 JdbcUserDetailsManager 实例，在创建时传入 DataSource 实例。通过userExists方法可以判断一个用户是否存在，该方法本质上就是去数据库中査询对应的用户；如果用户不存在，则通过createUser方法可以创建一个用户，该方法本质上就是向数据库中添加一个用户。</li><li>最后将manager实例设置到auth对象中。</li></ul><p>  配置完成后，重启项目，如果项目启动成功，数据库中就会自动添加进来两条数据，如图2-22、图2-23所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%885%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><center>图 2-22</center><p><img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%885%EF%BC%89%EF%BC%882%EF%BC%89.png"></p><center>图 2-23</center><p>  此时，我们就可以使用buretuzi&#x2F;123456，sang&#x2F;123进行登录测试了。</p><p>  在 JdbcUserDetailsManager 的继承体系中,首先是 JdbcDaoImpl 实现了 UserDetailsService 接口，并实现了基本的loadUserByUsername方法，JdbcUserDetailsManager则继承自 JdbcDaoImpl,同时完善了数据库操作，又封装了用户的增删改査方法，这里，我们以 loadUserByUsername为例，看一下源码，其余的增删改操作相对来说都比较容易，这里就不再赘述了。</p><p>  JdbcDaoImpl#loadUserByUsername:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcDaoImpl</span> <span class="keyword">extends</span> <span class="title class_">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span>, MessageSourceAware &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEF_USERS_BY_USERNAME_QUERY</span> <span class="operator">=</span> <span class="string">&quot;select username,password,enabled from users where username = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEF_AUTHORITIES_BY_USERNAME_QUERY</span> <span class="operator">=</span> <span class="string">&quot;select username,authority from authorities where username = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEF_GROUP_AUTHORITIES_BY_USERNAME_QUERY</span> <span class="operator">=</span> <span class="string">&quot;select g.id, g.group_name, ga.authority from groups g, group_members gm, group_authorities ga where gm.username = ? and g.id = ga.group_id and g.id = gm.group_id&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">MessageSourceAccessor</span> <span class="variable">messages</span> <span class="operator">=</span> SpringSecurityMessageSource.getAccessor();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">authoritiesByUsernameQuery</span> <span class="operator">=</span> <span class="string">&quot;select username,authority from authorities where username = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">groupAuthoritiesByUsernameQuery</span> <span class="operator">=</span> <span class="string">&quot;select g.id, g.group_name, ga.authority from groups g, group_members gm, group_authorities ga where gm.username = ? and g.id = ga.group_id and g.id = gm.group_id&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">usersByUsernameQuery</span> <span class="operator">=</span> <span class="string">&quot;select username,password,enabled from users where username = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">rolePrefix</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">usernameBasedPrimaryKey</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">enableAuthorities</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enableGroups;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        List&lt;UserDetails&gt; users = <span class="built_in">this</span>.loadUsersByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (users.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Query returned no results for user &#x27;&quot;</span> + username + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;JdbcDaoImpl.notFound&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;username&#125;, <span class="string">&quot;Username &#123;0&#125; not found&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> (UserDetails)users.get(<span class="number">0</span>);</span><br><span class="line">            Set&lt;GrantedAuthority&gt; dbAuthsSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.enableAuthorities) &#123;</span><br><span class="line">                dbAuthsSet.addAll(<span class="built_in">this</span>.loadUserAuthorities(user.getUsername()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.enableGroups) &#123;</span><br><span class="line">                dbAuthsSet.addAll(<span class="built_in">this</span>.loadGroupAuthorities(user.getUsername()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;GrantedAuthority&gt; dbAuths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(dbAuthsSet);</span><br><span class="line">            <span class="built_in">this</span>.addCustomAuthorities(user.getUsername(), dbAuths);</span><br><span class="line">            <span class="keyword">if</span> (dbAuths.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.logger.debug(<span class="string">&quot;User &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; has no authorities and will be treated as &#x27;not found&#x27;&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;JdbcDaoImpl.noAuthority&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;username&#125;, <span class="string">&quot;User &#123;0&#125; has no GrantedAuthority&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.createUserDetails(username, user, dbAuths);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> List&lt;UserDetails&gt; <span class="title function_">loadUsersByUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getJdbcTemplate().query(<span class="built_in">this</span>.usersByUsernameQuery, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;username&#125;, (rs, rowNum) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username1</span> <span class="operator">=</span> rs.getString(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> rs.getString(<span class="number">2</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">enabled</span> <span class="operator">=</span> rs.getBoolean(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(username1, password, enabled, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, AuthorityUtils.NO_AUTHORITIES);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先根据用户名，调用loadUserByUsername方法去数据库中查询用户，查询出来的是一个List集合，集合中如果没有数据，说明用户不存在，则直接抛出异常，</li><li>如果集合中存在数据，则将集合中的第一条数据拿出来，然后再去查询用户角色， 最后根据这些信息创建一个新的UserDetails出来。</li><li>需要注意的是，这里还引入了分组的概念，不过考虑到JdbcUserDetailsManager并非我们实际项目中的主流方案，因此这里不做过多介绍。</li></ul><p>  这就是使用JdbcUserDetailsManager做数据持久化。这种方式看起来简单，都不用开发者自己写SQL,但是局限性比较大，无法灵活地定义用户表、角色表等，而在实际开发中，我们还是希望能够灵活地掌控数据表结构，因此JdbcUserDetailsManager使用场景非常有限。</p><h2 id="1-3-基于-MyBatis"><a href="#1-3-基于-MyBatis" class="headerlink" title="1.3 基于 MyBatis"></a>1.3 基于 MyBatis</h2><p>使用MyBatis做数据持久化是目前大多数企业应用釆取的方案，Spring Security中结合 MyBatis可以灵活地定制用户表以及角色表，我们对此进行详细介绍。</p><p>  首先需要设计三张表，分别是用户表、角色表以及用户角色关联表，三张表的关系如图 2-24所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%885%EF%BC%89%EF%BC%883%EF%BC%89.png"></p><center>图 2-24</center><p>  用户和角色是多对多的关系，我们使用user_role来将两者关联起来。 数据库脚本如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `role`(</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`nameZh` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(`id`)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`username` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`password` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`enabled` TINYINT(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`accountNonExpired` TINYINT(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`accountNonLocked` TINYINT(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`credentialsNonExpired` TINYINT(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(`id`)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_role`(</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`uid` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`rid` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(`id`),</span><br><span class="line">KEY `uid` (`uid`),</span><br><span class="line">KEY `rid` (`rid`)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure><p>  对于角色表，三个字段从上往下含义分别为角色id、角色英文名称以及角色中文名称， 对于用户表，七个字段从上往下含义依次为：用户id、用户名、用户密码、账户是否可用、账户是否没有过期、账户是否没有锁定以及凭证(密码)是否没有过期。</p><p>  数据库创建完成后，可以向数据库中添加几条模拟数据，代码如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role` (`id`,`name`,`nameZh`)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;ROLE_dba&#x27;</span>,<span class="string">&#x27;数据库管理员&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;ROLE_admin&#x27;</span>,<span class="string">&#x27;系统管理员&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;ROLE_user&#x27;</span>,<span class="string">&#x27;用户&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` (`id`,`username`,`password`,`enabled`,`accountNonExpired`,`accountNonLocked`,`credentialsNonExpired`)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;root&#x27;</span>,<span class="string">&#x27;&#123;noop&#125;123&#x27;</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;&#123;noop&#125;123&#x27;</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;sang&#x27;</span>,<span class="string">&#x27;&#123;noop&#125;123&#x27;</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `user_role` (`id`,`uid`,`rid`)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>  这样，数据库的准备工作就算完成了。</p><p>  在Spring Security项目中，我们需要引入MyBatis和MySQL依赖，代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  同时在resources&#x2F;application.yml中配置数据库基本连接信息：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>  接下来创建用户类和角色类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Boolean enabled;</span><br><span class="line">    <span class="keyword">private</span> Boolean accountNonExpired;</span><br><span class="line">    <span class="keyword">private</span> Boolean accountNonLocked;</span><br><span class="line">    <span class="keyword">private</span> Boolean credentialsNonExpired;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Role&gt; roles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Role&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Role role : roles) &#123;</span><br><span class="line">            authorities.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(role.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountNonLocked;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> credentialsNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> enabled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String nameZh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  自定义用户类需要实现UserDetails接口，并实现接口中的方法，这些方法的含义我们在 3小节中已经介绍过了，这里不再赘述。其中roles属性用来保存用户所具备的角色信息， 由于系统获取用户角色调用的方法是getAuthorities，所以我们在getAuthorities方法中，将roles 中的角色转为系统可识别的对象并返回。</p><p>  接下来我们自定义UserDetailsService以及对应的数据库查询方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.Role;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span>&#123;</span><br><span class="line">    List&lt;Role&gt; <span class="title function_">getRolesByUid</span><span class="params">(Integer id)</span>;</span><br><span class="line">    User <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.loadUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        user.setRoles(userMapper.getRolesByUid(user.getId()));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  自定义 MyUserDetailsService实现UserDetailsService接口，并实现该接口中的方法。 loadUserByUsername方法经过前面章节的讲解，相信大家已经很熟悉了，该方法就是根据用户名去数据库中加载用户，如果从数据库中没有査到用户，则抛出UsernameNotFoundException 异常；如果査询到用户了，则给用户设置roles属性。</p><p>  UserMapper中定义两个方法用于支持MyUserDetailsService中的査询操作。</p><p>最后_,_在UserMapper.xml中定义查询SQL,代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.intehel.demo.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;loadUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.intehel.demo.domain.User&quot;</span>&gt;</span></span><br><span class="line">        select * from `user` where username = #&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;loadUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.intehel.demo.domain.Role&quot;</span>&gt;</span></span><br><span class="line">        select r.* from role r,user_role ur where r.`id`=ur.`rid`</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  将mylogin.html放在 resources&#x2F;templates&#x2F; 下，mylogin.html如下</p><p>查看代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;https://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bootstrap-css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#login</span> <span class="selector-class">.container</span> <span class="selector-id">#login-row</span> <span class="selector-id">#login-column</span> <span class="selector-id">#login-box</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#9c9c9c</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#EAEAEA</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-row&quot;</span> <span class="attr">class</span>=<span class="string">&quot;row justify-content-center align-items-center&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-column&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-6&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-box&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-12&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;login-form&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/doLogin&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;text-center text-info&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--/*@thymesVar id=&quot;SPRING_SECURITY_LAST_EXCEPTION&quot; type=&quot;com&quot;*/--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;SPRING_SECURITY_LAST_EXCEPTION&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-info&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uname&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-info&quot;</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-info btn-md&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  为了方便，我们将UserMapper.xml文件放在resources&#x2F;mapper下，UsetMapper接口放在mapper包下。为了防止 Maven打包时自动忽略了 XML文件，还需要在application.yml中添加mapper-locations配置：</p><p>查看代码</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">buretuzi</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">HTML</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="attr">servlet:</span></span><br><span class="line">      <span class="attr">content-type:</span> <span class="string">text/html</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">prefix:</span> <span class="string">classpath:/templates/</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment"># spring boot集成mybatis的方式打印sql</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p>  最后一步，就是在 SecurityConfig 中注入 UserDetailsService：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.handler.MyAuthenticationFailureHandler;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.service.MyUserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.httpsSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.provisioning.JdbcUserDetailsManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.util.matcher.AntPathRequestMatcher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.util.matcher.OrRequestMatcher;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyUserDetailsService myUserDetailsService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/index.html&quot;</span>)</span><br><span class="line">                .failureHandler(<span class="keyword">new</span> <span class="title class_">MyAuthenticationFailureHandler</span>())</span><br><span class="line">                .usernameParameter(<span class="string">&quot;uname&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                .logoutRequestMatcher(<span class="keyword">new</span> <span class="title class_">OrRequestMatcher</span>(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout1&quot;</span>,<span class="string">&quot;GET&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout2&quot;</span>,<span class="string">&quot;POST&quot;</span>)))</span><br><span class="line">                .invalidatehttpsSession(<span class="literal">true</span>)</span><br><span class="line">                .clearAuthentication(<span class="literal">true</span>)</span><br><span class="line">                .defaultLogoutSuccessHandlerFor((req,resp,auth)-&gt;&#123;</span><br><span class="line">                    resp.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">                    Map&lt;String,Object&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">                    result.put(<span class="string">&quot;status&quot;</span>,<span class="number">200</span>);</span><br><span class="line">                    result.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;使用logout1注销成功！&quot;</span>);</span><br><span class="line">                    <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> om.writeValueAsString(result);</span><br><span class="line">                    resp.getWriter().write(s);</span><br><span class="line">                &#125;,<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout1&quot;</span>,<span class="string">&quot;GET&quot;</span>))</span><br><span class="line">                .defaultLogoutSuccessHandlerFor((req,resp,auth)-&gt;&#123;</span><br><span class="line">                    resp.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">                    Map&lt;String,Object&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">                    result.put(<span class="string">&quot;status&quot;</span>,<span class="number">200</span>);</span><br><span class="line">                    result.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;使用logout2注销成功！&quot;</span>);</span><br><span class="line">                    <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> om.writeValueAsString(result);</span><br><span class="line">                    resp.getWriter().write(s);</span><br><span class="line">                &#125;,<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout1&quot;</span>,<span class="string">&quot;GET&quot;</span>))</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth.userDetailsService(myUserDetailsService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   配置UserDetailsService的方式和前面配置JdbcUserDetailsManager的方式基本一致，只不过配置对象变成了 myUserDetailsService而己。至此，整个配置工作就完成了。</p><p>  接下来启动项目，利用数据库中添加的模拟用户进行登录测试，就可以成功登录了，测试方式和前面章节一致，这里不再赘述。</p><h2 id="1-4-基于-Spring-Data-JPA"><a href="#1-4-基于-Spring-Data-JPA" class="headerlink" title="1.4  基于 Spring Data JPA"></a>1.4  基于 Spring Data JPA</h2><p> 考虑到在Spring Boot技术栈中也有不少人使用Spring Data JPA,因此这里针对Spring Security+Spring Data JPA也做一个简单介绍，具体思路和基于MyBatis的整合类似。</p><p>   首先引入Spring Data JPA的依赖和MySQL依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  然后在resources&#x2F;application.yml中配置数据库和JPA,代码如下：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=true</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">database-platform:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">hibernate:</span></span><br><span class="line">        <span class="attr">dialect:</span> <span class="string">org.hibernate.dialect.Mysql8Dialect</span></span><br></pre></td></tr></table></figure><p>  据库的配置还是和以前一样，JPA的配置则主要配置了数据库平台，数据表更新方式、 是否打印SQL以及对应的数据库方言。</p><p>  使用Spring Data JPA的好处是我们不用提前准备SQL脚本，所以接下来配置两个数据库实体类即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Boolean enabled;</span><br><span class="line">    <span class="keyword">private</span> Boolean accountNonExpired;</span><br><span class="line">    <span class="keyword">private</span> Boolean accountNonLocked;</span><br><span class="line">    <span class="keyword">private</span> Boolean credentialsNonExpired;</span><br><span class="line">    <span class="meta">@ManyToMany(fetch = FetchType.EAGER,cascade = CascadeType.PERSIST)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Role role : roles) &#123;</span><br><span class="line">            authorities.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(role.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountNonLocked;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> credentialsNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> enabled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity(name = &quot;role&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String nameZh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这两个实体类和前面MyBatis中实体类的配置类似，需要注意的是roles属性上多了一个 多对多配置。</p><p>  接下来配置UserDetailsService,并提供数据查询方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User,Integer&gt; &#123;</span><br><span class="line">    User <span class="title function_">findUserByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDao.findUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  MyUserDetailsService的定义也和前面的类似，不同之处在于数据查询方法的变化。定义 UserDao 继承自 JpaRepository,并定义一个 findUserByUsername 方法，剩下的事情 Spring Data JPA框架会帮我们完成。</p><p>  最后，再在 SecurityConfig 中配置 MyUserDetailsService配置方式和 MyBatis 一模一样， 这里就不再把代码贴岀来了。使用了 Spring Data JPA之后，当项目启动时，会自动在数据库中创建相关的表，而不用我们自己去写脚本，这也是使用Spring Data JPA的方便之处。</p><p>  为了测试方便，我们可以在单元测试中执行如下代码，向数据库中添加测试数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.Role;</span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user1.setUsername(<span class="string">&quot;buretuzi&quot;</span>);</span><br><span class="line">        user1.setPassword(<span class="string">&quot;&#123;noop&#125;123&quot;</span>);</span><br><span class="line">        user1.setAccountNonExpired(<span class="literal">true</span>);</span><br><span class="line">        user1.setAccountNonLocked(<span class="literal">true</span>);</span><br><span class="line">        user1.setCredentialsNonExpired(<span class="literal">true</span>);</span><br><span class="line">        user1.setEnabled(<span class="literal">true</span>);</span><br><span class="line">        List&lt;Role&gt; roles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Role</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Role</span>();</span><br><span class="line">        r1.setName(<span class="string">&quot;ROLE_admin&quot;</span>);</span><br><span class="line">        r1.setNameZh(<span class="string">&quot;管理员&quot;</span>);</span><br><span class="line">        roles.add(r1);</span><br><span class="line">        user1.setRoles(roles);</span><br><span class="line">        userDao.save(user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  测试数据添加成功之后，接下来启动项目，使用测试数据进行登录测试，具体测试过程就不再赘述了。</p><p>  至此，四种不同的用户定义方式就介绍完了。这四种方式，异曲同工，只是数据存储的方式不一样而已，其他的执行流程都是一样的</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security登录用户数据获取（4）</title>
      <link href="/2022/08/03/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89/"/>
      <url>/2022/08/03/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-登录用户数据获取"><a href="#1-登录用户数据获取" class="headerlink" title="1. 登录用户数据获取"></a>1. 登录用户数据获取</h1><p>  登录成功之后，在后续的业务逻辑中，开发者可能还需要获取登录成功的用户对象，如果不使用任何安全管理框架，那么可以将用户信息保存在httpsSession中，以后需要的时候直接从httpsSession中获取数据。在Spring Security中，用户登录信息本质上还是保存在 httpsSession中，但是为了方便使用，Spring Security对httpsSession中的用户信息进行了封装， 封装之后，开发者若再想获取用户登录数据就会有两种不同的思路：</p><ul><li>从 SecurityContextHolder 中获取</li><li>从当前请求对象中获取。</li></ul><p>这里列出来的两种方式是主流的做法，开发者也可以使用一些非主流的方式获取登录成功后的用户信息，例如直接从httpsSession中获取用户登录数据，</p><p>无论是哪种获取方式，都离不开一个重要的对象：Authentication。在Spring Security中， Authentication对象主要有两方面的功能：</p><ul><li>作为AuthenticationManager的输入参数，提供用户身份认证的凭证，当它作为一个 输入参数时，它的isAuthenticated方法返回false,表示用户还未认证。</li><li>代表已经经过身份认证的用户，此时的Authentication可以从SecurityContext中获取。</li></ul><p>一个Authentication对象主要包含三个方面的信息:</p><ul><li>principal:  定义认证的用户。如果用户使用用户名&#x2F;密码的方式登录，principal通常就是一个UserDetails对象。</li><li>credentials：登录凭证，一般就是指密码。当用户登录成功之后，登录凭证会被自动擦除，以防止泄漏。</li><li>authorities：用户被授予的权限信息。</li></ul><p>  Java中本身提供了 Principal接口用来描述认证主体，Principal可以代表一个公司、个人或者登录ID，Spring Security中定义了 Authentication接口用来规范登录用户信息， Authentication 继承自 Principal：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Authentication</span> <span class="keyword">extends</span> <span class="title class_">Principal</span>, Serializable &#123;</span><br><span class="line">Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line">Object <span class="title function_">getCredentials</span><span class="params">()</span>;</span><br><span class="line">Object <span class="title function_">getDetails</span><span class="params">()</span>;</span><br><span class="line">Object <span class="title function_">getPrincipal</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isAuthenticated</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setAuthenticated</span><span class="params">(<span class="type">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里接口中定义的方法都很好理解：</p><ul><li>getAuthorities方法：用来获取用户权限。</li><li>getCredentials方法：用来获取用户凭证,一般来说就是密码。</li><li>getDetails方法：用来获取用户的详细信息，可能是当前的请求之类。</li><li>getPrincipal方法：用来获取当前用户信息，可能是一个用户名，也可能是一个用户对象。</li><li>isAuthenticated方法：当前用户是否认证成功。</li></ul><p>可以看到，在Spring Security中，只要获取到Authentication对象，就可以获取到登录用户的详细信息，</p><p>不同的认证方式对应不同的Authentication实例,Spring Security中的Authentication实现类如图2-11所示，</p><p>这些实现类现看起来可能会觉得陌生，不过没关系，在后续中，这些实现类基本上都会涉及，现在我们先对每个类的功能做一个大概介绍：</p><ul><li><p>AbstractAuthenticationToken：该类实现了 Authentication 和 CredentialsContainer 两个接口，在AbstractAuthenticationToken中对Authentication接口定义的各个数据获取方法进行了 实现，CredentialsContainer则提供了登录凭证擦除方法。一般在登录成功后，为了防止用户信 息泄漏，可以将登录凭证(例如密码)擦除。</p></li><li><p>RememberMeAuthenticationToken:如果用户使用 RememberMe 的方式登录，登录信息将封装在 RememberMeAuthenticationToken中。</p></li><li><p>TestingAuthenticationToken:单元测试时封装的用户对象口</p></li><li><p>AnonymousAuthenticationToken：匿名登录时封装的用户对象。</p></li><li><p>RunAsUserToken：替换验证身份时封装的用户对象。</p></li><li><p>UsernamePasswordAuthenticationToken：表单登录时封装的用户对象。</p></li><li><p>JaasAuthenticationToken: JAAS 认证时封装的用户对象。</p></li><li><p>PreAuthenticatedAuthenticationToken： Pre-Authentication 场景下封装的用户对象。</p></li></ul><p>  在这些 Authentication 的实例中，最常用的有两个：UsernamePasswordAuthenticationToken 和RememberMeAuthenticationToken。在2中的案例对应的用户认证对象就是UsernamePasswordAuthenticationToken。</p><p>  了解了 Authentication对象之后，接下来我们来看一下如何在登录成功后获取用户登录信 息，即 Authentication 对象。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><center>图 2-11</center><h2 id="1-1-从-SecurityContextHolder-中获取"><a href="#1-1-从-SecurityContextHolder-中获取" class="headerlink" title="1.1 从 SecurityContextHolder 中获取"></a>1.1 从 SecurityContextHolder 中获取</h2><p>  添加一个UserController,内容如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userinfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">        Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = authentication.getAuthorities();</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;authorities = &quot;</span>+authorities);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  配置完成后，启动项目，登录成功后，访问&#x2F;user接口，控制台就会打印出登录用户信息, 当然，由于我们目前没有给用户配置角色，所以默认的用户角色为空数组，如图2-12所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%882%EF%BC%89.png"></p><center>图 2-12</center><p>  这里为了演示方便，我们在Controller中获取登录用户信息，可以发现，SecurityContextHolder.getContext()是一个静态方法，也就意味着我们随时随地都可以获取到登录用户信息，在service层也可以获取到登录用户信息(在实际项目中，大部分情况下也都是在service层获取登录用户信息)。</p><p>  获取登录用户信息的代码很简单，那么SecuntyContextHolder到底是什么？它里边的数据又是从何而来的？接下来我们将进行一一解析。</p><h3 id="1-1-1-SecurityContextHolder"><a href="#1-1-1-SecurityContextHolder" class="headerlink" title="1.1.1 SecurityContextHolder"></a>1.1.1 SecurityContextHolder</h3><p>  SecurityContextHolder 中存储的是 SecurityContext，SecurityContext 中存储的则是 Authentication，三者的关系如图2-13所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%883%EF%BC%89.png"></p><center>图 2-13</center><p>  这幅图清晰地描述了 SecurityContextHolder、SecurityContext 以及 Authentication 三者之间 的关系。</p><p>  首先在 SecurityContextHolder 中存放的是 SecurityContext, SecurityContextHolder 中定义了三种不同的数据存储策略，这实际上是一种典型的策略模式：</p><ul><li>MODE_THREADLOCAL:  这种存放策略是将 SecurityContext 存放在 ThreadLocal 中，大家知道ThreadLocal的特点是在哪个线程中存储就要在哪个线程中读取，这其实非常适合Web应用，因为在默认情况下，一个请求无论经过多少Filter到达Servlet都是由一个线程来处理的，这也是SecurityContextHolder的默认存储策略，这种存储策略意味着如果在具体的业务处理代码中，开启了子线程，在子线程中去获取登录用户数据，就会获取不到。</li><li>MODE_INHERITABLETHREADLOCAL:这种存储模式适用于多线程环境，如果希望在子线程中也能够获取到登录用户数据，那么可以使用这种存储模式。</li><li>MODE_GLOBAL：这种存储模式实际上是将数据保存在一个静态变量中，在Java Web开发中，这种模式很少使用到。</li></ul><p>Spring Security中定义了 SecurityContextHolderStrategy接口用来规范存储策略中的方法， 我们来看一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityContextHolderStrategy</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span>;</span><br><span class="line">SecurityContext <span class="title function_">getContext</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span>;</span><br><span class="line">SecurityContext <span class="title function_">createEmptyContext</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  接口中一共定义了四个方法：</p><ul><li>clearContext：该方法用来清除存储的SecurityContext对象。</li><li>getContext：该方法用来获取存储的SecurityContext对象。</li><li>setContext：该方法用来设置存储的SecurityContext对象。</li><li>createEmptyContext:  该方法则用来创建一个空的 SecurityContext对象。</li></ul><p>  在 Spring Security 中，SecurityContextHolderStrategy接口一共有三个实现类，对应了三种不同的存储策略，如图2-14所示</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%884%EF%BC%89.png"></p><center>图 2-14</center>每一个实现类都对应了不同的实现策略，我们先来看一下ThreadLocalSecurityContextHolderStrategy：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalSecurityContextHolderStrategy</span> <span class="keyword">implements</span></span><br><span class="line"><span class="title class_">SecurityContextHolderStrategy</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SecurityContext&gt; contextHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span> &#123;</span><br><span class="line">contextHolder.remove();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> SecurityContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SecurityContext</span> <span class="variable">ctx</span> <span class="operator">=</span> contextHolder.get();</span><br><span class="line"><span class="keyword">if</span> (ctx == <span class="literal">null</span>) &#123;</span><br><span class="line">ctx = createEmptyContext();</span><br><span class="line">contextHolder.set(ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">Assert.notNull(context, <span class="string">&quot;Only non-null SecurityContext instances are permitted&quot;</span>);</span><br><span class="line">contextHolder.set(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> SecurityContext <span class="title function_">createEmptyContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecurityContextImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  ThreadLocalSecurityContextHolderStrategy实现了 SecurityContextHolderStrategy接口，并实现了接口中的方法_，_存储数据的载体就是一个ThreadLocal，所以针对SecurityContext的清空、获取以及存储，都是在ThreadLocal中进行操作，例如清空就是调用ThreadLocal的remove 方法。SecurityContext是一个接口，它只有一个实现类SecurityContextImpl,所以创建就直接新建一个SecurityContextImpl对象即可。</p><p>  再来看 InheritableThreadLocalSecurityContextHolderStrategy：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocalSecurityContextHolderStrategy</span> <span class="keyword">implements</span></span><br><span class="line"><span class="title class_">SecurityContextHolderStrategy</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SecurityContext&gt; contextHolder = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span> &#123;</span><br><span class="line">contextHolder.remove();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> SecurityContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SecurityContext</span> <span class="variable">ctx</span> <span class="operator">=</span> contextHolder.get();</span><br><span class="line"><span class="keyword">if</span> (ctx == <span class="literal">null</span>) &#123;</span><br><span class="line">ctx = createEmptyContext();</span><br><span class="line">contextHolder.set(ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">Assert.notNull(context, <span class="string">&quot;Only non-null SecurityContext instances are permitted&quot;</span>);</span><br><span class="line">contextHolder.set(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> SecurityContext <span class="title function_">createEmptyContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecurityContextImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InheritableThreadLocalSecurityContextHolderStrategy 和 ThreadLocalSecurityContextHolderStrategy的实现策略基本一致，不同的是存储数据的载体变了，在InheritableThreadLocalSecurityContextHolderStrategy 中存储数据的载体变成了 InheritableThreadLocal。InheritableThreadLocal继承自ThreadLocaL但是多了一个特性，就是在子线程创建的一瞬间，会自动将父线程中的数据复制到子线程中。该存储策略正是利用了这一特性，实现了在子线程中获取登录用户信息的功能，</p><p>  最后再来看一下 GlobalSecurityContextHolderStrategy：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">GlobalSecurityContextHolderStrategy</span> <span class="keyword">implements</span> <span class="title class_">SecurityContextHolderStrategy</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SecurityContext contextHolder;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span> &#123;</span><br><span class="line">contextHolder = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> SecurityContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (contextHolder == <span class="literal">null</span>) &#123;</span><br><span class="line">contextHolder = <span class="keyword">new</span> <span class="title class_">SecurityContextImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> contextHolder;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">Assert.notNull(context, <span class="string">&quot;Only non-null SecurityContext instances are permitted&quot;</span>);</span><br><span class="line">contextHolder = context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> SecurityContext <span class="title function_">createEmptyContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecurityContextImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  GlobalSecurityContextHolderStrategy的实现就更简单了，用一个静态变量来保存 SecurityContext,所以它也可以在多线程环境下使用，但是一般在Web开发中，这种存储策略使用得较少。</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextHolder</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MODE_THREADLOCAL</span> <span class="operator">=</span> <span class="string">&quot;MODE_THREADLOCAL&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MODE_INHERITABLETHREADLOCAL</span> <span class="operator">=</span> <span class="string">&quot;MODE_INHERITABLETHREADLOCAL&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MODE_GLOBAL</span> <span class="operator">=</span> <span class="string">&quot;MODE_GLOBAL&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SYSTEM_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.security.strategy&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">strategyName</span> <span class="operator">=</span> System.getProperty(SYSTEM_PROPERTY);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SecurityContextHolderStrategy strategy;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">initializeCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">initialize();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span> &#123;</span><br><span class="line">strategy.clearContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SecurityContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> strategy.getContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getInitializeCount</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> initializeCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(strategyName)) &#123;</span><br><span class="line">strategyName = MODE_THREADLOCAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (strategyName.equals(MODE_THREADLOCAL)) &#123;</span><br><span class="line">strategy = <span class="keyword">new</span> <span class="title class_">ThreadLocalSecurityContextHolderStrategy</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (strategyName.equals(MODE_INHERITABLETHREADLOCAL)) &#123;</span><br><span class="line">strategy = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocalSecurityContextHolderStrategy</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (strategyName.equals(MODE_GLOBAL)) &#123;</span><br><span class="line">strategy = <span class="keyword">new</span> <span class="title class_">GlobalSecurityContextHolderStrategy</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(strategyName);</span><br><span class="line">Constructor&lt;?&gt; customStrategy = clazz.getConstructor();</span><br><span class="line">strategy = (SecurityContextHolderStrategy) customStrategy.newInstance();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">ReflectionUtils.handleReflectionException(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">initializeCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">strategy.setContext(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setStrategyName</span><span class="params">(String strategyName)</span> &#123;</span><br><span class="line">SecurityContextHolder.strategyName = strategyName;</span><br><span class="line">initialize();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SecurityContextHolderStrategy <span class="title function_">getContextHolderStrategy</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> strategy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SecurityContext <span class="title function_">createEmptyContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> strategy.createEmptyContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;SecurityContextHolder[strategy=&#x27;&quot;</span> + strategyName + <span class="string">&quot;&#x27;; initializeCount=&quot;</span></span><br><span class="line">+ initializeCount + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这段源码中可以看到，SecurityContextHolder定义了三个静态常量用来描述三种不同的存储策略；存储策略strategy会在静态代码块中进行初始化，根据不同的strategyName初始化不同的存储策略；strategyName变量表示目前正在使用的存储策略，开发者可以通过配置系统变量或者调用setStrategyName来修改SecurityContextHolder中的存储策略，调用 setStrategyName 后会重新初始化 strategy。</p><p>  默认情况下，如果开发者试图从子线程中获取当前登录用户数据，就会获取失败，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userinfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">        Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = authentication.getAuthorities();</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;authorities = &quot;</span>+authorities);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">                <span class="keyword">if</span> (authentication == <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取用户信息失败&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">                Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = authentication.getAuthorities();</span><br><span class="line">                <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                System.out.println(threadName+<span class="string">&quot;:name = &quot;</span>+name);</span><br><span class="line">                System.out.println(threadName+<span class="string">&quot;:authorities = &quot;</span> + authorities);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在子线程中尝试获取登录用户数据时，获取到的数据为null,如图2-15所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%885%EF%BC%89.png"></p><center>图 2-15</center><p>  子线程之所以获取不到登录用户信息，就是因为数据存储在ThreadLocal中，存储和读取不是同一个线程，所以获取不到。如果希望子线程中也能够获取到登录用户信息，可以将 SecurityContextHolder 中的存储策略改为 MODE INHERITABLETHREADLOCAL,这样就支持多线程环境下获取登录用户信息了。</p><p>  默认的存储策略是通过System.getProperty加载的，因此我们可以通过配置系统变量来修改默认的存储策略，以IntelliJ IDEA为例，首先单击启动按钮，选择Edit Configurations按钮, 如图2-16所示，然后在打开的选项中，配置VM options参数，添加如下一行，配置界面如图 2-17所示</p><p><code>  -Dspring.security.strategy=MODE_INHERITABLETHREADLOCAL </code></p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%886%EF%BC%89.png"></p><center>图 2-16</center><p><img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%887%EF%BC%89.png"></p><center>图 2-17</center><p>  这样，在SecurityContextHolder中通过System.getProperty加载到的默认存储策略就支持多线程环境了，</p><p>  配置完成之后，再次启动项目，此时访问&#x2F;user接口，即使在子线程中，也可以获取到登录用户信息了，如图2-18所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%888%EF%BC%89.png"></p><center>图 2-18</center><p>  那么既然SecurityContextHolder默认是将用户信息存储在 ThreadLocal中，在Spring Boot中不同的请求都是由不同的线程处理的，那为什么每一次请求都还能从SecurityContextHolder中获取到登录用户信息呢？这就不得不提到Spring Security过滤器链中重要—环 SecurityContextPersistenceFliter。</p><h3 id="1-1-2-SecurityContextPersistenceFilter"><a href="#1-1-2-SecurityContextPersistenceFilter" class="headerlink" title="1.1.2 SecurityContextPersistenceFilter"></a>1.1.2 SecurityContextPersistenceFilter</h3><p>  前面介绍了 Spring Security中的常见过滤器，在这些过滤器中，存在一个非常重要的过滤器就是 SecurityContextPersistenceFliter。</p><p>  默认情况下，在 Spring Security 过滤器链中，SecurityContextPersistenceFilter 是第一道防线，位于 WebAsyncManagerlntegrationFilter 之后。从 SecurityContextPersistenceFilter 这个过滤器的名字上就可以推断出来，它的作用是为了存储SecuntyContext而设计的。</p><p>  整体上来说，SecurityContextPersistenceFilter 主要做两件事情：</p><ul><li>当一个请求到来时，从 httpsSession 中获取 SecurityContext 并存入 SecurityContextHolder中，这样在同一个请求的后续处理过程中，开发者始终可以通过SeciuityContextHolder 获取到当前登录用户信息，</li><li>当一个请求处理完毕时，从SecurityContextHolder中获取SecuntyContext并存入 httpsSession中(主要针对异步Servlet),方便下一个请求到来时，再从httpsSession中拿出来使用，同时擦除SecurityContextHolder中的登录用户信息。</li></ul><p>  在SecurityContextPersistenceFilter 过滤器中，当一个请求处理完毕时，从SecurityContextHolder中获取SecurityContext 存入 httpsSession 中，这一步的操作主要是针对异步Servlet。如果不是异步Servlet,在响应提交时，就会将</p><p>SecurityContext 保存到httpsSession 中了，而不会等到在SecurityContextPersistenceFliter过滤器中再去存储。</p><p>  这就是SecurityContextPersistenceFliter大致上做的事情,在正式升始介绍SecurityContextPersistenceFilter 之前,需要先介绍另外接口，这就是 SecurityContextRepository接口，将 SecurityContext 存入 httpsSession,或者从 httpsSession 中加载数据并转为 SecurityContext对象，这些事情都是由SecurityContextRepositoiy接口的实现类完成的，因此这里我们 就先从 SecurityContextRepository 接口开始看起。首先我们来看一下SecurityContextRepository接口的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityContextRepository</span> &#123;</span><br><span class="line">SecurityContext <span class="title function_">loadContext</span><span class="params">(httpsRequestResponseHolder requestResponseHolder)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">saveContext</span><span class="params">(SecurityContext context, httpsServletRequest request,</span></span><br><span class="line"><span class="params">httpsServletResponse response)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsContext</span><span class="params">(httpsServletRequest request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SecurityContextRepository接口 中一共定义了三个方法：</p><ul><li>loadContext：这个方法用来加载SecurityContext 对象出来，对于没有登录的用户，这里会返回一个空的SecurityContext对象，注意空的SecurityContext对象是指SecurityContext 中不存在Authentication对象，而不是该方法返回null。</li><li>saveContext：该方法用来保存一个 SecurityContext 对象</li><li>containsContext：该方法可以判断SecurityContext对象是否存在。</li></ul><p>  在Spring Security框架中，为SecurityContextRepository接口一共提供了三个实现类，如图2-19所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%889%EF%BC%89.png"></p><center>图 2-19</center><p>  在这三个实现类中，TestSecurityContextRepository为单元测试提供支持；NullSecurityContextRepository 实现类中，loadContext 方法总是返回一个空的 SecurityContext 对象, saveContext方法未做任何实现，containsContext方法总是返回false ,所以 NullSecurityContextRepository 实现类实际上未做 SecurityContext 的存储工作，</p><p>  在 Spring Security 中默认使用的实现类是 httpsSessionSecurityContextRepository,通过 httpsSessionSecurityContextRepository实现了将 SecurityContext 存储到 httpsSession 以及从 httpsSession 中加载 SecurityContext出来，这里我们来重点看一下 httpsSessionSecurityContextRepository 类。</p><p>  在正式开始介绍 httpsSessionSecurityContextRepository之前，首先来看一下 httpsSessionSecurityContextRepository中定义的关于请求和封装的两个内部类。</p><p>  首先是 httpsSessionSecurityContextRepository中定义的对于响应的封装类 SaveToSessionResponseWrapper,我们先来看一下 SaveToSessionResponseWrapper的继承关系图，如图 2-20 所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%8810%EF%BC%89.png"></p><center>图 2-20</center><p>  从这幅继承关系图中可以看到，SaveToSessionResponseWrapper实际上就是我们所熟知的 httpsServletResponse功能的扩展。这里有三个关键的实现类：</p><ul><li><p>httpsServletResponseWrapper： httpsServletResponseWrapper 实现了httpsServletResponse 接口，它是httpsServletResponse的装饰类，利用httpsServletResponseWrapper可以方便地操作参数和输出流等。</p></li><li><p>OnCommittedResponseWrapper： OnCommittedResponseWrapper继承自httpsServletResponseWrapper对其功能进行了增强，最重要的增强在于可以获取httpsServletResponse的提交行为。当httpsServletResponse的 sendRedirect.flushBuffer.flush 以及 close 等方法被调用时，onResponseCommitted方法会被触发，开发者可以在onResponseCommitted方法中做一些数据保存操作，例如保存SecurityContext 不过OnCommittedResponseWrapper中的onResponseCommitted方法只是一个抽象方法，并没有具体的实现，具体的实现则在它的实现类 SaveContextOnUpdateOrErrorResponseWrapper中心</p></li><li><p>SaveContextOnUpdateOrErrorResponseWrapper：该类继承自OnCommittedResponseWrapper并对 onResponseCommitted方法做了实现由在SaveContextOnUpdateOrErrorResponseWrapper类中声明了一个contextSaved变量，表示SecurityContext是否已经存储成功，当httpsServletResponse 提交时，会调用 onResponseCommitted 方法，任 onResponseCommitted方法中调用 saveContext 方法，将 SecurityContext保存到 httpsSession 中，同时将 contextSaved 变量标记为true。 saveContext方法在这里也是一个抽象方法，具体的实现则在SaveToSessionResponseWrapper 类中。</p></li></ul><p>  接下来看一下 httpsSessionSecurityContextRepositoiy 中 SaveToSessionResponseWrapper 的定义：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SaveToSessionResponseWrapper</span> <span class="keyword">extends</span></span><br><span class="line"><span class="title class_">SaveContextOnUpdateOrErrorResponseWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> httpsServletRequest request;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> httpsSessionExistedAtStartOfRequest;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SecurityContext contextBeforeExecution;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Authentication authBeforeExecution;</span><br><span class="line">SaveToSessionResponseWrapper(httpsServletResponse response,</span><br><span class="line">httpsServletRequest request, <span class="type">boolean</span> httpsSessionExistedAtStartOfRequest,</span><br><span class="line">SecurityContext context) &#123;</span><br><span class="line"><span class="built_in">super</span>(response, disableUrlRewriting);</span><br><span class="line"><span class="built_in">this</span>.request = request;</span><br><span class="line"><span class="built_in">this</span>.httpsSessionExistedAtStartOfRequest = httpsSessionExistedAtStartOfRequest;</span><br><span class="line"><span class="built_in">this</span>.contextBeforeExecution = context;</span><br><span class="line"><span class="built_in">this</span>.authBeforeExecution = context.getAuthentication();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">saveContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> context.getAuthentication();</span><br><span class="line"><span class="type">httpsSession</span> <span class="variable">httpsSession</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (authentication == <span class="literal">null</span> || trustResolver.isAnonymous(authentication)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;SecurityContext is empty or contents are anonymous - context will not be stored in httpsSession.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (httpsSession != <span class="literal">null</span> &amp;&amp; authBeforeExecution != <span class="literal">null</span>) &#123;</span><br><span class="line">httpsSession.removeAttribute(springSecurityContextKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (httpsSession == <span class="literal">null</span>) &#123;</span><br><span class="line">httpsSession = createNewSessionIfAllowed(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (httpsSession != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (contextChanged(context)</span><br><span class="line">|| httpsSession.getAttribute(springSecurityContextKey) == <span class="literal">null</span>) &#123;</span><br><span class="line">httpsSession.setAttribute(springSecurityContextKey, context);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;SecurityContext &#x27;&quot;</span> + context</span><br><span class="line">+ <span class="string">&quot;&#x27; stored to httpsSession: &#x27;&quot;</span> + httpsSession);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">contextChanged</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> context != contextBeforeExecution</span><br><span class="line">|| context.getAuthentication() != authBeforeExecution;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> httpsSession <span class="title function_">createNewSessionIfAllowed</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (httpsSessionExistedAtStartOfRequest) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;httpsSession is now null, but was not null at start of request; &quot;</span></span><br><span class="line">+ <span class="string">&quot;session was invalidated, so do not create a new session&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!allowSessionCreation) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;The httpsSession is currently null, and the &quot;</span></span><br><span class="line">+ httpsSessionSecurityContextRepository.class.getSimpleName()</span><br><span class="line">+ <span class="string">&quot; is prohibited from creating an httpsSession &quot;</span></span><br><span class="line">+ <span class="string">&quot;(because the allowSessionCreation property is false) - SecurityContext thus not &quot;</span></span><br><span class="line">+ <span class="string">&quot;stored for next request&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (contextObject.equals(context)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;httpsSession is null, but SecurityContext has not changed from default empty context: &#x27; &quot;</span></span><br><span class="line">+ context</span><br><span class="line">+ <span class="string">&quot;&#x27;; not creating httpsSession or storing SecurityContext&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;httpsSession being created as SecurityContext is non-default&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> request.getSession(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;Failed to create a session, as response has been committed. Unable to store&quot;</span></span><br><span class="line">+ <span class="string">&quot; SecurityContext.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在 SaveToSessionResponseWrapper 中其实主要定义了三个方法：saveContext、contextChanged以及CreateNewSessionIfAllowed</p><ul><li>saveContext：该方法主要是用来保存 SecurityContext,如果 authentication 对象为 null 或者它是一个匿名对象，则不需要保存SecurityContext (参见SEC-776： <a href="httpss://github.com/%20spring-projects/spring-security/issues/1036">httpss:&#x2F;&#x2F;github.com&#x2F; spring-projects&#x2F;spring-security&#x2F;issues&#x2F;1036</a>)；同时，如果 httpsSession 不为 null 并且 authBeforeExecution也不为null,就从httpsSession中将保存的登录用户数据移除，这个主要是为了防止 开发者在注销成功的回调中继续调用doFilter方法，进而导致原始的登录信息无法清除的问题(参见 SEC-1587： <a href="httpss://github.com/spting-projects/spTing-secuTity/issues/1826">httpss:&#x2F;&#x2F;github.com&#x2F;spting-projects&#x2F;spTing-secuTity&#x2F;issues&#x2F;1826</a>)；如果 httpsSession为null,则去创建一个httpsSession对象；最后，如果SecurityContext发生了变化， 或者httpsSession中没有保存 SecurityContext,则调用 httpsSession 中的 setAttribute 方法将 SecurityContext保存起来。</li><li>contextChanged：该方法主要用来判断SecurityContext是否发生变化，因为在程序运行过程中_，_开者可能修改了 SecurityContext中的Authentication对象。</li><li>createNewSessionlfAllowed:  该方法用来创建一个 httpsSession 对象。</li></ul><p>  这就是 httpsSessionSecurityContextRepositoiy 中封装的 SaveToSessionResponseWrapper 对象，一个核心功能就是在httpsServletResponse提交的时候，将SecurityContext保存到httpsSession 中，</p><p>  接下来看—下 httpsSessionSecurityContextRepositoiy 中关于 SaveToSessionResponseWrapper 的定义，SaveToSessionResponseWrapper相对而言就要简单很多了:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Servlet3SaveToSessionRequestWrapper</span> <span class="keyword">extends</span></span><br><span class="line"><span class="title class_">httpsServletRequestWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SaveContextOnUpdateOrErrorResponseWrapper response;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Servlet3SaveToSessionRequestWrapper</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">SaveContextOnUpdateOrErrorResponseWrapper response)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(request);</span><br><span class="line"><span class="built_in">this</span>.response = response;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AsyncContext <span class="title function_">startAsync</span><span class="params">()</span> &#123;</span><br><span class="line">response.disableSaveOnResponseCommitted();</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.startAsync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AsyncContext <span class="title function_">startAsync</span><span class="params">(ServletRequest servletRequest,</span></span><br><span class="line"><span class="params">ServletResponse servletResponse)</span> <span class="keyword">throws</span> IllegalStateException &#123;</span><br><span class="line">response.disableSaveOnResponseCommitted();</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.startAsync(servletRequest, servletResponse);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  SaveToSessionRequestWrapper类实际上是在Spring Security 3.2之后出现的封装类，在 Spring Security 3.2 之前并不存在 SaveToSessionRequestWrapper 类。封装的 SaveToSessionRequestwrapper类主要作用是禁止在异步Servlet提交时，自动保存SecurityContext</p><p>  为什么要禁止呢？我们来看如下一段简单的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userinfo</span><span class="params">(httpsServletRequest req, httpsServletResponse resp)</span>&#123;</span><br><span class="line">    <span class="type">AsyncContext</span> <span class="variable">asyncContext</span> <span class="operator">=</span> req.startAsync();</span><br><span class="line">    CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> asyncContext.getResponse().getWriter();</span><br><span class="line">            out.write(<span class="string">&quot;hello buretuzi&quot;</span>);</span><br><span class="line">            asyncContext.complete();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，在异步Servlet中，当任务执行完毕之后，httpsServletResponse也会自动提交, 在提交的过程中会自动保存SecurityContext到httpsSession中，但是由于是在子线程中，因此无法获取到 SecurityContext 对象(SecurityContextHolder 默认将数据存储在 ThreadLocal 中)， 所以会保存失败。如果开发者使用了异步Servlet,则默认情况下会禁用httpsServletResponse 提交时自动保存SecurityContext这一功能，改为在SecurityContextPersistenceFilter过滤器中完成 SecurityContext 保存操作。</p><p>  看完了 httpsSessionSecurityContextRepositoiy中封装的两个请求&#x2F;响应对象之后，接下来我 们再来整体上看一下 httpsSessionSecurityContextRepositoiy 类的功能</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">httpsSessionSecurityContextRepository</span> <span class="keyword">implements</span> <span class="title class_">SecurityContextRepository</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPRING_SECURITY_CONTEXT_KEY</span> <span class="operator">=</span> <span class="string">&quot;SPRING_SECURITY_CONTEXT&quot;</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(<span class="built_in">this</span>.getClass());</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">contextObject</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">allowSessionCreation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">disableUrlRewriting</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isServlet3</span> <span class="operator">=</span> ClassUtils.hasMethod(ServletRequest.class, <span class="string">&quot;startAsync&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">springSecurityContextKey</span> <span class="operator">=</span> SPRING_SECURITY_CONTEXT_KEY;</span><br><span class="line"><span class="keyword">private</span> <span class="type">AuthenticationTrustResolver</span> <span class="variable">trustResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthenticationTrustResolverImpl</span>();</span><br><span class="line"><span class="keyword">public</span> SecurityContext <span class="title function_">loadContext</span><span class="params">(httpsRequestResponseHolder requestResponseHolder)</span> &#123;</span><br><span class="line"><span class="type">httpsServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> requestResponseHolder.getRequest();</span><br><span class="line"><span class="type">httpsServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> requestResponseHolder.getResponse();</span><br><span class="line"><span class="type">httpsSession</span> <span class="variable">httpsSession</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line"><span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> readSecurityContextFromSession(httpsSession);</span><br><span class="line"><span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;No SecurityContext was available from the httpsSession: &quot;</span></span><br><span class="line">+ httpsSession + <span class="string">&quot;. &quot;</span> + <span class="string">&quot;A new one will be created.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">context = generateNewContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SaveToSessionResponseWrapper</span> <span class="variable">wrappedResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SaveToSessionResponseWrapper</span>(</span><br><span class="line">response, request, httpsSession != <span class="literal">null</span>, context);</span><br><span class="line">requestResponseHolder.setResponse(wrappedResponse);</span><br><span class="line"><span class="keyword">if</span> (isServlet3) &#123;</span><br><span class="line">requestResponseHolder.setRequest(<span class="keyword">new</span> <span class="title class_">Servlet3SaveToSessionRequestWrapper</span>(</span><br><span class="line">request, wrappedResponse));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveContext</span><span class="params">(SecurityContext context, httpsServletRequest request,</span></span><br><span class="line"><span class="params">httpsServletResponse response)</span> &#123;</span><br><span class="line"><span class="type">SaveContextOnUpdateOrErrorResponseWrapper</span> <span class="variable">responseWrapper</span> <span class="operator">=</span> WebUtils</span><br><span class="line">.getNativeResponse(response,</span><br><span class="line">SaveContextOnUpdateOrErrorResponseWrapper.class);</span><br><span class="line"><span class="keyword">if</span> (responseWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line"><span class="string">&quot;Cannot invoke saveContext on response &quot;</span></span><br><span class="line">+ response</span><br><span class="line">+ <span class="string">&quot;. You must use the httpsRequestResponseHolder.response after invoking loadContext&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!responseWrapper.isContextSaved()) &#123;</span><br><span class="line">responseWrapper.saveContext(context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsContext</span><span class="params">(httpsServletRequest request)</span> &#123;</span><br><span class="line"><span class="type">httpsSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (session == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> session.getAttribute(springSecurityContextKey) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> SecurityContext <span class="title function_">readSecurityContextFromSession</span><span class="params">(httpsSession httpsSession)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">debug</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (httpsSession == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (debug) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;No httpsSession currently exists&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Object</span> <span class="variable">contextFromSession</span> <span class="operator">=</span> httpsSession.getAttribute(springSecurityContextKey);</span><br><span class="line"><span class="keyword">if</span> (contextFromSession == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (debug) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;httpsSession returned null object for SPRING_SECURITY_CONTEXT&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(contextFromSession <span class="keyword">instanceof</span> SecurityContext)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(springSecurityContextKey</span><br><span class="line">+ <span class="string">&quot; did not contain a SecurityContext but contained: &#x27;&quot;</span></span><br><span class="line">+ contextFromSession</span><br><span class="line">+ <span class="string">&quot;&#x27;; are you improperly modifying the httpsSession directly &quot;</span></span><br><span class="line">+ <span class="string">&quot;(you should always use SecurityContextHolder) or using the httpsSession attribute &quot;</span></span><br><span class="line">+ <span class="string">&quot;reserved for this class?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (debug) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Obtained a valid SecurityContext from &quot;</span></span><br><span class="line">+ springSecurityContextKey + <span class="string">&quot;: &#x27;&quot;</span> + contextFromSession + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (SecurityContext) contextFromSession;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> SecurityContext <span class="title function_">generateNewContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAllowSessionCreation</span><span class="params">(<span class="type">boolean</span> allowSessionCreation)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.allowSessionCreation = allowSessionCreation;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDisableUrlRewriting</span><span class="params">(<span class="type">boolean</span> disableUrlRewriting)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.disableUrlRewriting = disableUrlRewriting;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSpringSecurityContextKey</span><span class="params">(String springSecurityContextKey)</span> &#123;</span><br><span class="line">Assert.hasText(springSecurityContextKey,</span><br><span class="line"><span class="string">&quot;springSecurityContextKey cannot be empty&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.springSecurityContextKey = springSecurityContextKey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Servlet3SaveToSessionRequestWrapper</span> <span class="keyword">extends</span></span><br><span class="line"><span class="title class_">httpsServletRequestWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SaveContextOnUpdateOrErrorResponseWrapper response;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Servlet3SaveToSessionRequestWrapper</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">SaveContextOnUpdateOrErrorResponseWrapper response)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(request);</span><br><span class="line"><span class="built_in">this</span>.response = response;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AsyncContext <span class="title function_">startAsync</span><span class="params">()</span> &#123;</span><br><span class="line">response.disableSaveOnResponseCommitted();</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.startAsync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AsyncContext <span class="title function_">startAsync</span><span class="params">(ServletRequest servletRequest,</span></span><br><span class="line"><span class="params">ServletResponse servletResponse)</span> <span class="keyword">throws</span> IllegalStateException &#123;</span><br><span class="line">response.disableSaveOnResponseCommitted();</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.startAsync(servletRequest, servletResponse);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SaveToSessionResponseWrapper</span> <span class="keyword">extends</span></span><br><span class="line"><span class="title class_">SaveContextOnUpdateOrErrorResponseWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> httpsServletRequest request;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> httpsSessionExistedAtStartOfRequest;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SecurityContext contextBeforeExecution;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Authentication authBeforeExecution;</span><br><span class="line">SaveToSessionResponseWrapper(httpsServletResponse response,</span><br><span class="line">httpsServletRequest request, <span class="type">boolean</span> httpsSessionExistedAtStartOfRequest,</span><br><span class="line">SecurityContext context) &#123;</span><br><span class="line"><span class="built_in">super</span>(response, disableUrlRewriting);</span><br><span class="line"><span class="built_in">this</span>.request = request;</span><br><span class="line"><span class="built_in">this</span>.httpsSessionExistedAtStartOfRequest = httpsSessionExistedAtStartOfRequest;</span><br><span class="line"><span class="built_in">this</span>.contextBeforeExecution = context;</span><br><span class="line"><span class="built_in">this</span>.authBeforeExecution = context.getAuthentication();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">saveContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> context.getAuthentication();</span><br><span class="line"><span class="type">httpsSession</span> <span class="variable">httpsSession</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (authentication == <span class="literal">null</span> || trustResolver.isAnonymous(authentication)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;SecurityContext is empty or contents are anonymous - context will not be stored in httpsSession.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (httpsSession != <span class="literal">null</span> &amp;&amp; authBeforeExecution != <span class="literal">null</span>) &#123;</span><br><span class="line">httpsSession.removeAttribute(springSecurityContextKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (httpsSession == <span class="literal">null</span>) &#123;</span><br><span class="line">httpsSession = createNewSessionIfAllowed(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (httpsSession != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (contextChanged(context)</span><br><span class="line">|| httpsSession.getAttribute(springSecurityContextKey) == <span class="literal">null</span>) &#123;</span><br><span class="line">httpsSession.setAttribute(springSecurityContextKey, context);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;SecurityContext &#x27;&quot;</span> + context</span><br><span class="line">+ <span class="string">&quot;&#x27; stored to httpsSession: &#x27;&quot;</span> + httpsSession);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">contextChanged</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> context != contextBeforeExecution</span><br><span class="line">|| context.getAuthentication() != authBeforeExecution;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> httpsSession <span class="title function_">createNewSessionIfAllowed</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (httpsSessionExistedAtStartOfRequest) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;httpsSession is now null, but was not null at start of request; &quot;</span></span><br><span class="line">+ <span class="string">&quot;session was invalidated, so do not create a new session&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!allowSessionCreation) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;The httpsSession is currently null, and the &quot;</span></span><br><span class="line">+ httpsSessionSecurityContextRepository.class.getSimpleName()</span><br><span class="line">+ <span class="string">&quot; is prohibited from creating an httpsSession &quot;</span></span><br><span class="line">+ <span class="string">&quot;(because the allowSessionCreation property is false) - SecurityContext thus not &quot;</span></span><br><span class="line">+ <span class="string">&quot;stored for next request&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (contextObject.equals(context)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;httpsSession is null, but SecurityContext has not changed from default empty context: &#x27; &quot;</span></span><br><span class="line">+ context</span><br><span class="line">+ <span class="string">&quot;&#x27;; not creating httpsSession or storing SecurityContext&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;httpsSession being created as SecurityContext is non-default&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> request.getSession(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;Failed to create a session, as response has been committed. Unable to store&quot;</span></span><br><span class="line">+ <span class="string">&quot; SecurityContext.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTrustResolver</span><span class="params">(AuthenticationTrustResolver trustResolver)</span> &#123;</span><br><span class="line">Assert.notNull(trustResolver, <span class="string">&quot;trustResolver cannot be null&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.trustResolver = trustResolver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先通过 SPRING_SECURITY_CONTEXT_KEY 变量定义了 SecurityContext 在 httpsSession中存储的key,如果开发者需要手动操作httpsSession中存储的SecurityContext,可以通过该key来操作。</li><li>trustResolver是一个用户身份评估器，用来判断当前用户是匿名用户还是通过 RememberMe登录的用户。</li><li>在 loadContext 方法中，通过调用 readSecurityContextFromSession 方法来获取 SecurityContext对象，如果获取到的对象为null,则调用generateNewContext方法去生成一个空的SecurityContext对象，最后构造请求和响应的装饰类并存入requestResponseHolder对象中。</li><li>saveContext方法用来保存SecurityContext,在保存之前，会先调用isContextSaved 方法判断是否已经保存了，如果已经保存了，则不再保存，正常情况下，在httpsServletResponse 提交时SecurityContext就已经保存到httpsSession中；如果是异步Servlet,则提交时不会自动将SecurityContext保存到httpsSession,此时会在这里进行保存操作。</li><li>containsContext方法用来判断请求中是否存在SecurityContext对象。</li><li>readSecurityContextFromSession 方法执行具体的 SecurityContext 读取逻辑，从 httpsSession 中获取 SecurityContext 并返回。</li><li>generateNewContext 方法用来生成一个不包含 Authentication 的空的 SecurityContext 对象。</li><li>setAllowSessionCreation方法用来设置是否允许创建httpsSession,默认是true。</li><li>setDisableUrlRewriting方法表示是否禁用URL重写，默认是false。</li><li>setSpringSecurityContextKey 方法可以用来配置 httpsSession 中存储 SecurityContext 的 key。</li><li>isTransientAuthentication 方法用来判断 Authentication 是否免于存储。</li><li>setTrustResolver方法用来配置身份评估器。</li></ol><p>  这就是httpsSessionSecurityContextRepositoiy所提供的所有功能，这些功能都将在 SecurityContextPersistenceFilter过滤器中进行调用，那么接下来我们就来看一下SecurityContextPersistenceFilter中的调用逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextPersistenceFilter</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILTER_APPLIED</span> <span class="operator">=</span> <span class="string">&quot;__spring_security_scpf_applied&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> SecurityContextRepository repo;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">forceEagerSessionCreation</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SecurityContextPersistenceFilter</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">httpsSessionSecurityContextRepository</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SecurityContextPersistenceFilter</span><span class="params">(SecurityContextRepository repo)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.repo = repo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="type">httpsServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (httpsServletRequest) req;</span><br><span class="line"><span class="type">httpsServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (httpsServletResponse) res;</span><br><span class="line"><span class="keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="literal">null</span>) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">debug</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line">request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line"><span class="keyword">if</span> (forceEagerSessionCreation) &#123;</span><br><span class="line"><span class="type">httpsSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"><span class="keyword">if</span> (debug &amp;&amp; session.isNew()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Eagerly created session: &quot;</span> + session.getId());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">httpsRequestResponseHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">httpsRequestResponseHolder</span>(request,</span><br><span class="line">response);</span><br><span class="line"><span class="type">SecurityContext</span> <span class="variable">contextBeforeChainExecution</span> <span class="operator">=</span> repo.loadContext(holder);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="type">SecurityContext</span> <span class="variable">contextAfterChainExecution</span> <span class="operator">=</span> SecurityContextHolder</span><br><span class="line">.getContext();</span><br><span class="line">SecurityContextHolder.clearContext();</span><br><span class="line">repo.saveContext(contextAfterChainExecution, holder.getRequest(),</span><br><span class="line">holder.getResponse());</span><br><span class="line">request.removeAttribute(FILTER_APPLIED);</span><br><span class="line"><span class="keyword">if</span> (debug) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;SecurityContextHolder now cleared, as request processing completed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setForceEagerSessionCreation</span><span class="params">(<span class="type">boolean</span> forceEagerSessionCreation)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.forceEagerSessionCreation = forceEagerSessionCreation;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤器的核心方法当然是doFilter,我们就从doFilter方法开始介绍：</p><ol><li>首先从request中获取FILTER_APPLIED属性，如果该属性值不为null则直接执行doFilter方法，当前过滤器到此为止，这个判断主要是确保该请求只执行一次该过滤 器，如果确实是该request第一次经过该过滤器，则给其设置上FILTER_APPLIED属性。</li><li>forceEagerSessionCreation变量表示是否要在过滤器链执行之前确保会话有效，由于这是一个比较耗费资源的操作，因此默认为false,</li><li>构造 httpsRequestResponseHolder 对象，将 httpsServletRequest 和 httpsServletResponse 都存储进去。</li><li>调用loadContext方法去加载SecurityContext, repo实际上就是我们前面所说 httpsSessionSecurityContextRepository 的实例，所以 loadContext 方法这里就不再赘述了。</li><li>将读取到的SecurityContext存入SecurityContextHolder之中,这样，在接下来的处理逻辑中，开发者就可以直接通过SecurityContextHolder获取当前登录用户对象了。</li><li>调用doFilter方法使请求继续向下走，但是要注意，此时传递的request和 response 对象是在 httpsSessionSecurityContextRepositoiy 中封装后的对象，即 SaveToSessionResponseWrapper 和 SaveToSessionRequestWrapper 的实例。</li><li>当请求处理完毕后，在finally模块中，获取最新的SecurityContext对象(开发者可能在后续处理中修改了SecurityContext中的Authentication对象)，然后清空SecurityContextHolder中的数据；再调用saveContext方法保存SecurityContext,具体的保存逻辑前面已经说过，这里就不再赘述了。</li><li>最后，从 request 中移除 FILTER_APPLIED 属性。</li></ol><p>  这就是整个SecurityContextPersistenceFilter过滤器的工作逻辑。一言以蔽之，请求在到达 SecurityContextPersistenceFilter 过滤器之后，先从 httpsSession 中读取 SecurityContext 出来，并存入SecurityContextHolder之中以备后续使用；当请求离开 SecurityContextPersisteiiceFilter过滤器的时候，获取最新的SecurityContext并存入httpsSession中，同时清空SecurityContextHolder中的登录用户信息。</p><p>  这就是第一种登录数据的获取方式，即从SecurityContextHolder中获取。</p><h2 id="1-2-从当前请求对象中获取"><a href="#1-2-从当前请求对象中获取" class="headerlink" title="1.2 从当前请求对象中获取"></a>1.2 从当前请求对象中获取</h2><p>  接下来我们来看一下第二种登录数据获取方式——从当前请求中获取。获取代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/authentication&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">authentication</span><span class="params">(Authentication authentication)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Authentication = &quot;</span>  + authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/principal&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">principal</span><span class="params">(Principal principal)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Principal = &quot;</span> + principal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  开发者可以直接在Controller的请求参数中放入Authentication对象来获取登录用户信息。 通过前面的讲解，大家已经知道Authentication是Principal的子类，所以也可以直接在请求参数中放入Principal来接收当前登录用户信息，需要注意的是，即使参数是Principal，真正的实例依然是Authentication的实例。</p><p>  用过Spring MVC的读者都知道，Controller中方法的参数都是当前请求httpsServletRequest 带来的。毫无疑问，前面的Authentication和Principal参数也都是httpsServletRequest带来的， 那么这些数据到底是何时放入httpsServletRequest的呢？又是以何种形式存在的呢？接下来我 们一起分析一下，</p><p>  在Servlet规范中，最早有三个和安全管理相关的方法：</p><p><code>public String getRemoteUser();</code></p><p><code>public boolean isUserlnRole(String role);</code></p><p><code>public java.security.Principal getUserPrincipal();</code></p><ol><li>getRemoteUser方法用来获取登录用户名_。_</li><li>isUserlnRole方法用来判断当前登录用户是否具备某一个指定的角色。</li><li>getUserPrincipal方法用来获取当前认证主体。</li></ol><p>  从Servlet 3.0开始，在这三个方法的基础之上，又增加了三个和安全管理相关的方法：</p><p><code>public boolean authenticate(httpsServletRespouse response)</code></p><p><code>throws lOException, ServletException;</code></p><p><code>public void login(String username, String password) throws ServletException;</code></p><p><code>public void logout() throws ServletException</code></p><ol><li>authenticate方法可以判断当前请求是否认证成功。</li><li>login方法可以执行登录操作。</li><li>logout方法可以执行注销操作。</li></ol><p>  不过httpsServletRequest只是一个接口，这些安全认证相关的方法，在不同环境下会有不同的实现。</p><p>  如果是一个普通的Web项目 ,不使用任何框架,httpsServletRequest的默认实现类是Tomcat 中的RequestFacade,从这个类的名字上就可以看出来，这是一个使用了 Facade模式(外观模式)的类，真正提供底层服务的是Tomcat中的Request对象，只不过这个Request对象在实现 Servlet规范的同时，还定义了很多Tomcat内部的方法，为了避免开发者直接调用到这些内部方法，这里使用了外观模式。</p><p>  在Tomcat的Request类中，对上面这些方法都做了实现，基本上都是基于Tomcat提供的 Realm来实现的，这种认证方式非常冷门，项目中很少使用，因此这里不做过多介绍，感兴趣 的读者可以查看 <a href="httpss://github.com/lenve/javaboy-code-samples">httpss:&#x2F;&#x2F;github.com&#x2F;lenve&#x2F;javaboy-code-samples</a> 仓库中的 basiclogin 案例来了解 其用法。</p><p>如果使用了 Spring Security框架，那么我们在Controller参数中拿到的httpsServletRequest 实例将是 Servlet3SecurityContextHolderAwareRequestWrapper,很明显，这是被 Spring Security 封装过的请求，</p><p>我们来看一下 Servlet3SecurityContextHolderAwareRequestWrapper 的继承关系，如图 2-21 所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%8811%EF%BC%89.png"></p><center>图 2-21</center><p>  httpsServletRequestWrapper 就不用过多介绍了 , SecurityContextHolderAwareRequestWrapper类主要实现了 Servlet 3.0之前和安全管理相关的三个方法，也就是getRemoteUser()、isUserlnRole(String)以及getUserPrincipal，Servlet 3.0中新增的三个安全管理相关的方法， 则在Servlet3SecurityContextHolderAwareRequestWrapper类中实现心获取用户登录信息主要和前面三个方法有关，因此这里我们主要来看一下SecurityContextHolderAwareRequestWrapper 类中相关方法的实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextHolderAwareRequestWrapper</span> <span class="keyword">extends</span> <span class="title class_">httpsServletRequestWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AuthenticationTrustResolver trustResolver;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String rolePrefix;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SecurityContextHolderAwareRequestWrapper</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">String rolePrefix)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(request, <span class="keyword">new</span> <span class="title class_">AuthenticationTrustResolverImpl</span>(), rolePrefix);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SecurityContextHolderAwareRequestWrapper</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">AuthenticationTrustResolver trustResolver, String rolePrefix)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(request);</span><br><span class="line">Assert.notNull(trustResolver, <span class="string">&quot;trustResolver cannot be null&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.rolePrefix = rolePrefix;</span><br><span class="line"><span class="built_in">this</span>.trustResolver = trustResolver;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Authentication <span class="title function_">getAuthentication</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"><span class="keyword">if</span> (!trustResolver.isAnonymous(auth)) &#123;</span><br><span class="line"><span class="keyword">return</span> auth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getRemoteUser</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> getAuthentication();</span><br><span class="line"><span class="keyword">if</span> ((auth == <span class="literal">null</span>) || (auth.getPrincipal() == <span class="literal">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (auth.getPrincipal() <span class="keyword">instanceof</span> UserDetails) &#123;</span><br><span class="line"><span class="keyword">return</span> ((UserDetails) auth.getPrincipal()).getUsername();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> auth.getPrincipal().toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Principal <span class="title function_">getUserPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> getAuthentication();</span><br><span class="line"><span class="keyword">if</span> ((auth == <span class="literal">null</span>) || (auth.getPrincipal() == <span class="literal">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> auth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGranted</span><span class="params">(String role)</span> &#123;</span><br><span class="line"><span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> getAuthentication();</span><br><span class="line"><span class="keyword">if</span> (rolePrefix != <span class="literal">null</span> &amp;&amp; role != <span class="literal">null</span> &amp;&amp; !role.startsWith(rolePrefix)) &#123;</span><br><span class="line">role = rolePrefix + role;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((auth == <span class="literal">null</span>) || (auth.getPrincipal() == <span class="literal">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = auth.getAuthorities();</span><br><span class="line"><span class="keyword">if</span> (authorities == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (GrantedAuthority grantedAuthority : authorities) &#123;</span><br><span class="line"><span class="keyword">if</span> (role.equals(grantedAuthority.getAuthority())) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUserInRole</span><span class="params">(String role)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> isGranted(role);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;SecurityContextHolderAwareRequestWrapper[ &quot;</span> + getRequest() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SecurityContextHolderAwareRequestWrapper 类其实非常好理解:</p><ol><li>getAuthentication：该方法用来获取当前登录对象Authentication,获取方式就是我们前面所讲的从SecurityContextHolder中获取。如果不是匿名对象就返回，否则就返回null。</li><li>getRemoteUser：该方法返回了当前登录用户的用户名，如果Authentication对象中存储的Principal是当前登录用户对象，则返回用户名；如果Authentication对象中存储的 Principal是当前登录用户名(字符串)，则直接返回即可。</li><li>getUserPrincipaL该方法返回当前登录用户对象，其实就是Authentication的实例。</li><li>isGranted：该方法是一个私有方法，作用是判断当前登录用户是否具备某一个指定的角色。判断逻辑也很简单，先对传入进来的角色进行预处理，有的情况下可能需要添加ROLE_前缀，角色前缀的问题在后面的章节中会做详细介绍，这里先不做过多的展开。 然后调用Authentication#getAuthorities方法，获取当前登录用户所具备的所有角色，最后再和 传入进来的参数进行比较，</li><li>isUserlnRole：该方法调用isGranted方法，进而实现判断当前用户是否具备某一个 指定角色的功能。</li></ol><p>看到这里，相信你己经明白了，在使用了 Spring Security之后，我们通过 httpsServletRequest就可以获取到很多当前登录用户信息了，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(httpsServletRequest req)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">remoteUser</span> <span class="operator">=</span> req.getRemoteUser();</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> (Authentication) req.getUserPrincipal();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">admin</span> <span class="operator">=</span> req.isUserInRole(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;remoteUser = &quot;</span>+remoteUser);</span><br><span class="line">    System.out.println(<span class="string">&quot;auth.getName() = &quot;</span>+auth.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;admin = &quot;</span> +admin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  执行该方法，打印结果如下：</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%8812%EF%BC%89.png"></p><p>  前面我们直接将Authentication或者Principal写到Controller参数中，实际上就是Spring MVC 框架从 Seivlet3SecurityContextHolderAwareRequestWrapper 中提取的用户信息。</p><p>  那么Spring Security是如何将默认的请求对象转化为Servlet3SecurityContextHolderAwareRequestwrapper的呢？这就涉及Spring Security过滤器链中另外一个重要的过滤器———————————————SecurityContextHolderAwareRequestFilter。</p><p>  前面我们提到 Spring Security 过滤器中，有一个 SecurityContextHolderAwareRequestFilter 过滤器，该过滤器的主要作用就是对httpsServletRequest请求进行再包装，重写 httpsServletRequest中和安全管理相关的方法心httpsSeivletRequest在整个请求过程中会被包装 多次，每一次的包装都会给它增添新的功能，例如在经过SecurityContextPersistenceFilter请求 时就会对它进行包装。</p><p>  我们来看一下 SecurityContextHolderAwareRequestFilter 过滤器的源码(部分):</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextHolderAwareRequestFilter</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">rolePrefix</span> <span class="operator">=</span> <span class="string">&quot;ROLE_&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> httpsServletRequestFactory requestFactory;</span><br><span class="line"><span class="keyword">private</span> AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line"><span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"><span class="keyword">private</span> List&lt;LogoutHandler&gt; logoutHandlers;</span><br><span class="line"><span class="keyword">private</span> <span class="type">AuthenticationTrustResolver</span> <span class="variable">trustResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthenticationTrustResolverImpl</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRolePrefix</span><span class="params">(String rolePrefix)</span> &#123;</span><br><span class="line">Assert.notNull(rolePrefix, <span class="string">&quot;Role prefix must not be null&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.rolePrefix = rolePrefix;</span><br><span class="line">updateFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthenticationEntryPoint</span><span class="params">(</span></span><br><span class="line"><span class="params">AuthenticationEntryPoint authenticationEntryPoint)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.authenticationEntryPoint = authenticationEntryPoint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthenticationManager</span><span class="params">(AuthenticationManager authenticationManager)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.authenticationManager = authenticationManager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLogoutHandlers</span><span class="params">(List&lt;LogoutHandler&gt; logoutHandlers)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.logoutHandlers = logoutHandlers;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">chain.doFilter(<span class="built_in">this</span>.requestFactory.create((httpsServletRequest) req,</span><br><span class="line">(httpsServletResponse) res), res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"><span class="built_in">super</span>.afterPropertiesSet();</span><br><span class="line">updateFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateFactory</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">rolePrefix</span> <span class="operator">=</span> <span class="built_in">this</span>.rolePrefix;</span><br><span class="line"><span class="built_in">this</span>.requestFactory = isServlet3() ? createServlet3Factory(rolePrefix)</span><br><span class="line">: <span class="keyword">new</span> <span class="title class_">httpsServlet25RequestFactory</span>(<span class="built_in">this</span>.trustResolver, rolePrefix);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTrustResolver</span><span class="params">(AuthenticationTrustResolver trustResolver)</span> &#123;</span><br><span class="line">Assert.notNull(trustResolver, <span class="string">&quot;trustResolver cannot be null&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.trustResolver = trustResolver;</span><br><span class="line">updateFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> httpsServletRequestFactory <span class="title function_">createServlet3Factory</span><span class="params">(String rolePrefix)</span> &#123;</span><br><span class="line"><span class="type">httpsServlet3RequestFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">httpsServlet3RequestFactory</span>(rolePrefix);</span><br><span class="line">factory.setTrustResolver(<span class="built_in">this</span>.trustResolver);</span><br><span class="line">factory.setAuthenticationEntryPoint(<span class="built_in">this</span>.authenticationEntryPoint);</span><br><span class="line">factory.setAuthenticationManager(<span class="built_in">this</span>.authenticationManager);</span><br><span class="line">factory.setLogoutHandlers(<span class="built_in">this</span>.logoutHandlers);</span><br><span class="line"><span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isServlet3</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ClassUtils.hasMethod(ServletRequest.class, <span class="string">&quot;startAsync&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从这段源码中可以看到，在 SecurityCoutextHolderAwareRequestFilter#doFilter 方法中，会 调用 requestFactory.create 方法对请求重新进行包装，requestFactory 就是 httpsServletRequestFactoiry 类的实例，它的 create 方法里边就直接创建 了一个 Servlet3SecurityContextHolderAwareRequestwrapper 实例。</p><p>对请求的httpsServletRequest包装之后，接下来在过滤器链中传递的httpsServletRequest对 象，它的 getRemoteUser()、isUserlnRole(String)以及 getUserPrincipal()方法就可以直接使用 了，</p><p>httpsServletRequest 中 getUserPrincipal()方法有了返回值之后，最终在 Spring MVC 的 ServletRequestMethodArgumentResolvei#resolveArgument(Class&lt;?&gt;, httpsServletRequest)方法中进行默认参数解析，自动解析出Principal对象，开发者在Controller中既可以通过Principal 来接收参数，也可以通过Authentication对象来接收。</p><p>经过前面的介绍，相信对于Spring Security中两种获取登录用户信息的方式，以及这两种获取方式的原理，都有一定的了解了，</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security登录表单配置（3）</title>
      <link href="/2022/08/02/Spring%20Security%E7%99%BB%E5%BD%95%E8%A1%A8%E5%8D%95%E9%85%8D%E7%BD%AE%EF%BC%883%EF%BC%89/"/>
      <url>/2022/08/02/Spring%20Security%E7%99%BB%E5%BD%95%E8%A1%A8%E5%8D%95%E9%85%8D%E7%BD%AE%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-登录表单配置"><a href="#1-登录表单配置" class="headerlink" title="1. 登录表单配置"></a>1. 登录表单配置</h1><h2 id="1-1-快速入门"><a href="#1-1-快速入门" class="headerlink" title="1.1 快速入门"></a>1.1 快速入门</h2><p>理解了入门案例之后，接下来我们再来看一下登录表单的详细配置，首先创建一个新的Spring Boot项目，引入Web和Spring Security依赖，代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  项目创建好之后，为了方便测试，需要在application.yml中添加如下配置，将登录用户名和密码固定下来：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">buretuzi</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>  接下来，我们在resources&#x2F;static目录下创建一个login.html页而，这个是我们自定义的登录页面：</p><p>查看代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bootstrap-css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#login</span> <span class="selector-class">.container</span> <span class="selector-id">#login-row</span> <span class="selector-id">#login-column</span> <span class="selector-id">#login-box</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#9c9c9c</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#EAEAEA</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-row&quot;</span> <span class="attr">class</span>=<span class="string">&quot;row justify-content-center align-items-center&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-column&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-6&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-box&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-12&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;login-form&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/dologin&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;text-center text-info&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-info&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uname&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-info&quot;</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-info btn-md&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  这个logmt.html中的核心内容就是一个登录表单，登录表单中有三个需要注意的地方，</p><ul><li><p>form的action，这里给的是&#x2F;doLogin，表示表单要提交到&#x2F;doLogin接口上。</p></li><li><p>用户名输入框的name属性值为uname,当然这个值是可以自定义的，这里采用了uname。</p></li><li><p>密码输入框的name属性值为passwd, passwd也是可以自定义的。</p></li></ul><p>login.html定义好之后，接下来定义两个测试接口，作为受保护的资源。当用户登录成功 后，就可以访问到受保护的资源。接口定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  最后再提供一个Spring Security的配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.httpsSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/loginNew.html&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/index&quot;</span>)</span><br><span class="line">                .failureUrl(<span class="string">&quot;/loginNew.html&quot;</span>)</span><br><span class="line">                .usernameParameter(<span class="string">&quot;uname&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在Spring Security中，如果我们需要自定义配置，基本上都是继承自WebSecurityConfigurerAdapter来实现的，当然WebSecurityConfigurerAdapter本身的配置还是比较复杂，同时也是比较丰富的，这里先不做过多的展开，仅就结合上面的代码来解释，在下节中将会对这里的配置再做更加详细的介绍。</p><ul><li>首先configure方法中是一个链式配置，当然也可以不用链式配置，每一个属性配置完毕后再从重新开始写起</li><li>authorizeRequests()方法表示开启权限配置(该方法的含义其实比较复杂，在后面还会再次介绍该方法)，.anyRequest().authenticated()表示所有的请求都要认证之后才能访问.</li><li>有的读者会对and()方法表示疑惑，and()方法会返回httpsSecurityBuilder对象的一个 子类(实际上就是httpsSecurity),所以and()方法相当于又回到httpsSecurity实例，重新开启 新一轮的配置。如果觉得and()方法很难理解，也可以不用and()方法, 在.anyRequest().authenticated。配置完成后直接用分号(;)结束，然后通过https.formLogin()继续配置表单登录。</li><li>formLogin()表示开启表单登录配置，loginPage用来配置登录页面地址； loginProcessingUrl用来配置登录接口地址；defaultSuccessUrl表示登录成功后的跳转地址； failureUrl表示登录失败后的跳转地址；usernameParameter表示登录用户名的参数名称； passwordParameter表示登录密码的参数名称；permitAll表示跟登录相关的页面和接口不做拦截, 直接通过。需要注意的是,loginProcessingUrl、usernameParameter、passwordParameter 需要和login-html中登录表单的配置一致。</li><li>最后的csrf().disable()表示禁用CSRF防御功能，Spring Security自带了 CSRF防御机制，但是我们这里为了测试方便，先将CSRF防御机制关闭，在后面将会详细介绍CSRF攻击与防御问题。</li></ul><p>  配置完成后，启动Spring Boot项目,浏览器地址栏中输入<a href="https://localhost:8080/iiidex,%e4%bc%9a">https://localhost:8080/index，</a>会自动跳转到<a href="https://localhost:8080/loginNew.html%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%A6%82%E5%9B%BE2-5%E6%89%80%E7%A4%BA%E3%80%82%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E8%BF%9B%E8%A1%8C%E7%99%BB%E5%BD%95">https://localhost:8080/loginNew.html页面，如图2-5所示。输入用户名和密码进行登录</a>(用 户名为buretuzi,密码为123456),登录成功之后，就可以访问到index页面了，如图2-6所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E8%A1%A8%E5%8D%95%E9%85%8D%E7%BD%AE%EF%BC%883%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><center>图2-5</center><p><img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E8%A1%A8%E5%8D%95%E9%85%8D%E7%BD%AE%EF%BC%883%EF%BC%89%EF%BC%882%EF%BC%89.png"></p><center>图2-6</center><p>  经过上面的配置，我们已经成功自定义了一个登录页面出来，用户在登录成功之后，就可以访问受保护的资源了。</p><h2 id="1-2-配置细节"><a href="#1-2-配置细节" class="headerlink" title="1.2 配置细节"></a>1.2 配置细节</h2><p>  当然，前面的配置比较粗糙，这里还有一些配置的细节需要和读者分享一下。</p><p>  在前面的配置中，我们用defaultSuccessUrl表示用户登录成功后的跳转地址，用failureUrl 表示用户登录失败后的跳转地址。关于登录成功和登录失败，除了这两个方法可以配置之外, 还有另外两个方法也可以配置。</p><h3 id="1-2-1-登录成功"><a href="#1-2-1-登录成功" class="headerlink" title="1.2.1 登录成功"></a>1.2.1 登录成功</h3><p>当用户登录成功之后，除了 defaultSuccessUrl方法可以实现登录成功后的跳转之外， successForwardUrl也可以实现登录成功后的跳转，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/loginNew.html&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .successForwardUrl(<span class="string">&quot;/index&quot;</span>)</span><br><span class="line">                .failureUrl(<span class="string">&quot;/loginNew.html&quot;</span>)</span><br><span class="line">                .usernameParameter(<span class="string">&quot;uname&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defaultSuccessUrl 和 successForwardUrl 的区别如下：</p><ul><li>defaultSuccessUrl表示当用户登录成功之后，会自动重定向到登录之前的地址上， 如果用户本身就是直接访问的登录页面，则登录成功后就会重定向到defaultSuccessUrl指定的页面中。例如，用户在未认证的情况下，访问了&#x2F;hello页面，此时会自动重定向到登录页面， 当用户登录成功后，就会自动重定向到&#x2F;hello页面；而用户如果一开始就访问登录页面，则登录成功后就会自动重定向到defaultSuccessUrl所指定的页面中，</li><li>successForwardUrl则不会考虑用户之前的访问地址，只要用户登录成功，就会通过服务器端跳转到successForwardUrl所指定的页面</li><li>defaultSuccessUrl有一个重载方法，如果重载方法的第二个参数传入true,则 defaultSuccessUrl的效果与successForwardUrl类似，即不考虑用户之前的访问地址，只要登录成功_,_就重定向到defaultSuccessUrl所指定的页面。不同之处在于，defaultSuccessUrl是通过重定向实现的跳转(客户端跳转)，successForwardUrl则是通过服务器端跳转实现的。</li></ul><p>无论是 defaultSuccessUrl 还是 successForwardUrl，最终所配置的都是 AuthenticationSuccessHandler接口的实例。</p><p>Spring Security中专门提供了 AuthenticationSuccessHandler接口用来处理登录成功事项：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">httpsServletResponse response, FilterChain chain, Authentication authentication)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException&#123;</span><br><span class="line">onAuthenticationSuccess(request, response, authentication);</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">httpsServletResponse response, Authentication authentication)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由上述代码可以看到，AuthenticationSuccessHandler接口中一共定义了两个方法，其中一 个是default方法，此方法是Spring Security 5.2开始加入进来的，在处理特定的认证请求 AuthenticationFilter中会用到；另外一个非default方法，则用来处理登录成功的具体事项，其 中request和response参数好理解，authentication参数保存了登录成功的用户信息。我们将在后面的章节中详细介绍authentication参数。</p><p>  AuthenticationSuccessHandler接口共有三个实现类，如图2-7所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E8%A1%A8%E5%8D%95%E9%85%8D%E7%BD%AE%EF%BC%883%EF%BC%89%EF%BC%883%EF%BC%89.png"></p><center>图2-7</center><p>（1） SimpleUrlAuthenticationSuccessHandler继承自 AbstractAuthenticationTargetUrlRequestHandler，通过 AbstractAuthenticationTargetUrlRequestHandler 中的 handle 方法实现请求重定向。</p><p> （2）SavedRequestAwareAuthenticationSuccessHandler在 SimpleUrlAuthenticationSuccessHandler的基础上增加了请求缓存的功能，可以记录之前请求的地址，进而在登录成功后重定向到一开始访问的地址。</p><p> （3） ForwardAuthenticationSuccessHandler的实现则比较容易，就是一个服务端跳转。</p><p>  我们来重点分析 SavedRequestAwareAuthenticationSuccessHandler和ForwardAuthenticationSuccessHandler的实现。</p><p>  当通过defaultSuccessUrl来设置登录成功后重定向的地址时，实际上对应的实现类就是 SavedRequestAwareAuthenticationSuccessHandler。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SavedRequestAwareAuthenticationSuccessHandler</span> <span class="keyword">extends</span></span><br><span class="line"><span class="title class_">SimpleUrlAuthenticationSuccessHandler</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(<span class="built_in">this</span>.getClass());</span><br><span class="line"><span class="keyword">private</span> <span class="type">RequestCache</span> <span class="variable">requestCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">httpsSessionRequestCache</span>();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">httpsServletResponse response, Authentication authentication)</span></span><br><span class="line"><span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="type">SavedRequest</span> <span class="variable">savedRequest</span> <span class="operator">=</span> requestCache.getRequest(request, response);</span><br><span class="line"><span class="keyword">if</span> (savedRequest == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">super</span>.onAuthenticationSuccess(request, response, authentication);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">targetUrlParameter</span> <span class="operator">=</span> getTargetUrlParameter();</span><br><span class="line"><span class="keyword">if</span> (isAlwaysUseDefaultTargetUrl()</span><br><span class="line">|| (targetUrlParameter != <span class="literal">null</span> &amp;&amp; StringUtils.hasText(request</span><br><span class="line">.getParameter(targetUrlParameter)))) &#123;</span><br><span class="line">requestCache.removeRequest(request, response);</span><br><span class="line"><span class="built_in">super</span>.onAuthenticationSuccess(request, response, authentication);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">clearAuthenticationAttributes(request);</span><br><span class="line"><span class="comment">// Use the DefaultSavedRequest URL</span></span><br><span class="line"><span class="type">String</span> <span class="variable">targetUrl</span> <span class="operator">=</span> savedRequest.getRedirectUrl();</span><br><span class="line">logger.debug(<span class="string">&quot;Redirecting to DefaultSavedRequest Url: &quot;</span> + targetUrl);</span><br><span class="line">getRedirectStrategy().sendRedirect(request, response, targetUrl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRequestCache</span><span class="params">(RequestCache requestCache)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.requestCache = requestCache;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心方法就是onAuthenticationSuccess:</p><ul><li>首先从requestcache中获取缓存下来的请求，如果没有获取到缓存请求，就说明用户在访问登录页面之前并没有访问其他页面，此时直接调用父类的onAuthenticationSuccess方法来处理_，_最终会重定向到defaultSuccessUrl指定的地址。</li><li>接下来会获取一个targetUrlParameter,这个是用户显式指定的、希望登录成功后重定向的地址，例如用户发送的登录请求是<a href="https://localhost:8080/doLogin?target=/hello,%E8%BF%99%E5%B0%B1%E8%A1%A8%E7%A4%BA%E5%BD%93%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%B8%8C%E6%9C%9B%E8%87%AA%E5%8A%A8%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0/hello%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8CgetTargetUrlParameter%E5%B0%B1%E6%98%AF%E8%A6%81%E8%8E%B7%E5%8F%96%E9%87%8D%E5%AE%9A%E5%90%91%E5%9C%B0%E5%9D%80%E5%8F%82%E6%95%B0%E7%9A%84key,%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%B8%8A%E9%9D%A2%E7%9A%84target,%E6%8B%BF%E5%88%B0target%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E5%88%B0%E9%87%8D%E5%AE%9A%E5%90%91%E5%9C%B0%E5%9D%80%E4%BA%86%E3%80%82">https://localhost:8080/doLogin?target=/hello,这就表示当用户登录成功之后，希望自动重定向到/hello这个接口，getTargetUrlParameter就是要获取重定向地址参数的key,也就是上面的target,拿到target之后，就可以获取到重定向地址了。</a></li><li>如果 targetUrlParameter 存在，或者用户设置了 alwaysUseDefaultTargetUrl 为 true, 这个时候缓存下来的请求就没有意义了。此时会直接调用父类的onAuthenticationSuccess方法完成重定向， targetUrlParameter存在，则直接重定向到targetUrlParameter指定的地址；alwaysUseDefaultTargetUrl 为 true,则直接重定向到 defaultSuccessUrl 指定的地址；如果 targetUrlParameter 存在并且 alwaysUseDefaultTargetUrl 为 true,则重定向到 defaultSuccessUrl 指定的地址。</li><li>如果前面的条件都不满足，那么最终会从缓存请求savedRequest中获取重定向地址, 然后进行重定向操作。</li></ul><p>  这就是SavedRequestAwareAuthenticationSuccessHandler的实现逻辑，升发者也可以配置 自己的 SavedRequestAwareAuthenticationSuccessHandler,代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/loginNew.html&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .successForwardUrl(<span class="string">&quot;/index&quot;</span>)</span><br><span class="line">                .failureUrl(<span class="string">&quot;/loginNew.html&quot;</span>)</span><br><span class="line">                .usernameParameter(<span class="string">&quot;uname&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">    SavedRequestAwareAuthenticationSuccessHandler <span class="title function_">successHandler</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">SavedRequestAwareAuthenticationSuccessHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SavedRequestAwareAuthenticationSuccessHandler</span>();</span><br><span class="line">        handler.setDefaultTargetUrl(<span class="string">&quot;/index&quot;</span>);</span><br><span class="line">        handler.setTargetUrlParameter(<span class="string">&quot;target&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意在配置时指定了 targetUrlParameter为target,这样用户就可以在登录请求中，通过 target来指定跳转地址了，然后我们修改一下前面login.html中的form表单：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;login-form&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/doLogin?target=/hello&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;text-center text-info&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-info&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uname&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-info&quot;</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-info btn-md&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  在form表单中，action修改&#x2F;doLogin?target&#x3D;&#x2F;hello,这样当用户登录成功之后，就始终跳转到&#x2F;hello接口了。</p><p>  当我们通过successForwardUrl来设置登录成功后重定向的地址时，实际上对应的实现类 就是 ForwardAuthenticationSuccessHandler，ForwardAuthenticationSuccessHandler 的源码特别简单，就是一个服务端转发，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForwardAuthenticationSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String forwardUrl;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ForwardAuthenticationSuccessHandler</span><span class="params">(String forwardUrl)</span> &#123;</span><br><span class="line">Assert.isTrue(UrlUtils.isValidRedirectUrl(forwardUrl),</span><br><span class="line">() -&gt; <span class="string">&quot;&#x27;&quot;</span> + forwardUrl + <span class="string">&quot;&#x27; is not a valid forward URL&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.forwardUrl = forwardUrl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(httpsServletRequest request, httpsServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">request.getRequestDispatcher(forwardUrl).forward(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由上述代码可以看到，主要功能就是调用getRequestDispatcher方法进行服务端转发。 AuthenticationSuccessHandler默认的三个实现类，无论是哪一个，都是用来处理页面跳转的，有时候页面跳转并不能满足我们的需求，特别是现在流行的前后端分离开发中，用户登录成功后，就不再需要页面跳转了，只需要给前端返回一个JSON数据即可，告诉前端登录成功还是登录失败，前端收到消息之后自行处理。像这样的需求，我们可以通过自定义 AuthenticationSuccessHandler 的实现类来完成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationSuccessHandler;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.https.httpsServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.https.httpsServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(</span></span><br><span class="line"><span class="params">            httpsServletRequest request, httpsServletResponse response, Authentication authentication)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        Map&lt;String,Object&gt; resp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">        resp.put(<span class="string">&quot;status&quot;</span>,<span class="number">200</span>);</span><br><span class="line">        resp.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> om.writeValueAsString(resp);</span><br><span class="line">        response.getWriter().write(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在自定义的 MyAuthenticationSuccessHandler中，重写 onAuthenticationSuccess方法，在该方法中，通过httpsServletResponse对象返回一段登录成功的JSON字符串给前端即可。最后， 在 SecurityConfig中配置自定义的 MyAuthenticationSuccessHandler，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/loginNew.html&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .successHandler(<span class="keyword">new</span> <span class="title class_">MyAuthenticationSuccessHandler</span>())</span><br><span class="line">                .failureUrl(<span class="string">&quot;/loginNew.html&quot;</span>)</span><br><span class="line">                .usernameParameter(<span class="string">&quot;uname&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  配置完成后，重启项目，此时，当用户成功登录之后，就不会进行页面跳转了，而是返回一段JSON字符串。</p><p><img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E8%A1%A8%E5%8D%95%E9%85%8D%E7%BD%AE%EF%BC%883%EF%BC%89%EF%BC%884%EF%BC%89.png"></p><h3 id="1-2-2-登录失败"><a href="#1-2-2-登录失败" class="headerlink" title="1.2.2 登录失败"></a>1.2.2 登录失败</h3><p>接下来看登录失败的处理逻辑。为了方便在前端页面展示登录失败的异常信息，我们首先在项目的pom.xml文件中引入thymeleaf依赖，代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  然后在resources&#x2F;templates目录下新建mylogin.html，代码如下：</p><p>查看代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;https://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bootstrap-css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#login</span> <span class="selector-class">.container</span> <span class="selector-id">#login-row</span> <span class="selector-id">#login-column</span> <span class="selector-id">#login-box</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#9c9c9c</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#EAEAEA</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-row&quot;</span> <span class="attr">class</span>=<span class="string">&quot;row justify-content-center align-items-center&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-column&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-6&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-box&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-12&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;login-form&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/doLogin?target=/hello&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;text-center text-info&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;SPRING SECURITY LAST EXCEPTION&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-info&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uname&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-info&quot;</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-info btn-md&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  mylogin.html和前面的login.html基本类似，前面的login.html是静态页面，这里的 mylogin.html是thymeleaf模板页面，mylogin.html页面在form中多了一个div,用来展示登录失败时候的异常信息，登录失败的异常信息会放在request中返回到前端，开发者可以将其直接提取岀来展示。</p><p>  既然mylogm.html是动态页面，就不能像静态页面那样直接访问了，需要我们给mylogin.html页面提供一个访问控制器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLoginController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/mylogin.html&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">myLogin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;mylogin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  最后再在SecurityConfig中配置登录页面，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/index.html&quot;</span>)</span><br><span class="line">                .failureUrl(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                .usernameParameter(<span class="string">&quot;uname&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  failureUrl表示登录失败后重定向到mylogin.html页面。重定向是一种客户端跳转，重定向不方便携带请求失败的异常信息(只能放在URL中)。</p><p>  如果希望能够在前端展示请求失败的异常信息，可以使用下面这种方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/index.html&quot;</span>)</span><br><span class="line">                .failureForwardUrl(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                .usernameParameter(<span class="string">&quot;uname&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  failureForwardUrl方法从名字上就可以看出，这种跳转是一种服务器端跳转，服务器端跳转的好处是可以携带登录异常信息，如果登录失败，自动跳转回登录页面后，就可以将错误信息展示出来，如图2-8所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E8%A1%A8%E5%8D%95%E9%85%8D%E7%BD%AE%EF%BC%883%EF%BC%89%EF%BC%885%EF%BC%89.png"></p><center>图2-8</center><p>  无论是 failureUrl 还是 failureForwardUrl,最终所配置的都是 AuthenticationFailureHandler 接口的实现。Spring Security中提供了 AuthenticationFailureHandler 接口，用来规范登录失败的 实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationFailureHandler</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">httpsServletResponse response, AuthenticationException exception)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  AuthenticationFailureHandler 接口中只有一个 onAuthenticationFailure 方法，用来处理登录 失败请求，request和response参数很好理解，最后的exception则表示登录失败的异常信息。 Spring Security 中为 AuthenticationFailureHandler 一共提供了五个实现类_，_如图 2-9 所示</p><p><img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E8%A1%A8%E5%8D%95%E9%85%8D%E7%BD%AE%EF%BC%883%EF%BC%89%EF%BC%886%EF%BC%89.png"></p><center>图2-9</center><ul><li>SimpleUrlAuthenticationFailureHandler默认的处理逻辑就是通过重定向跳转到登录页 面，当然也可以通过配置forwardToDestination属性将重定向改为服务器端跳转，failureUrl方法的底层实现逻辑就是 SimpleUrlAuthenticationFailureHandler。</li><li>ExceptionMappingAuthenticationFailureHandler可以实现根据不同的异常类型，映射到不同的路径</li><li>ForwardAuthenticationFailureHandler表示通过服务器端跳转来重新回到登录页面， failureForwardUrl 方法的底层实现逻辑就是 ForwardAuthenticationFailureHandler。</li><li>AuthenticationEntryPointFailureHandler是 Spring Security 5.2 新引进的处理类，可以 通过AuthenticationEntryPoint来处理登录异常。</li><li>DelegatingAuthenticationFailureHandler可以实现为不同的异常类型配置不同的登录失败处理回调。</li></ul><p>  这里举一个简单的例子。假如不使用failureForwardUrl 方法，同时又想在登录失败后通过服务器端跳转回到登录页面，那么可以自定义SimpleUrlAuthenticationFailureHandler配置，并将forwardToDestination属性设置为true,代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/index.html&quot;</span>)</span><br><span class="line">                .failureHandler(failureHandler())</span><br><span class="line">                .usernameParameter(<span class="string">&quot;uname&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">    SimpleUrlAuthenticationFailureHandler <span class="title function_">failureHandler</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">SimpleUrlAuthenticationFailureHandler</span> <span class="variable">handler</span> <span class="operator">=</span> </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SimpleUrlAuthenticationFailureHandler</span>(<span class="string">&quot;/mylogin.html&quot;</span>);</span><br><span class="line">        handler.setUseForward(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这样配置之后，如果用户再次登录失败，就会通过服务端跳转重新回到登录页面，登录页而也会展示相应的错误信息，效果和failureForwardUrl 一致。</p><p>SimpleUrlAuthenticationFailureHandler的源码也很简单，我们一起来看一下实现逻辑(源码比较长，这里列出来核心部分):</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleUrlAuthenticationFailureHandler</span> <span class="keyword">implements</span></span><br><span class="line"><span class="title class_">AuthenticationFailureHandler</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(getClass());</span><br><span class="line"><span class="keyword">private</span> String defaultFailureUrl;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">forwardToDestination</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">allowSessionCreation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">RedirectStrategy</span> <span class="variable">redirectStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultRedirectStrategy</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SimpleUrlAuthenticationFailureHandler</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SimpleUrlAuthenticationFailureHandler</span><span class="params">(String defaultFailureUrl)</span> &#123;</span><br><span class="line">setDefaultFailureUrl(defaultFailureUrl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">httpsServletResponse response, AuthenticationException exception)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (defaultFailureUrl == <span class="literal">null</span>) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;No failure URL set, sending 401 Unauthorized error&quot;</span>);</span><br><span class="line"></span><br><span class="line">response.sendError(httpsStatus.UNAUTHORIZED.value(),</span><br><span class="line">httpsStatus.UNAUTHORIZED.getReasonPhrase());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">saveException(request, exception);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (forwardToDestination) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Forwarding to &quot;</span> + defaultFailureUrl);</span><br><span class="line"></span><br><span class="line">request.getRequestDispatcher(defaultFailureUrl)</span><br><span class="line">.forward(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Redirecting to &quot;</span> + defaultFailureUrl);</span><br><span class="line">redirectStrategy.sendRedirect(request, response, defaultFailureUrl);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">saveException</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">AuthenticationException exception)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (forwardToDestination) &#123;</span><br><span class="line">request.setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">httpsSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (session != <span class="literal">null</span> || allowSessionCreation) &#123;</span><br><span class="line">request.getSession().setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION,</span><br><span class="line">exception);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDefaultFailureUrl</span><span class="params">(String defaultFailureUrl)</span> &#123;</span><br><span class="line">Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultFailureUrl),</span><br><span class="line">() -&gt; <span class="string">&quot;&#x27;&quot;</span> + defaultFailureUrl + <span class="string">&quot;&#x27; is not a valid redirect URL&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.defaultFailureUrl = defaultFailureUrl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isUseForward</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> forwardToDestination;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUseForward</span><span class="params">(<span class="type">boolean</span> forwardToDestination)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.forwardToDestination = forwardToDestination;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从这段源码中可以看到，当用户构造SimpleUrlAuthenticationFailureHandler对象的时候， 就传入了 defaultFailureUrl也就是登录失败时要跳转的地址。在onAuthenticationFailure方法中，如果发现defaultFailureUrl为null,则直接通过response返回异常信息，否则调用 saveException 方法。在 saveException 方法中，如果 fowardToDestination 属性设置为ture，表示通过服务器端跳转回到登录页面，此时就把异常信息放到request中。再回到 onAuthenticationFailure方法中，如果用户设置fowardToDestination 为 true,就通过服务器 端跳转回到登录页面，否则通过重定向回到登录页面。</p><p>  如果是前后端分离开发，登录失败时就不需要页面跳转了，只需要返回JSON字符串给前端即可，此时可以通过自定义AuthenticationFailureHandler的实现类来完成，代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationFailureHandler;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.https.httpsServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.https.httpsServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationFailureHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationFailureHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(</span></span><br><span class="line"><span class="params">            httpsServletRequest request, httpsServletResponse response, AuthenticationException exception)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        Map&lt;String,Object&gt; resp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">        resp.put(<span class="string">&quot;status&quot;</span>,<span class="number">500</span>);</span><br><span class="line">        resp.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;登录失败&quot;</span>+exception.getMessage());</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> om.writeValueAsString(resp);</span><br><span class="line">        response.getWriter().write(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  然后在SecurityConfig中进行配置即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.handler.MyAuthenticationFailureHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.httpsSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/index.html&quot;</span>)</span><br><span class="line">                .failureHandler(<span class="keyword">new</span> <span class="title class_">MyAuthenticationFailureHandler</span>())</span><br><span class="line">                .usernameParameter(<span class="string">&quot;uname&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  配置完成后，当用户再次登录失败，就不会进行页而跳转了，而是直接返回JSON字符串, 如图2-10所示。</p><p><img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E8%A1%A8%E5%8D%95%E9%85%8D%E7%BD%AE%EF%BC%883%EF%BC%89%EF%BC%887%EF%BC%89.png"></p><center>图2-10</center><h3 id="1-2-3-注销登录"><a href="#1-2-3-注销登录" class="headerlink" title="1.2.3 注销登录"></a>1.2.3 注销登录</h3><p>Spring Security中提供了默认的注销页面，当然开发者也可以根据自己的需求对注销登录进行定制。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/index.html&quot;</span>)</span><br><span class="line">                .failureHandler(<span class="keyword">new</span> <span class="title class_">MyAuthenticationFailureHandler</span>())</span><br><span class="line">                .usernameParameter(<span class="string">&quot;uname&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                .logoutUrl(<span class="string">&quot;/logout&quot;</span>)</span><br><span class="line">                .invalidatehttpsSession(<span class="literal">true</span>)</span><br><span class="line">                .clearAuthentication(<span class="literal">true</span>)</span><br><span class="line">                .logoutSuccessUrl(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过.logout()方法开启注销登录配置。</li><li>logoutUrl指定了注销登录请求地址，默认是GET请求，路径为&#x2F;logout。</li><li>invalidatehttpsSession 表示是否使 session 失效，默认为 true。</li><li>clearAuthentication表示是否清除认证信息，默认为true。</li><li>logoutSuccessUrl表示注销登录后的跳转地址。</li></ul><p>  配置完成后，再次启动项目_，_登录成功后，在浏览器中输入<a href="https://localhost:8080/logout%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%8F%91%E8%B5%B7%E6%B3%A8%E9%94%80%E7%99%BB%E5%BD%95%E8%AF%B7%E6%B1%82%E4%BA%86%EF%BC%8C%E6%B3%A8%E9%94%80%E6%88%90%E5%8A%9F%E5%90%8E%EF%BC%8C%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%B7%B3%E8%BD%AC%E5%88%B0mylogin.html%E9%A1%B5%E9%9D%A2%E3%80%82">https://localhost:8080/logout就可以发起注销登录请求了，注销成功后，会自动跳转到mylogin.html页面。</a></p><p>  如果项目有需要，开发者也可以配置多个注销登录的请求，同时还可以指定请求的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.demo.handler.MyAuthenticationFailureHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.httpsSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.util.matcher.AntPathRequestMatcher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.util.matcher.OrRequestMatcher;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/index.html&quot;</span>)</span><br><span class="line">                .failureHandler(<span class="keyword">new</span> <span class="title class_">MyAuthenticationFailureHandler</span>())</span><br><span class="line">                .usernameParameter(<span class="string">&quot;uname&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                .logoutRequestMatcher(<span class="keyword">new</span> <span class="title class_">OrRequestMatcher</span>(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout1&quot;</span>,<span class="string">&quot;GET&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout2&quot;</span>,<span class="string">&quot;POST&quot;</span>)))</span><br><span class="line">                .invalidatehttpsSession(<span class="literal">true</span>)</span><br><span class="line">                .clearAuthentication(<span class="literal">true</span>)</span><br><span class="line">                .logoutSuccessUrl(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个配置表示注销请求路径有两个：</p><ul><li>第一个是&#x2F;logout1,请求方法是GET。</li><li>第二个是&#x2F;logout2,请求方法是POST。</li></ul><p>使用任意一个请求都可以完成登录注销。</p><p>如果项目是前后端分离的架构，注销成功后就不需要页面跳转了，只需将注销成功的信息返回给前端即可，此时我们可以自定义返回内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/index.html&quot;</span>)</span><br><span class="line">                .failureHandler(<span class="keyword">new</span> <span class="title class_">MyAuthenticationFailureHandler</span>())</span><br><span class="line">                .usernameParameter(<span class="string">&quot;uname&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                .logoutRequestMatcher(<span class="keyword">new</span> <span class="title class_">OrRequestMatcher</span>(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout1&quot;</span>,<span class="string">&quot;GET&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout2&quot;</span>,<span class="string">&quot;POST&quot;</span>)))</span><br><span class="line">                .invalidatehttpsSession(<span class="literal">true</span>)</span><br><span class="line">                .clearAuthentication(<span class="literal">true</span>)</span><br><span class="line">                .logoutSuccessHandler((req,resp,auth)-&gt;&#123;</span><br><span class="line">                    resp.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">                    Map&lt;String,Object&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">                    result.put(<span class="string">&quot;status&quot;</span>,<span class="number">200</span>);</span><br><span class="line">                    result.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;注销成功！&quot;</span>);</span><br><span class="line">                    <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> om.writeValueAsString(result);</span><br><span class="line">                    resp.getWriter().write(s);</span><br><span class="line">                &#125;)</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  配置 logoutSuccessHandler 和 logoutSuccessUrl 类似于前面所介绍的 successHandler 和defaultSuccessUrl之间的关系，只是类不同而已，因此这里不再赘述，读者可以按照我们前面的分析思路自行分析。</p><p>  配置完成后，重启项目，登录成功后再去注销登录，无论是使用&#x2F;logout1还是&#x2F;logout2进行注销，只要注销成功后，就会返回一段JSON字符串。</p><p>  如果开发者希望为不同的注销地址返回不同的结果，也是可以的，配置如下：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/mylogin.html&quot;</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/doLogin&quot;</span>)</span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/index.html&quot;</span>)</span><br><span class="line">                .failureHandler(<span class="keyword">new</span> <span class="title class_">MyAuthenticationFailureHandler</span>())</span><br><span class="line">                .usernameParameter(<span class="string">&quot;uname&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;passwd&quot;</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                .logoutRequestMatcher(<span class="keyword">new</span> <span class="title class_">OrRequestMatcher</span>(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout1&quot;</span>,<span class="string">&quot;GET&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout2&quot;</span>,<span class="string">&quot;POST&quot;</span>)))</span><br><span class="line">                .invalidatehttpsSession(<span class="literal">true</span>)</span><br><span class="line">                .clearAuthentication(<span class="literal">true</span>)</span><br><span class="line">                .defaultLogoutSuccessHandlerFor((req,resp,auth)-&gt;&#123;</span><br><span class="line">                    resp.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">                    Map&lt;String,Object&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">                    result.put(<span class="string">&quot;status&quot;</span>,<span class="number">200</span>);</span><br><span class="line">                    result.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;使用logout1注销成功！&quot;</span>);</span><br><span class="line">                    <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> om.writeValueAsString(result);</span><br><span class="line">                    resp.getWriter().write(s);</span><br><span class="line">                &#125;,<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout1&quot;</span>,<span class="string">&quot;GET&quot;</span>))</span><br><span class="line">                .defaultLogoutSuccessHandlerFor((req,resp,auth)-&gt;&#123;</span><br><span class="line">                    resp.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">                    Map&lt;String,Object&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">                    result.put(<span class="string">&quot;status&quot;</span>,<span class="number">200</span>);</span><br><span class="line">                    result.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;使用logout2注销成功！&quot;</span>);</span><br><span class="line">                    <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> om.writeValueAsString(result);</span><br><span class="line">                    resp.getWriter().write(s);</span><br><span class="line">                &#125;,<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout1&quot;</span>,<span class="string">&quot;GET&quot;</span>))</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  通过defaultLogoutSuccessHandlerFor方法可以注册多个不同的注销成功回调函数，该方法第一个参数是注销成功回调，第二个参数则是具体的注销请求。当用户注销成功后，使用了哪个注销请求，就给出对应的响应信息。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security基本认证（2）</title>
      <link href="/2022/08/02/Spring%20Security%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%EF%BC%882%EF%BC%89/"/>
      <url>/2022/08/02/Spring%20Security%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>  对于安全管理框架而言，认证功能可以说是一切的起点，所以我们要研究Spring Security, 就要从最基本的认证开始。在Spring Security中，对认证功能做了大量的封装，以至于开发者只需要稍微配置一下就能使用认证功能，然而要深刻理解其源码却并非易事。本文从最基本的用法开始讲解，最终再扩展到对源码的理解。</p><p>本章涉及的主要知识点有：</p><ul><li>Spring Security 基本认证。</li><li>登录表单配置。</li><li>登录用户数据获取。</li><li>用户的四种定义方式。</li></ul><h1 id="1-Spring-Security-基本认证"><a href="#1-Spring-Security-基本认证" class="headerlink" title="1.Spring Security 基本认证"></a>1.Spring Security 基本认证</h1><h2 id="1-1-快速入门"><a href="#1-1-快速入门" class="headerlink" title="1.1 快速入门"></a>1.1 快速入门</h2><p>在Spring Boot项目中使用Spring Security非常方便，创建一个新的Spring Boot项目，我 们只需要引入Web和Spring Security依赖即可，具体代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  然后我们在项目中提供一个用于测试的&#x2F;hello接口，代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello spring security&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  接下来启动项目，&#x2F;hello接口就已经被自动保护起来了。当用户访问&#x2F;hello接口时，会自动跳转到登录页面，如图所示，用户登录成功后，才能访问到&#x2F;hello接口。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%EF%BC%882%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><p>  默认的登录用户名是user,登录密码则是一个随机生成的UUID字符串，在项目启动日志中可以看到登录密码（这也意味着项目每次启动时，密码都会发生变化）:</p><p>  Using generated security password: 8ef9c800-17cf-47a3-9984-8ff936db6dd8</p><p>  输入默认的用户名和密码，就可以成功登录了，这就是Spring Security的强大之处，只需要引入一个依赖，所有的接口就会被自动保护起来。</p><h2 id="1-2-流程分析"><a href="#1-2-流程分析" class="headerlink" title="1.2 流程分析"></a>1.2 流程分析</h2><p>  通过一个简单的流程图来看一下上面案例中的请求流程，如下图所示</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%EF%BC%882%EF%BC%89%EF%BC%882%EF%BC%89.png"></p><p>流程图比较清晰地说明了整个请求过程：</p><ul><li>客户端(浏览器)发起请求去访问&#x2F;hello接口，这个接口默认是需要认证之后才能访问的。</li><li>这个请求会走一遍Spring Security中的过滤器链，在最后的FilterSecurityInterceptor 过滤器中被拦截下来，因为系统发现用户未认证。请求拦截下来之后，接下来会抛出 AccessDeniedException 异常。</li><li>抛出的 AccessDeniedException 异常在 ExceptionTranslationFilter 过滤器中被捕获， ExceptionTranslationFilter 过滤器通过调用 LoginUrlAuthenticationEntiyPoint#commence 方法给客户端返回302,要求客户端重定向到&#x2F;login页面。</li><li>客户端发送&#x2F;login请求。</li><li>&#x2F;login请求被DefaultLoginPageGeneratingFilter过滤器拦截下来，并在该过滤器中返 回登录页面。所以当用户访问&#x2F;hello接口时会首先看到登录页面。</li></ul><p>  在整个过程中，相当于客户端一共发送了两个请求，第一个请求是&#x2F;hello,服务端收到之 后，返回302,要求客户端重定向到&#x2F;login,于是客户端又发送了&#x2F;login请求。现在去理解上面这一个流程图可能还有些困难，等学完后面的内容之后，再回过头来看这个流程图，应该就会比较清晰了。</p><h2 id="1-3-原理分析"><a href="#1-3-原理分析" class="headerlink" title="1.3 原理分析"></a>1.3 原理分析</h2><p>  幵启Spring Security自动化配置，开启后，会自动创建一个名为springSecurityFilterChain 的过滤器，并注入到Spring容器中，这个过滤器将负责所有的安全管理，包括用户的认证、授权_、_重定向到登录页面等(springSecmityFilterChain实际上代理了 Spring Security中的过滤器链)。</p><ul><li>创建一个UserDetailsSeivice实例,UserDetailsService负责提供用户数据，默认的用户数据是基于内存的用户，用户名为user,密码则是随机生成的UUID字符串。</li><li>给用户生成一个默认的登录页面。</li><li>幵启CSRF攻击防御。</li><li>开启会话固定攻击防御。</li><li>集成 X-XSS-Protection</li><li>集成X-Frame-Options以防止单击劫持。</li></ul><p>  这里涉及的细节还是非常多的，登录的细节会在后面详细介绍，这里主要分析一下默认用户的生成以及默认登录页面的生成</p><h3 id="1-3-1-默认用户生成"><a href="#1-3-1-默认用户生成" class="headerlink" title="1.3.1 默认用户生成"></a>1.3.1 默认用户生成</h3><p>Spring Security中定义了 UserDetails接口来规范开发者自定义的用户对象，这样方便一些旧系统、用户表己经固定的系统集成到Spring Security认证体系中。</p><p>  UserDetails接口定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetails</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line">String <span class="title function_">getPassword</span><span class="params">()</span>;</span><br><span class="line">String <span class="title function_">getUsername</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  该接口中一共定义了 7个方法：</p><ul><li>getAuthorities方法：返回当前账户所具备的权限。</li><li>getPassword方法：返回当前账户的密码。</li><li>getUsemame方法：返回当前账户的用户名。</li><li>isAccountNonExpired方法：返回当前账户是否未过期。</li><li>isAccountNonLocked方法：返回当前账户是否未锁定。</li><li>isCredentialsNonExpired方法：返回当前账户凭证(如密码)是否未过期。</li><li>isEnabled方法：返回当前账户是否可用。</li></ul><p>这是用户对象的定义，而负责提供用户数据源的接口是UserDetailsService , UserDetailsService中只有一个查询用户的方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  loadUserByUsername有一个参数是username,这是用户在认证时传入的用户名，最常见的就是用户在登录表单中输入的用户名（实际开发时还可能存在其他情况，例如使用CAS单点登录时，username并非表单输入的用户名，而是CAS Server认证成功后回调的用户名参数）, 开发者在这里拿到用户名之后，再去数据库中査询用户，最终返回一个UserDetails实例。</p><p>  在实际项目中，一般需要开发者自定义UserDetailsService的实现。如果开发者没有自定义 UserDetailsService 的实现，Spring Security 也为 UserDetailsService 提供了默认实现，如下图</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%EF%BC%882%EF%BC%89%EF%BC%883%EF%BC%89.png"></p><ul><li>UserDetailsManager在UserDetailsService的基础上，继续定义了添加用户、更新用户、 删除用户、修改密码以及判断用户是否存在共5种方法。</li><li>JdbcDaoImpl在UserDetailsService的基础上，通过spring-jdbc实现了从数据库中查询用户的方法。</li><li>InMemoryUserDetailsManager 实现了 UserDetailsManager 中关于用户的增删改查方法，不过都是基于内存的操作，数据并没有持久化。</li><li>JdbcUserDetailsManager 继承自 JdbcDaoImpl 同时又实现了 UserDetailsManager接口，因此可以通过JdbcUserDetailsManager实现对用户的增删改查操作，这些操作都会持久化到数据库中。不过JdbcUserDetailsManager有一个局限性，就是操作数据库中用户的SQL 都是提前写好的，不够灵活，因此在实际开发中JdbcUserDetailsManager使用并不多。</li><li>CachingUserDetailsSeivice 的特点是会将 UserDetailsService 缓存起来。</li><li>UserDetailsServiceDelegator 则是提供了 UserDetailsService 的懒加载功能</li><li>ReactiveUserDetailsServiceAdapter 是 webflux-web-security 模块定义的 UserDetailsService 实现。</li></ul><p>  当我们使用Spring Security时，如果仅仅只是引入一个Spring Security依赖，则默认使用的用户就是由 InMemoryUserDetailsManager 提供的。</p><p>  大家知道,Spring Boot之所以能够做到零配置使用Spring Security,就是因为它提供了众多的自动化配置类，其中，针对UserDetailsService的自动化配置类是UserDetailsServiceAuto Configurationr这个类的源码并不长，我们一起来看一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(AuthenticationManager.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(ObjectPostProcessor.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">value = &#123; AuthenticationManager.class, AuthenticationProvider.class, UserDetailsService.class &#125;,</span></span><br><span class="line"><span class="meta">type = &#123; &quot;org.springframework.security.oauth2.jwt.JwtDecoder&quot;,</span></span><br><span class="line"><span class="meta">&quot;org.springframework.security.oauth2.server.resource.introspection.OpaqueTokenIntrospector&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NOOP_PASSWORD_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;&#123;noop&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">PASSWORD_ALGORITHM_PATTERN</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^\\&#123;.+&#125;.*$&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(UserDetailsServiceAutoConfiguration.class);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">type = &quot;org.springframework.security.oauth2.client.registration.ClientRegistrationRepository&quot;)</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> InMemoryUserDetailsManager <span class="title function_">inMemoryUserDetailsManager</span><span class="params">(SecurityProperties properties,</span></span><br><span class="line"><span class="params">ObjectProvider&lt;PasswordEncoder&gt; passwordEncoder)</span> &#123;</span><br><span class="line">SecurityProperties.<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> properties.getUser();</span><br><span class="line">List&lt;String&gt; roles = user.getRoles();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(</span><br><span class="line">User.withUsername(user.getName()).password(getOrDeducePassword(user, passwordEncoder.getIfAvailable()))</span><br><span class="line">.roles(StringUtils.toStringArray(roles)).build());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getOrDeducePassword</span><span class="params">(SecurityProperties.User user, PasswordEncoder encoder)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line"><span class="keyword">if</span> (user.isPasswordGenerated()) &#123;</span><br><span class="line">logger.info(String.format(<span class="string">&quot;%n%nUsing generated security password: %s%n&quot;</span>, user.getPassword()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (encoder != <span class="literal">null</span> || PASSWORD_ALGORITHM_PATTERN.matcher(password).matches()) &#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NOOP_PASSWORD_PREFIX + password;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中可以看到，有两个比较重要的条件促使系统自动提供一个InMemoryUserDetailsManager 的实例：</p><p>  (1)当前 classpath 下存在 AuthenticationManager 类。  </p><p>  (2 )当前项目中，系统没有提供 AuthenticationManager、AutlienticationProvider、UserDetailsService 以及 ClientRegistrationRepository 实例。</p><p>默认情况下，上面的条件都会满足，此时Spring Security会提供一个InMemoryUserDetailsManager实例。从InMemoryUserDetailsManager方法中可以看到，用户数据源自 SecurityProperties#getUser 方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.security&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityProperties</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BASIC_AUTH_ORDER</span> <span class="operator">=</span> Ordered.LOWEST_PRECEDENCE - <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">IGNORED_ORDER</span> <span class="operator">=</span> Ordered.HIGHEST_PRECEDENCE;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_FILTER_ORDER</span> <span class="operator">=</span> OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER - <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Filter</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Filter <span class="title function_">getFilter</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.filter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">order</span> <span class="operator">=</span> DEFAULT_FILTER_ORDER;</span><br><span class="line"><span class="keyword">private</span> Set&lt;DispatcherType&gt; dispatcherTypes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(</span><br><span class="line">Arrays.asList(DispatcherType.ASYNC, DispatcherType.ERROR, DispatcherType.REQUEST));</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrder</span><span class="params">(<span class="type">int</span> order)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.order = order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Set&lt;DispatcherType&gt; <span class="title function_">getDispatcherTypes</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.dispatcherTypes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDispatcherTypes</span><span class="params">(Set&lt;DispatcherType&gt; dispatcherTypes)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.dispatcherTypes = dispatcherTypes;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; roles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">passwordGenerated</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(password)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.passwordGenerated = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getRoles</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.roles;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoles</span><span class="params">(List&lt;String&gt; roles)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.roles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(roles);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPasswordGenerated</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.passwordGenerated;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从SecurityProperties.User类中，我们就可以看到默认的用户名是user,默认的密码是一个 UUID字符串。</p><p>  再回到 InMemoryUserDetailsManager方法中，构造 InMemoryUserDetailsManager实例时需要一个 User对象。这里的 User对象不是SecurityProperties.User ,而是 org.springframework.security.core.userdetails.User, 这是 Spring Security 提供的一个实现了UserDetails接口的用户类，该类提供了相应的静态方法，用来构造一个默认的Uset实例。同时，默认的用户密码还在getOrDeducePassword方法中进行了二次处理，由于默认的encoder 为null,所以密码的二次处理只是给密码加了一个前缀{noop},表示密码是明文存储的(关于 {noop}将在后续密码加密中做详细介绍)。</p><p>  经过以上的源码梳理，相信大家已经明白了 Spring Security 默认的用户名&#x2F;密码是来自哪里了！另外，当看了 Security Properties的源码后，只要对Spring Boot中properties属性的加载机制有一点了解，就会明白_，_只要我们在项目的application.properties配置文件中添加如下配置, 就能定制SecurityProperties.User类中各属性的值：</p><p>spring.security.user.name&#x3D;javaboy</p><p>spring.security.user.password&#x3D;123</p><p>spring.security.user.roles&#x3D;admin, user</p><p>配置完成后，重启项目，此时登录的用户名就是javaboy,登录密码就是123 ,登录成功后用户具备admin和user两个角色。</p><h3 id="1-3-2-默认页面生成"><a href="#1-3-2-默认页面生成" class="headerlink" title="1.3.2 默认页面生成"></a>1.3.2 默认页面生成</h3><p>在上面的案例中，一共存在两个默认页面，一个就是默认的登录页面，另外一个则是注销登录页面。当用户登录成功之后，在浏览器中输入<a href="https://localhost:8080/logout%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%B3%A8%E9%94%80%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%A6%82%E5%9B%BE%E6%89%80%E7%A4%BA%E3%80%82">https://localhost:8080/logout就可以看到注销登录页面，如图所示。</a></p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%EF%BC%882%EF%BC%89%EF%BC%884%EF%BC%89.png"></p><p>  那么这两个页面是从哪里来的呢？这里剖析一下，</p><p>  在前面我们介绍了 Spring Security中常见的过滤器，在这些常见的过滤器中就包含两个和页面相关的过滤器：DefaultLoginPageGeneratingFilter 和 DefaultLogoutPageGeneratingFilter</p><p>  通过过滤器的名字就可以分辨出DefaultLoginPageGeneratingFilter过滤器用来生成默认的登录页面，DefaultLogoutPageGeneratingFilter过滤器则用来生成默认的注销页面。</p><p>  先来看 DefaultLoginPageGeneratingFilter 作为 Spring Security 过滤器链中的一员，在第一次请求&#x2F;hello接口的时候，就会经过DefaultLoginPageGeneratingFilter过滤器，但是由于&#x2F;hello 接口和登录无关，因此DefaultLoginPageGeneratingFilter过滤器并未干涉&#x2F;hello接口，等到第二次重定向到&#x2F;login页面的时候，这个时候就和DefaultLoginPageGeneratingFilter有关系了，此时请求就会在DefaultLoginPageGeneratingFilter中进行处理，生成登录页面返回给客户端。</p><p>  我们来看一下DefaultLoginPageGeneratingFilter的源码，源码比较长，这里仅列出核心部分：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultLoginPageGeneratingFilter</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="type">httpsServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (httpsServletRequest) req;</span><br><span class="line"><span class="type">httpsServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (httpsServletResponse) res;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">loginError</span> <span class="operator">=</span> isErrorPage(request);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">logoutSuccess</span> <span class="operator">=</span> isLogoutSuccess(request);</span><br><span class="line"><span class="keyword">if</span> (isLoginUrlRequest(request) || loginError || logoutSuccess) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">loginPageHtml</span> <span class="operator">=</span> generateLoginPageHtml(request, loginError,</span><br><span class="line">logoutSuccess);</span><br><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">response.setContentLength(loginPageHtml.length());</span><br><span class="line">response.getWriter().write(loginPageHtml);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">generateLoginPageHtml</span><span class="params">(httpsServletRequest request, <span class="type">boolean</span> loginError,</span></span><br><span class="line"><span class="params"><span class="type">boolean</span> logoutSuccess)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> <span class="string">&quot;none&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (loginError) &#123;</span><br><span class="line"><span class="type">httpsSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">AuthenticationException</span> <span class="variable">ex</span> <span class="operator">=</span> (AuthenticationException) session</span><br><span class="line">.getAttribute(WebAttributes.AUTHENTICATION_EXCEPTION);</span><br><span class="line">errorMsg = ex != <span class="literal">null</span> ? ex.getMessage() : <span class="string">&quot;none&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Login Page&lt;/title&gt;&lt;/head&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (formLoginEnabled) &#123;</span><br><span class="line">sb.append(<span class="string">&quot;&lt;body onload=&#x27;document.f.&quot;</span>).append(usernameParameter)</span><br><span class="line">.append(<span class="string">&quot;.focus();&#x27;&gt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (loginError) &#123;</span><br><span class="line">sb.append(<span class="string">&quot;&lt;p style=&#x27;color:red;&#x27;&gt;Your login attempt was not successful, try again.&lt;br/&gt;&lt;br/&gt;Reason: &quot;</span>);</span><br><span class="line">sb.append(errorMsg);</span><br><span class="line">sb.append(<span class="string">&quot;&lt;/p&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logoutSuccess) &#123;</span><br><span class="line">sb.append(<span class="string">&quot;&lt;p style=&#x27;color:green;&#x27;&gt;You have been logged out&lt;/p&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (formLoginEnabled) &#123;</span><br><span class="line">sb.append(<span class="string">&quot;&lt;h3&gt;Login with Username and Password&lt;/h3&gt;&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;&lt;form name=&#x27;f&#x27; action=&#x27;&quot;</span>).append(request.getContextPath())</span><br><span class="line">.append(authenticationUrl).append(<span class="string">&quot;&#x27; method=&#x27;POST&#x27;&gt;\n&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;&lt;table&gt;\n&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;&lt;tr&gt;&lt;td&gt;User:&lt;/td&gt;&lt;td&gt;&lt;input type=&#x27;text&#x27; name=&#x27;&quot;</span>);</span><br><span class="line">sb.append(usernameParameter).append(<span class="string">&quot;&#x27; value=&#x27;&quot;</span>).append(<span class="string">&quot;&#x27;&gt;&lt;/td&gt;&lt;/tr&gt;\n&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;&lt;tr&gt;&lt;td&gt;Password:&lt;/td&gt;&lt;td&gt;&lt;input type=&#x27;password&#x27; name=&#x27;&quot;</span>)</span><br><span class="line">.append(passwordParameter).append(<span class="string">&quot;&#x27;/&gt;&lt;/td&gt;&lt;/tr&gt;\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (rememberMeParameter != <span class="literal">null</span>) &#123;</span><br><span class="line">sb.append(<span class="string">&quot;&lt;tr&gt;&lt;td&gt;&lt;input type=&#x27;checkbox&#x27; name=&#x27;&quot;</span>)</span><br><span class="line">.append(rememberMeParameter)</span><br><span class="line">.append(<span class="string">&quot;&#x27;/&gt;&lt;/td&gt;&lt;td&gt;Remember me on this computer.&lt;/td&gt;&lt;/tr&gt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">sb.append(<span class="string">&quot;&lt;tr&gt;&lt;td colspan=&#x27;2&#x27;&gt;&lt;input name=\&quot;submit\&quot; type=\&quot;submit\&quot; value=\&quot;Login\&quot;/&gt;&lt;/td&gt;&lt;/tr&gt;\n&quot;</span>);</span><br><span class="line">renderHiddenInputs(sb, request);</span><br><span class="line">sb.append(<span class="string">&quot;&lt;/table&gt;\n&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;&lt;/form&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (openIdEnabled) &#123;</span><br><span class="line">sb.append(<span class="string">&quot;&lt;h3&gt;Login with OpenID Identity&lt;/h3&gt;&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;&lt;form name=&#x27;oidf&#x27; action=&#x27;&quot;</span>).append(request.getContextPath())</span><br><span class="line">.append(openIDauthenticationUrl).append(<span class="string">&quot;&#x27; method=&#x27;POST&#x27;&gt;\n&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;&lt;table&gt;\n&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;&lt;tr&gt;&lt;td&gt;Identity:&lt;/td&gt;&lt;td&gt;&lt;input type=&#x27;text&#x27; size=&#x27;30&#x27; name=&#x27;&quot;</span>);</span><br><span class="line">sb.append(openIDusernameParameter).append(<span class="string">&quot;&#x27;/&gt;&lt;/td&gt;&lt;/tr&gt;\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (openIDrememberMeParameter != <span class="literal">null</span>) &#123;</span><br><span class="line">sb.append(<span class="string">&quot;&lt;tr&gt;&lt;td&gt;&lt;input type=&#x27;checkbox&#x27; name=&#x27;&quot;</span>)</span><br><span class="line">.append(openIDrememberMeParameter)</span><br><span class="line">.append(<span class="string">&quot;&#x27;&gt;&lt;/td&gt;&lt;td&gt;Remember me on this computer.&lt;/td&gt;&lt;/tr&gt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">sb.append(<span class="string">&quot;&lt;tr&gt;&lt;td colspan=&#x27;2&#x27;&gt;&lt;input name=\&quot;submit\&quot; type=\&quot;submit\&quot; value=\&quot;Login\&quot;/&gt;&lt;/td&gt;&lt;/tr&gt;\n&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;&lt;/table&gt;\n&quot;</span>);</span><br><span class="line">renderHiddenInputs(sb, request);</span><br><span class="line">sb.append(<span class="string">&quot;&lt;/form&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (oauth2LoginEnabled) &#123;</span><br><span class="line">sb.append(<span class="string">&quot;&lt;h3&gt;Login with OAuth 2.0&lt;/h3&gt;&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;&lt;table&gt;\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; clientAuthenticationUrlToClientName : oauth2AuthenticationUrlToClientName.entrySet()) &#123;</span><br><span class="line">sb.append(<span class="string">&quot; &lt;tr&gt;&lt;td&gt;&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;&lt;a href=\&quot;&quot;</span>).append(request.getContextPath()).append(clientAuthenticationUrlToClientName.getKey()).append(<span class="string">&quot;\&quot;&gt;&quot;</span>);</span><br><span class="line">sb.append(clientAuthenticationUrlToClientName.getValue());</span><br><span class="line">sb.append(<span class="string">&quot;&lt;/a&gt;&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">sb.append(<span class="string">&quot;&lt;/table&gt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">sb.append(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultLoginPageGeneratingFliter的源码执行流程还是非常清晰的，我们梳理一下：</p><ul><li>在doFilter方法中，首先判断出当前请求是否为登录出错请求、注销成功请求或者登录请求，如果是这三种请求中的任意一个，就会在DefaultLoginPageGeneratingFilter过滤器中生成登录页面并返回，否则请求继续往下走，执行下一个过滤器(这就是一开始的&#x2F;hello请 求为什么没有被DefaultLoginPageGeneratingFilter拦截下来的原因)。</li><li>如果当前请求是登录出错请求、注销成功请求或者登录请求中的任意一个，就会调用generateLoginPageHtml方法去生成登录页面。在该方法中，如果有异常信息就把异常信息 取出来一同返回给前端，然后根据不同的登录场景，生成不同的登录页面。生成过程其实就是字符串拼接，拼接岀不同的登录表单</li><li>登录页面生成后，接下来通过httpsServletResponse将登录页面写回到前端，然后调 用return方法跳出过滤器链。</li></ul><p>这就是DefaultLoginPageGeneratingFilter的工作过程。这里重点搞明白为什么&#x2F;hello请求没有被拦截，而&#x2F;login请求却被拦截了，其他都很好懂。</p><p>理解了 DefaultLoginPageGeneratingFilter，再来看 DefaultLogoutPageGeneratingFilter 就更容易了，DefaultLogoutPageGeneratingFilter 部分核心源码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultLogoutPageGeneratingFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RequestMatcher</span> <span class="variable">matcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/logout&quot;</span>, <span class="string">&quot;GET&quot;</span>);</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(httpsServletRequest request, httpsServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.matcher.matches(request)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.renderLogout(request, response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renderLogout</span><span class="params">(httpsServletRequest request, httpsServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">page</span> <span class="operator">=</span> <span class="string">&quot;&lt;!DOCTYPE html&gt;\n&lt;html lang=\&quot;en\&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=\&quot;utf-8\&quot;&gt;\n    &lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1, shrink-to-fit=no\&quot;&gt;\n    &lt;meta name=\&quot;description\&quot; content=\&quot;\&quot;&gt;\n    &lt;meta name=\&quot;author\&quot; content=\&quot;\&quot;&gt;\n    &lt;title&gt;Confirm Log Out?&lt;/title&gt;\n    &lt;link href=\&quot;httpss://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css\&quot; rel=\&quot;stylesheet\&quot; integrity=\&quot;sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M\&quot; crossorigin=\&quot;anonymous\&quot;&gt;\n    &lt;link href=\&quot;httpss://getbootstrap.com/docs/4.0/examples/signin/signin.css\&quot; rel=\&quot;stylesheet\&quot; crossorigin=\&quot;anonymous\&quot;/&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n     &lt;div class=\&quot;container\&quot;&gt;\n      &lt;form class=\&quot;form-signin\&quot; method=\&quot;post\&quot; action=\&quot;&quot;</span> + request.getContextPath() + <span class="string">&quot;/logout\&quot;&gt;\n        &lt;h2 class=\&quot;form-signin-heading\&quot;&gt;Are you sure you want to log out?&lt;/h2&gt;\n&quot;</span> + <span class="built_in">this</span>.renderHiddenInputs(request) + <span class="string">&quot;        &lt;button class=\&quot;btn btn-lg btn-primary btn-block\&quot; type=\&quot;submit\&quot;&gt;Log Out&lt;/button&gt;\n      &lt;/form&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;&quot;</span>;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(page);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从上述源码中可以看出，请求到来之后，会先判断是否是注销请求&#x2F;logout,如果是&#x2F;logout 请求，则渲染一个注销请求的页面返回给客户端，渲染过程和前面登录页而的渲染过程类似, 也是字符串拼接(这里省略了字符串拼接，读者可以参考DefaultLogoutPageGeneratingFilter 的源码)；否则请求继续往下走，执行下一个过滤器。</p><p>  通过前面的分析，相信大家对这个简单的案例己经有所了解，看似只是加了一个依赖， 但实际上Spring Security和Spring Boot在背后都默默做了很多事情，当然还有很多没有介绍到的，将在后面和大家一起继续深究。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security的认证和授权（1）</title>
      <link href="/2022/08/01/Spring%20Security%E7%9A%84%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%EF%BC%881%EF%BC%89/"/>
      <url>/2022/08/01/Spring%20Security%E7%9A%84%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring-Security-简介"><a href="#1-Spring-Security-简介" class="headerlink" title="1.Spring Security 简介"></a>1.Spring Security 简介</h1><p>Java企业级开发生态丰富，无论你想做哪方面的功能，都有众多的框架和工具可供选择, 以至于SUN公司在早些年不得不制定了很多规范，这些规范在今天依然影响着我们的开发， 安全领域也是如此，然而，不同于其他领域，在Java企业级开发中，安全管理方面的框架非常少，一般来说，主要有三种方案：</p><ul><li>Shiro</li><li>Spring Security</li><li>开发者自己实现</li></ul><p>  Shiro本身是一个老牌的安全管理框架，有着众多的优点，例如轻量、简单、易于集成、 可以在JavaSE环境中使用等。不过，在微服务时代，Shiro就显得力不从心了，在微服务面前, 它无法充分展示自己的优势。</p><p>  也有开发者选择自己实现安全管理，这一部分人不在少数，但是一个系统 的安全，不仅仅是登录和权限控制这么简单，我们还要考虑各种各样可能存在的网络攻击以及防御策略，从这个角度来说，开发者自己实现安全管理也并非是一件容易的事情，只有大公司才有足够的人力物力去支持这件事情。Spring Security作为Spring家族的一员，在和Spring家族的其他成员如Spring Boot、Spring Cloud等进行整合时，具有其他框架无可比拟的优势，同时对OAuth2有着良好的支持，再加 上 Spring Cloud 对 Spring Security 的不断加持（如推出 Spring Cloud Security）,让 Spring Security 不知不觉中成为微服务项目的首选安全管理方案。</p><h1 id="2-Spring-Security-核心功能"><a href="#2-Spring-Security-核心功能" class="headerlink" title="2.Spring Security 核心功能"></a>2.Spring Security 核心功能</h1><p>对于一个安全管理框架而言，无论是Shiro还是Spring Security,最核心的功能，无非就是如下两方面：</p><ul><li>认证</li><li>授权</li></ul><p>  通俗点说，认证就是身份验证（你是谁？），授权就是访问控制（你可以做什么？）</p><h2 id="2-1-认证"><a href="#2-1-认证" class="headerlink" title="2.1 认证"></a>2.1 认证</h2><p>Spring Security支持多种不同的认证方式，这些认证方式有的是Spring Security自己提供的认证功能，有的是第三方标准组织制订的。Spring Security集成的主流认证机制主要有如下几种：</p><ul><li>表单认证</li><li>OAuth2.0 认证</li><li>SAML2.0 认证</li><li>CAS 认证</li><li>RememberMe 自动认证</li><li>JAAS 认证</li><li>OpenlD 去中心化认证</li><li>Pre-Authentication Scenarios 认证口</li><li>X509认证</li><li>https Basic 认证</li><li>https Digest 认证</li></ul><p>作为一个开放的平台，Spring Security提供的认证机制不仅仅包括上面这些，我们还可以通过引入第三方依赖来支持更多的认证方式，同时，如果这些认证方式无法满足我们的需求, 我们也可以自定义认证逻辑，特别是当我们和一些“老破旧“的系统进行集成时，自定义认证逻辑就显得非常重要了。</p><h2 id="2-2-授权"><a href="#2-2-授权" class="headerlink" title="2.2 授权"></a>2.2 授权</h2><p>无论釆用了上面哪种认证方式，都不影响在Spring Security中使用授权功能。Spring Security支持基于URL的请求授权、支持方法访问授权、支持SpEL访问控制、支持域对象安全(ACL)，同时也支持动态权限配置、支持RBAC权限模型等，总之，我们常见的权限管理需求，Spring Security基本上都是支持的。</p><h2 id="2-3-其他"><a href="#2-3-其他" class="headerlink" title="2.3 其他"></a>2.3 其他</h2><p>在认证和授权这两个核心功能之外,Spring Security还提供了很多安全管理的“周边功能”, 这也是一个非常重要的特色。</p><p>  大部分Java工程师都不是专业的Web安全工程师，自己开发的安全管理框架可能会存在 大大小小的安全漏洞，而Spring Security的强大之处在于，即使你不了解很多网络攻击，只要使用了 Spring Security,它会帮助我们自动防御很多网络攻击，例如CSRF攻击、会话固定攻击等，同时Spring Security还提供了 https防火墙来拦截大量的非法请求。由此可见，研究Spring Securityr也是研究常见的网络攻击以及防御策略。</p><p>  对于大部分的Java项目而言，无论是从经济性还是安全性来考虑，使用Spring Security 无疑是最佳方案。</p><h1 id="3-Spring-Security-整体架构"><a href="#3-Spring-Security-整体架构" class="headerlink" title="3. Spring Security 整体架构"></a>3. Spring Security 整体架构</h1><h2 id="3-1-认证和授权"><a href="#3-1-认证和授权" class="headerlink" title="3.1 认证和授权"></a>3.1 认证和授权</h2><h3 id="3-1-1-认证"><a href="#3-1-1-认证" class="headerlink" title="3.1.1 认证"></a>3.1.1 认证</h3><p>在 Spring Security 的架构设计中，认证(Authentication)和授权(Authorization)是分开的，无论使用什么样的认证方式，都不会影响授权，这是两个独立的存在，这种独立带来的好处之一，就是Spring Security可以非常方便地整合一些外部的认证方案。</p><p>  在Spring Security中，用户的认证信息主要由Authentication的实现类来保存， Authentication 接口定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Authentication</span> <span class="keyword">extends</span> <span class="title class_">Principal</span>, Serializable &#123;</span><br><span class="line">Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line">Object <span class="title function_">getCredentials</span><span class="params">()</span>;</span><br><span class="line">Object <span class="title function_">getDetails</span><span class="params">()</span>;</span><br><span class="line">Object <span class="title function_">getPrincipal</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isAuthenticated</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setAuthenticated</span><span class="params">(<span class="type">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里接口中定义的方法如下：</p><ul><li>getAuthorities方法：用来获取用户的权限。</li><li>getCredentials方法_：_用来获取用户凭证，一般来说就是密码。</li><li>getDetails方法：用来获取用户携带的详细信息，可能是当前请求之类等。</li><li>getPrincipal方法：用来获取当前用户，例如是一个用户名或者一个用户对象。</li><li>isAuthenticated：当前用户是否认证成功。</li></ul><p>  当用户使用用户名&#x2F;密码登录或使用Remember-me登录时，都会对应一个不同的 Authentication 实例。Spring Security中的认证工作主要由AuthenticationManager接口来负责，下面来看一下该接口的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationManager</span> &#123;</span><br><span class="line">Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line"><span class="keyword">throws</span> AuthenticationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  AuthenticationManager只有一个authenticate方法可以用来做认证，该方法有三个不同的返回值：</p><ul><li>返回Authentication,表示认证成功。</li><li>抛出AuthenticationException异常，表示用户输入了无效的凭证。</li><li>返回null,表示不能断定。</li></ul><p>  AuthenticationManager 最主要的实现类是 ProviderManager，PioviderManager 管理了众多的 AuthenticationProvider 实例，AuthenticationProvider 有点类似于 AuthenticationManager,但是它多了一个supports方法用来判断是否支持给定的Authentication类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line">Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line"><span class="keyword">throws</span> AuthenticationException;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由于Authentication拥有众多不同的实现类，这些不同的实现类又由不同的 AuthenticationProvider 来处理，所以 AuthenticationProvider 会有一个 supports 方法，用来判断当前的 AuthenticationProvider 是否支持对应的 Authentication。</p><p>  在一次完整的认证流程中，可能会同时存在多个AuthenticationProvider (例如，项目同时支持form表单登录和短信验证码登录)，多个AuthenticationProvider统一由ProviderManager 来管理。同时，ProviderManager具有一个可选的parent,如果所有的AuthenticationProvider 都认证失败，那么就会调用parent进行认证。parent相当于一个备用认证方式，即各个 AuthenticationProvider都无法处理认证问题的时候，就由parent出场收拾残局。</p><h3 id="3-1-2-授权"><a href="#3-1-2-授权" class="headerlink" title="3.1.2 授权"></a>3.1.2 授权</h3><p>当完成认证后，接下来就是授权了。在Spring Security的授权体系中，有两个关键接口：</p><ul><li>AccessDecisionManager</li><li>AccessDecisionVoter</li></ul><p>  AccessDecisionVoter是一个投票器，投票器会检查用户是否具备应有的角色，进而投出赞成、反对或者弃权票；AccessDecisionManager则是一个决策器，来决定此次访问是否被允许。 AccessDecisionVoter 和 AccessDecisionManager 都有众多的实现类，在 AccessDecisionManager 中会挨个遍历AccessDecisionVoter，进而决定是否允许用户访问，因而AccessDecisionVoter 和 AccessDecisionManager 两者的关系类似于 AuthenticationProvider 和 ProviderManager 的关系。</p><p>  在Spring Security中，用户请求一个资源（通常是一个网络接口或者一个Java方法）所需要的角色会被封装成一个ConfigAttribute对象，在ConfigAttribute中只有一个getAttribute 方法，该方法返回一个String字符串，就是角色的名称。一般来说，角色名称都带有一个ROLE_ 前缀，投票器AccessDecisionVoter所做的事情，其实就是比较用户所具备的角色和请求某个资源所需的ConfigAttribute之间的关系。</p><h2 id="3-2-Web安全"><a href="#3-2-Web安全" class="headerlink" title="3.2 Web安全"></a>3.2 Web安全</h2><p>在Spring Security中，认证、授权等功能都是基于过滤器来完成的。下表列出了 Spring Security中常见的过滤器，注意这里说的是否默认加载是指引入Spring Security依赖之后，开发者不做任何配置时，会自动加载的过滤器。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%9A%84%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%EF%BC%881%EF%BC%89%EF%BC%881%EF%BC%89.png">    </p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%9A%84%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%EF%BC%881%EF%BC%89%EF%BC%882%EF%BC%89.png"></p><p>  开发者所见到的Spring Security提供的功能，都是通过这些过滤器来实现的，这些过滤器按照既定的优先级排列，最终形成一个过滤器链，开发者也可以自定义过滤器，并通过@Order 注解去调整自定义过滤器在过滤器链中的位置。</p><p>  需要注意的是，默认过滤器并不是直接放在Web项目的原生过滤器链中，而是通过一个FilterChainProxy 来统一管理。Spring Security 中的过滤器链通过 FilterChainProxy 嵌入到 Web 项目的原生过滤器链中，如下图所示。</p><p><img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%9A%84%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%EF%BC%881%EF%BC%89%EF%BC%883%EF%BC%89.png"></p><p>  在Spring Security中，这样的过滤器链不仅仅只有一个，可能会有多个，如下图所示。 当存在多个过滤器链时，多个过滤器链之间要指定优先级，当请求到达后，会从 FilterChainProxy进行分发，先和哪个过滤器链匹配上，就用哪个过滤器链进行处理。当系统中存在多个不同的认证体系时，那么使用多个过滤器链就非常有效。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%9A%84%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%EF%BC%881%EF%BC%89%EF%BC%884%EF%BC%89.png"></p><p>  FilterChainProxy 作为一个顶层管理者，将统一管理 Security Fliter_。_ FilterChainProxy 本身将通过Spring框架提供的DelegatingFilterProxy整合到原生过滤器链中，所以还可以做进一步的优化，如下图所示。</p><p><img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%9A%84%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%EF%BC%881%EF%BC%89%EF%BC%885%EF%BC%89.png"></p><h2 id="3-3-登录数据保存"><a href="#3-3-登录数据保存" class="headerlink" title="3.3 登录数据保存"></a>3.3 登录数据保存</h2><p>  如果不使用Spring Security这一类的安全管理框架，大部分的开发者可能会将登录用户数据保存在Session中，事实上,Spring Security也是这么做的。但是，为了使用方便,Spring Security 在此基础上还做了一些改进，其中最主要的一个变化就是线程绑定，</p><p>  当用户登录成功后，Spring Security会将登录成功的用户信息保存到SecurityContextHolder 中。SecurityContextHolder 中的数据保存默认是通过ThreadLocal来实现的，使用ThreadLocal 创建的变量只能被当前线程访问，不能被其他线程访问和修改，也就是用户数据和请求线程绑定在一起。当登录请求处理完毕后，Spring Security会将SecurityContextHolder中的数据拿出来保存到Session中，同时将SecurityContextHolder中的数据清空。以后每当有请求到来时， Spring Security就会先从Session中取出用户登录数据，保存到SecurityContextHolder 中，方便在该请求的后续处理过程中使用，同时在请求结束时将SecurityContextHolder中的数据拿岀来保存到Session中，然后将SecurityContextHolder 中的数据清空。</p><p>  这一策略非常方便用户在Controller或者Service层获取当前登录用户数据，但是带来的另外一个问题就是，在子线程中想要获取用户登录数据就比较麻烦。Spring Security对此也提供了相应的解决方案，如果开发者使用@Async注解来开启异步任务的话，那么只需要添加如下配置，使用Spring Security提供的异步任务代理，就可以在异步任务中从SecurityContextHolder里边获取当前登录用户的信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationConfiguration</span> <span class="keyword">extends</span> <span class="title class_">AsyncConfigurerSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatingSecurityContextExecutorService</span>(Executors.newFixedThreadPool(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security- SpringBoot（18）</title>
      <link href="/2022/07/28/Spring%20Security-%20SpringBoot%EF%BC%8818%EF%BC%89/"/>
      <url>/2022/07/28/Spring%20Security-%20SpringBoot%EF%BC%8818%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="由于Spring-Security内容较多，本人决定先学Spring-Security然后继续更新springboot"><a href="#由于Spring-Security内容较多，本人决定先学Spring-Security然后继续更新springboot" class="headerlink" title="由于Spring Security内容较多，本人决定先学Spring Security然后继续更新springboot"></a>由于Spring Security内容较多，本人决定先学Spring Security然后继续更新springboot</h1><h1 id="1-认识Spring-Security"><a href="#1-认识Spring-Security" class="headerlink" title="1.认识Spring Security"></a>1.认识Spring Security</h1><p>  Spring Security提供了声明式的安全访问控制解决方案(仅支持基于Spring的应用程序)，对访问权限进行认证和授权，它基于Spring AOP和Servlet过滤器，提供了安全性方面的全面解决方案。</p><p>  除常规的认证和授权外，它还提供了 ACLs、LDAP、JAAS、CAS等高级特性以满足复杂环境下的安全需求。</p><h2 id="1-1-核心概念"><a href="#1-1-核心概念" class="headerlink" title="1.1 核心概念"></a>1.1 核心概念</h2><p>Spring Security的3个核心概念。</p><ul><li>Principle：代表用户的对象Principle ( User),不仅指人类，还包括一切可以用于验证的设备。</li><li>Authority:  代表用户的角色Authority ( Role ),每个用户都应该有一种角色，如管理员或是会员。</li><li>Permission：代表授权，复杂的应用环境需要对角色的权限进行表述。</li></ul><p>  在Spring Security中，Authority和Permission是两个完全独立的概念，两者并没有必然的联系。它们之间需要通过配置进行关联，可以是自己定义的各种关系。</p><h2 id="1-2-认证和授权"><a href="#1-2-认证和授权" class="headerlink" title="1.2 认证和授权"></a>1.2 认证和授权</h2><p>安全主要分为验证(authentication)和授权(authorization )两个部分。</p><h3 id="（1）验证-authentication"><a href="#（1）验证-authentication" class="headerlink" title="（1）验证(authentication)"></a>（1）验证(authentication)</h3><p>  验证指的是，建立系统使用者信息(Principal)的过程。使用者可以是一个用户、设备，和可以在应用程序中执行某种操作的其他系统。用户认证一般要求用户提供用户名和密码，系统通过校验用户名和密码的正确性来完成认证的通过或拒绝过程。Spring Security支持主流的认证方式，包括https基本认证、https表单验证、https摘要认证、OpenlD和LDAP等。</p><p>  Spring Security进行验证的步骤如下：</p><ol><li>用户使用用户名和密码登录。</li><li>过滤器(UsernamePasswordAuthenticationFilter)获取到用户名、密码，然后封装成 Authentication。</li><li>AuthenticationManager 认证 token ( Authentication 的实现类传递)。</li><li>AuthenticationManager认证成功,返回一个封装了用户权限信息的Authentication对象， 用户的上下文信息(角色列表等)。</li><li>Authentication对象赋值给当前的SecurityContext,建立这个用户的安全上下文(通过调用 getContext().setAuthentication())。</li><li>用户进行一些受到访问控制机制保护的操作，访问控制机制会依据当前安全上下文信息检查这个操作所需的权限。</li></ol><p>除利用提供的认证外，还可以编写自己的Filter（过滤器),提供与那些不是基于Spring Security 的验证系统的操作。</p><h3 id="（2）授权-authorization-。"><a href="#（2）授权-authorization-。" class="headerlink" title="（2）授权(authorization)。"></a>（2）授权(authorization)。</h3><p>  在一个系统中，不同用户具有的权限是不同的。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。它判断某个Principal在应用程序中是否允许执行某个操作。在进行授权判断之前，要求其所要使用到的规则必须在验证过程中已经建立好了。对Web资源的保护，最好的办法是使用过滤器。对方法调用的保护，最好的办法是使用AOP。Spring Security在进行用户认证及授予权限时，也是通过各种拦截器和AOP来控制权限访问的，从而实现安全。</p><h2 id="1-3-模块"><a href="#1-3-模块" class="headerlink" title="1.3 模块"></a>1.3 模块</h2><ul><li>核心模块——spring-security-core.jar：包含核心验证和访问控制类和接口，以及支持远程配置的基本API。</li><li>远程调用——spring-security-remoting.jar：提供与 Spring Remoting 集成。</li><li>网页——spring-security-web.jar：包括网站安全的模块，提供网站认证服务和基于URL 访问控制。</li><li>配置——spring-security-config.jar：包含安全命令空间解析代码。</li><li>LDAP——spring-security-ldap.jar： LDAP 验证和配置。</li><li>ACL——spring-security-acl.jar：对 ACL 访问控制表的实现。</li><li>CAS——spring-security-cas.jar：对 CAS 客户端的安全实现。</li><li>OpenlD——spring-security-openid.jar：对 OpenlD 网页验证的支持。</li><li>Test——spring-security-test.jar:对 Spring Security 的测试的支持。</li></ul><h1 id="2-核心类"><a href="#2-核心类" class="headerlink" title="2. 核心类"></a>2. 核心类</h1><h2 id="2-1-SecurityContext"><a href="#2-1-SecurityContext" class="headerlink" title="2.1 SecurityContext"></a>2.1 SecurityContext</h2><p>  Securitycontext中包含当前正在访问系统的用户的详细信息，它只有以下两种方法。</p><ul><li>getAuthentication（）：获取当前经过身份验证的主体或身份验证的请求令牌。</li><li>setAuthentication（）:更改或删除当前已验证的主体身份验证信息。</li></ul><p>  SecurityContext 的信息是由 SecurityContextHolder 来处理的。</p><h2 id="2-2-SecurityContextHolder"><a href="#2-2-SecurityContextHolder" class="headerlink" title="2.2 SecurityContextHolder"></a>2.2 SecurityContextHolder</h2><p>  SecurityContextHolder 用来保存 SecurityContext。最常用的是 getContext()方法，用来获得当前 SecurityContext。</p><p>  SecurityContextHolder中定义了一系列的静态方法，而这些静态方法的内部逻辑是通过 SecurityContextHolder 持有的 SecurityContextHolderStrategy 来实现的，如 clearContext()、 getContext ()、setContext、createEmptyContext（）。SecurityContextHolderStrategy 接口的关键代码如下：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2004, 2005, 2006 Acegi Technology Pty Limited</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      https://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.security.core.context;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A strategy for storing security context information against a thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The preferred strategy is loaded by &#123;<span class="doctag">@link</span> SecurityContextHolder&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ben Alex</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityContextHolderStrategy</span> &#123;</span><br><span class="line"><span class="comment">// ~ Methods</span></span><br><span class="line"><span class="comment">// ========================================================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clears the current context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtains the current context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a context (never &lt;code&gt;null&lt;/code&gt; - create a default implementation if</span></span><br><span class="line"><span class="comment"> * necessary)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> SecurityContext <span class="title function_">getContext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context to the new argument (should never be &lt;code&gt;null&lt;/code&gt;, although</span></span><br><span class="line"><span class="comment"> * implementations must check if &lt;code&gt;null&lt;/code&gt; has been passed and throw an</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;IllegalArgumentException&lt;/code&gt; in such cases)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty context implementation, for use by</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;SecurityContextRepository&lt;/tt&gt; implementations, when creating a new context for</span></span><br><span class="line"><span class="comment"> * the first time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the empty context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> SecurityContext <span class="title function_">createEmptyContext</span><span class="params">()</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="（1）strategy-实现"><a href="#（1）strategy-实现" class="headerlink" title="（1）strategy 实现"></a>（1）strategy 实现</h3><p>  默认使用的 strategy 就是基于 ThreadLocal 的 ThreadLocalSecurityContextHolderStralegy 来实现的。</p><p>  除了上述提到的，Spring Security还提供了 3种类型的strategy来实现。</p><ul><li>GlobalSecurityContextHolderStrategy：表示全局使用同一个 SecuntyContext,如 C&#x2F;S 结构的客户端。</li><li>InheritableThreadLocalSecuntyContextHolderStrategy：使用 InhentableThreadLocal 来存放Security Context, 即子线程可以使用父线程中存放的变量。</li><li>ThreadLocalSecuntyContextHolderStrategy: 使用ThreadLocal 来存放 SecurityContext</li></ul><p>  —般情况下，使用默认的strategy即可。但是，如果要改变默认的strategy, Spring Security 提供了两种方法来改变”strategyName”</p><p>  SecuntyContextHolder 类中有 3 种不同类型的 strategy,分别为 MODE_THREADLOCAL、MODE_INHERITABLETHREADLOCAL和MODE_GLOBAL,关键代码如下：</p><p>    public static final String MODE_THREADLOCAL &#x3D; “MODE_THREADLOCAL”;</p><p>    publrc static final String MODE_INHERITABLETHREADLOCAL &#x3D; “MODE_INHERITABLETHREADLOCAL”;</p><p>    public static final String MODE_GLOBAL &#x3D; “MODE_GLOBAL”;</p><p>    public static final String SYSTEM_PROPERTY &#x3D; “spring.security.strategy”;</p><p>    private static String strategyName &#x3D; System.getProperty(SYSTEM_PROPERTY);</p><p>    private static SecurityContextHolderStrategy strategy;</p><p>  MODE_THREADLOCAL是默认的方法。</p><p>  如果要改变strategy,则有下面两种方法：</p><ul><li>通过 SecurityContextHolder 的静态方法 setStrategyName（java.Iang.String.strategyName) 来改变需要使用的strategy</li><li>通过系统属性(SYSTEM_PROPERTY )进行指定，其中属性名默认为”spring.security.strategy”,属性值为对应strategy的名称。</li></ul><h3 id="（2）获取当前用户的SecurityContext"><a href="#（2）获取当前用户的SecurityContext" class="headerlink" title="（2）获取当前用户的SecurityContext()"></a>（2）获取当前用户的SecurityContext()</h3><p>Spring Security使用一个Authentication对象来描述当前用户的相关信息。Security-ContextHolder中持有的是当前用户的SecurityContext,而SecurityContext持有的是代表当前用户相关信息的Authentication的引用。</p><p>  这个Authentication对象不需要自己创建，Spring Security会自动创建相应的Authentication 对象，然后赋值给当前的SecurityContext。但是，往往需要在程序中获取当前用户的相关信息， 比如最常见的是获取当前登录用户的用户名。在程序的任何地方，可以通过如下方式获取到当前用户的用户名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getCurrentUsername</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">principal</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">    <span class="keyword">if</span> (principal <span class="keyword">instanceof</span> UserDetails)&#123;</span><br><span class="line">        <span class="keyword">return</span> ((UserDetails) principal).getUsername();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (principal <span class="keyword">instanceof</span> Principal)&#123;</span><br><span class="line">        <span class="keyword">return</span> ((Principal) principal).getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(principal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  getAuthentication()方法会返回认证信息。</p><p>  getPrincipal()方法返回身份信息，它是UserDetails对身份信息的封装。</p><p>  获取当前用户的用户名，最简单的方式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getCurrentUsername</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SecurityContextHolder.getContext().getAuthentication().getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在调用 SecurityContextHolder.getContext()获取 SecurityContext 时，如果对应的 Securitycontext 不存在，则返回空的 SecurityContext。</p><h2 id="2-3-ProviderManager"><a href="#2-3-ProviderManager" class="headerlink" title="2.3 ProviderManager"></a>2.3 ProviderManager</h2><p>ProviderManager会维护一个认证的列表，以便处理不同认证方式的认证，因为系统可能会存在多种认证方式，比如手机号、用户名密码、邮箱方式。</p><p>  在认证时，如果ProviderManager的认证结果不是null,则说明认证成功，不再进行其他方式的认证，并且作为认证的结果保存在SecurityContext中。如果不成功，则抛出错误信息 “ProviderNotFoundException”</p><h2 id="2-4-DaoAuthenticationProvider"><a href="#2-4-DaoAuthenticationProvider" class="headerlink" title="2.4 DaoAuthenticationProvider"></a>2.4 DaoAuthenticationProvider</h2><p>它是AuthenticationProvider最常用的实现，用来获取用户提交的用户名和密码，并进行正确性比对。如果正确，则返回一个数据库中的用户信息。</p><p>  当用户在前台提交了用户名和密码后，就会被封装成UsernamePasswordAuthentication-Token。然后，DaoAuthenticationProvider 根据 retrieveUser方法，交给 additionalAuthentication- Checks方法完成 UsernamePasswordAuthenticationToken 和 UserDetails 密码的比对。如果这个方法没有抛出异常，则认为比对成功。</p><p>  比对密码需要用到PasswordEncoder和SaltSource。</p><h2 id="2-5-UserDetails"><a href="#2-5-UserDetails" class="headerlink" title="2.5 UserDetails"></a>2.5 UserDetails</h2><p>UserDetails是Spring Security的用户实体类，包含用户名、密码、权限等信息。Spring Security默认实现了内置的User类，供Spring Security安全认证使用，当然，也可以自己实现。</p><p>    UserDetails 接口和 Authentication 接口很类似，都拥有 username 和 authorities。一定要区分清楚Authentication 的 getCredentials()与 UserDetails 中的 getPassword()。前者是用户提交的密码凭证，不一定是正确的，或数据库不一定存在；后者是用户正确的密码，认证器要进行比对的就是两者是否相同。</p><p>  Authentication 中的 getAuthorities()方法是由 UserDetails 的 getAuthorities()传递而形成 的。UserDetails的用户信息是经过Authenticationprovider认证之后被填充的</p><p>  UserDetails中提供了以下几种方法。</p><ul><li>String getPassword()：返回验证用户密码，无法返回则显示为null。</li><li>String getUsemame()：返回验证用户名，无法返回则显示为nulL</li><li>boolean isAccountNonExpired()：账户是否过期：过期无法验证。</li><li>boolean isAccountNonLocked()：指定用户是否被锁定或解锁，锁定的用户无法进行身份验证。</li><li>boolean isCredentialsNonExpired()：指定是否已过期的用户的凭据(密码)，过期的凭据无法认证。</li><li>boolean isEnabled()：是否被禁用。禁用的用户不能进行身份验证。</li></ul><h2 id="2-6-UserDetailsService"><a href="#2-6-UserDetailsService" class="headerlink" title="2.6 UserDetailsService"></a>2.6 UserDetailsService</h2><p>  用户相关的信息是通过UserDetailsService接口来加载的。该接口的唯一方法是 loadUserByUsername(String username),用来根据用户名加载相关信息。这个方法的返回值是 UserDetails接口，其中包含了用户的信息，包括用户名、密码、权限、是否启用、是否被锁定、 是否过期等。</p><h2 id="2-7-GrantedAuthority"><a href="#2-7-GrantedAuthority" class="headerlink" title="2.7 GrantedAuthority"></a>2.7 GrantedAuthority</h2><p>  GrantedAuthonty中只定义了一个getAuthority()方法。该方法返回一个字符串，表示对应权限的字符串。如果对应权限不能用字符串表示，则返回nulL</p><p>  GrantedAuthority 接口通过 UserDetailsService 进行加载，然后赋予 UserDetails。</p><p>  Authentication的getAuthorities()方法可以返回当前Authentication对象拥有的权限，其返回值是一个GrantedAuthority类型的数组。每一个GrantedAuthority对象代表赋予当前用户的一 种权限。</p><h2 id="2-8-Filter"><a href="#2-8-Filter" class="headerlink" title="2.8 Filter"></a>2.8 Filter</h2><h3 id="（1）SecurityContextPersistenceFilter"><a href="#（1）SecurityContextPersistenceFilter" class="headerlink" title="（1）SecurityContextPersistenceFilter"></a>（1）SecurityContextPersistenceFilter</h3><p>它从SecurityContextRepository中取出用户认证信息。为了提高效率，避免每次请求都要查询认证信息，它会从Session中取岀已认证的用户信息，然后将其放入SecurityContextHolder 中，以便其他Filter使用。</p><h3 id="（2）WebAsyncManagerlntegrationFilter"><a href="#（2）WebAsyncManagerlntegrationFilter" class="headerlink" title="（2）WebAsyncManagerlntegrationFilter"></a>（2）WebAsyncManagerlntegrationFilter</h3><p>集成了 SecurityContext 和 WebAsyncManager,把 Securitycontext 设置到异步线程，使其也能获取到用户上下文认证信息。</p><h3 id="（3）HanderWriterFilter"><a href="#（3）HanderWriterFilter" class="headerlink" title="（3）HanderWriterFilter"></a>（3）HanderWriterFilter</h3><p>  它对请求的Header添加相应的信息。</p><h3 id="（4）CsrfFilter"><a href="#（4）CsrfFilter" class="headerlink" title="（4）CsrfFilter"></a>（4）CsrfFilter</h3><p>  跨域请求伪造过滤器。通过客户端传过来的token与服务器端存储的token进行对比，来判断请求的合法性。</p><h3 id="（5）LogoutFilter"><a href="#（5）LogoutFilter" class="headerlink" title="（5）LogoutFilter"></a>（5）LogoutFilter</h3><p>匹配登岀URL。匹配成功后，退出用户，并清除认证信息。</p><p>  （6）UsernamePasswordAuthenticationFilter</p><p>  登录认证过滤器,默认是对“&#x2F;login”的POST请求进行认证。该方法会调用attemptAuthentication, 尝试获取一个Authentication认证对象，以保存认证信息，然后转向下一个Filter,最后调用 successfulAuthenlication 执行认证后的事件。</p><h3 id="（7）AnonymousAuthenticationFilter"><a href="#（7）AnonymousAuthenticationFilter" class="headerlink" title="（7）AnonymousAuthenticationFilter"></a>（7）AnonymousAuthenticationFilter</h3><p>  如果SecurityContextHolder中的认证信息为空，则会创建一个匿名用户到Security-ContextHolder 中</p><h3 id="（8）SessionManagementFilter"><a href="#（8）SessionManagementFilter" class="headerlink" title="（8）SessionManagementFilter"></a>（8）SessionManagementFilter</h3><p>  持久化登录的用户信息。用户信息会被保存到Session、Cookie、或Redis中。</p><h1 id="3-配置Spring-Security"><a href="#3-配置Spring-Security" class="headerlink" title="3.配置Spring Security"></a>3.配置Spring Security</h1><h2 id="3-1-继承-WebSecurityConfigurerAdapter"><a href="#3-1-继承-WebSecurityConfigurerAdapter" class="headerlink" title="3.1 继承 WebSecurityConfigurerAdapter"></a>3.1 继承 WebSecurityConfigurerAdapter</h2><p>通过重写抽象接口 WebSecurityConfigurerAdapter,再加上注解@EnableWebSecurity, 可以实现Web的安全配置。</p><p>    WebSecurityConfigurerAdapter Config 模块一共有 3 个 builder (构造程序)。</p><ul><li>AuthenticationManagerBuilder：认证相关builder，用来配置全局的认证相关的信息。它包含AuthenticationProvider和UserDetailsService f前者是认证服务提供者，后者是用户详情查询服务。</li><li>httpsSecurity：进行权限控制规则相关配置。</li><li>WebSecurity:进行全局请求忽略规则配置、httpsFirewall配置、debug配置、全局 SecurityFilterChain 配置。</li></ul><p>  配置安全，通常要重写以下方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过auth对象的方法添加身份验证</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder authenticationManagerBuilder)</span> <span class="keyword">throws</span> Exception&#123;&#125;</span><br><span class="line"><span class="comment">//通常用于设置忽略权限的静态资源</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity webSecurity)</span> <span class="keyword">throws</span> Exception&#123;&#125;</span><br><span class="line"><span class="comment">//通过https对象的authorizeRequests()方法定义URL访问权限。默认为formLogin()提供一个简单的登录验证页面</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity httpsSecurity)</span> <span class="keyword">throws</span> Exception&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-配置自定义策略"><a href="#3-2-配置自定义策略" class="headerlink" title="3.2 配置自定义策略"></a>3.2 配置自定义策略</h2><p>配置安全需要继承WebSecurityConfigurerAdapter，然后重写其方法，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.httpsSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.WebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//指定为配置类</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="comment">//指定为 Spring Security如果是 WebFlux,则需要启用@EnableWebFluxSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="comment">//如果要启用方法安全设置，则开启此项。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//不拦截静态资源</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/static/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用BCrypt加密</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(httpsSecurity https)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        https.formLogin().usernameParameter(<span class="string">&quot;uname&quot;</span>).passwordParameter(<span class="string">&quot;pwd&quot;</span>).loginPage(<span class="string">&quot;admin/login&quot;</span>).permitAll()</span><br><span class="line">                .and().authorizeRequests().antMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">                <span class="comment">//除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">        https.logout().permitAll();</span><br><span class="line">        https.rememberMe().rememberMeParameter(<span class="string">&quot;rememberMe&quot;</span>);</span><br><span class="line">        <span class="comment">//处理异常，拒绝访问就重定向到403页面</span></span><br><span class="line">        https.exceptionHandling().accessDeniedPage(<span class="string">&quot;/403&quot;</span>);</span><br><span class="line">        https.logout().logoutSuccessUrl(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        https.csrf().ignoringAntMatchers(<span class="string">&quot;/admin/upload&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释如下。</p><ul><li>authorizeRequests():  定义哪些URL需要被保护，哪些不需要被保护。</li><li>antMatchers(“&#x2F;admin&#x2F;**“).hasRole(“ADMIN”),定义&#x2F;admin&#x2F;下的所有 URL。只有拥有 admin角色的用户才有访问权限。</li><li>formLogin()：自定义用户登录验证的页面。</li><li>https.csrfO：配置是否开JSCSRF保护，还可以在开启之后指定忽略的接口。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns</span>=<span class="string">&quot;https://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;https://www.thymeleaf.org&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:sec</span>=<span class="string">&quot;https://www.thymeleaf.org/tyemeleaf-extras-springsecurity5&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果开启了 CSRF,则一定在验证页面加入以下代码以传递token值：--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;_csrf&quot;</span> <span class="attr">th:content</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;_csrf_header&quot;</span> <span class="attr">th:content</span>=<span class="string">&quot;$&#123;_csrf.headerName&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果要提交表单，则需要在表单中添加以下代码以提交token值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">th:name</span>=<span class="string">&quot;$&#123;_csrf.parameterName&#125;&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https.rememberMe()： &quot;记住我&quot;功能，可以指定参数。使用时，添加如下代码：--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;i-checks&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rememberme&quot;</span>/&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>记住我</span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-3-配置加密方式"><a href="#3-3-配置加密方式" class="headerlink" title="3.3 配置加密方式"></a>3.3 配置加密方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//使用BCrypt加密</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在业务代码中，可以用以下方式对密码进行加密：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BCryptPasswordEncoder</span> <span class="variable">bCryptPasswordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">encryptedPassword</span> <span class="operator">=</span> bCryptPasswordEncoder.encode(password);</span><br></pre></td></tr></table></figure><h2 id="3-4-自定义加密规则"><a href="#3-4-自定义加密规则" class="headerlink" title="3.4 自定义加密规则"></a>3.4 自定义加密规则</h2><p>除默认的加密规则，还可以自定义加密规则。具体见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    auth.userDetailsService(UserService()).passwordEncoder(<span class="keyword">new</span> <span class="title class_">PasswordEncoder</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(CharSequence rawPassword)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> MD5Util.encode((String)rawPassword);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> encodedPassword.equals(MD5Util.encode((String)rawPassword));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-配置多用户系统"><a href="#3-5-配置多用户系统" class="headerlink" title="3.5 配置多用户系统"></a>3.5 配置多用户系统</h2><p>  一个完整的系统一般包含多种用户系统，比如”后台管理系统+前端用户系统”。Spring Security 默认只提供一个用户系统，所以，需要通过配置以实现多用户系统。</p><p>比如，如果要构建一个前台会员系统，则可以通过以下步骤来实现。</p><h3 id="（1）构建UserDetailsService用户信息服务接口"><a href="#（1）构建UserDetailsService用户信息服务接口" class="headerlink" title="（1）构建UserDetailsService用户信息服务接口"></a>（1）构建UserDetailsService用户信息服务接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.intehel.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.LockedException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSecurityService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.findByName(username);</span><br><span class="line">        <span class="keyword">if</span> (user==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">mobileUser</span> <span class="operator">=</span> userRepository.findByMobile(username);</span><br><span class="line">            <span class="keyword">if</span> (mobileUser==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">emailUser</span> <span class="operator">=</span> userRepository.findByEmail(username);</span><br><span class="line">                <span class="keyword">if</span> (emailUser==<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户名，邮箱或手机号不存在！&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    user = userRepository.findByEmail(username);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                user = userRepository.findByMobile(username);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;locked&quot;</span>.equals(user.getStatus()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LockedException</span>(<span class="string">&quot;用户被锁定&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）进行安全配置"><a href="#（2）进行安全配置" class="headerlink" title="（2）进行安全配置"></a>（2）进行安全配置</h3><p>  在继承 WebSecurityConfigurerAdapter 的 Spring Security 配置类中,配置 UserSecurity- Service 类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">UserDetailsService <span class="title function_">UserService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserSecurityService</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果要加入后台管理系统，则只需要重复上面步骤即可。</p><h2 id="3-6-获取当前登录用户信息的几种方式"><a href="#3-6-获取当前登录用户信息的几种方式" class="headerlink" title="3.6 获取当前登录用户信息的几种方式"></a>3.6 获取当前登录用户信息的几种方式</h2><p>  获取当前登录用户的信息，在权限开发过程中经常会遇到。而对新人来说，不太了解怎么获取, 经常遇到获取不到或报错的问题。所以，本节讲解如何在常用地方获取当前用户信息。</p><h3 id="（1）在Thymeleaf视图中获取"><a href="#（1）在Thymeleaf视图中获取" class="headerlink" title="（1）在Thymeleaf视图中获取"></a>（1）在Thymeleaf视图中获取</h3><p>  要Thymeleaf视图中获取用户信息，可以使用Spring Security的标签特性。</p><p>  在Thymeleaf页面中引入Thymeleaf的Spring Security依赖,见以下代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;https://www.thymeleaf.org&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:sec</span>=<span class="string">&quot;https://www.thymeleaf.org/extras/spring-security&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;isAnonymous()&quot;</span>&gt;</span></span><br><span class="line">        未登录，单击<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/home/login&#125;&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;isAuthenticated()&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>已登录<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>登录名：<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>角色：<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;principal.authorities&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>name：<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;principal.username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>password：<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;principal.password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里要特别注意版本的对应。如果引入了 thymeleaf-extras-springsecurity依赖依然获取不到信息，那么可能是Thymeleaf版本和thymeleaf-extras-springsecurity的版本不对，请检查在pom.xrnl文件的两个依赖，见以下代码，springboot中需加入starter依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-springsecurity5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0.M1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（2）在Controller中获取"><a href="#（2）在Controller中获取" class="headerlink" title="（2）在Controller中获取"></a>（2）在Controller中获取</h3><p>在控制器中获取用户信息有3种方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;userinfo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getProduct</span><span class="params">(Principal principal, Authentication authentication,httpsServletRequest request)</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.通过Principal获取</span></span><br><span class="line"><span class="comment">     *  */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username1</span> <span class="operator">=</span> principal.getName();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.通过Authentication获取</span></span><br><span class="line"><span class="comment">     *  */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username2</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.通过httpsServletRequest获取</span></span><br><span class="line"><span class="comment">     *  */</span></span><br><span class="line">    <span class="type">Principal</span> <span class="variable">httpsPrincipal</span> <span class="operator">=</span> request.getUserPrincipal();</span><br><span class="line">    <span class="type">String</span> <span class="variable">username3</span> <span class="operator">=</span> httpsPrincipal.getName();</span><br><span class="line">    <span class="keyword">return</span> username1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）在Bean中获取"><a href="#（3）在Bean中获取" class="headerlink" title="（3）在Bean中获取"></a>（3）在Bean中获取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"><span class="keyword">if</span> (!(authentication <span class="keyword">instanceof</span> AnonymousAuthenticationToken))&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">    <span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在其他 Authentication 类也可以这样获取。比如在 UsemamePasswoEAuthenticationToken 类中。</p><p>  如果上面代吗获取不到，并不是代码错误，则可能是因为以下原因造成的</p><ol><li>要使上面的获取生效，必须在继承 WebSecurityConfigurerAdapter的类中的https.antMatcher(“&#x2F;*“)的鉴权 URI 范围内。</li><li>没有添加 Thymeleaf 的 thymeleaf-extras-springsecurity 依赖。</li><li>添加了 Spring Security 的依械，但是版本不对，比如 Spring Security 和 Thymeleaf 的版本不对。</li></ol><h2 id="3-7-用Spring-Security来实现后台登录及权限认证功能"><a href="#3-7-用Spring-Security来实现后台登录及权限认证功能" class="headerlink" title="3.7 用Spring Security来实现后台登录及权限认证功能"></a>3.7 用Spring Security来实现后台登录及权限认证功能</h2><h3 id="（1）引入依赖"><a href="#（1）引入依赖" class="headerlink" title="（1）引入依赖"></a>（1）引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-springsecurity5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0.M1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（2）创建权限开放的页面"><a href="#（2）创建权限开放的页面" class="headerlink" title="（2）创建权限开放的页面"></a>（2）创建权限开放的页面</h3><p>  这个页面是不需要鉴权即可访问的，以区别演示需要鉴权的页面，见以下代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;https://www.thymeleaf.org&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:sec</span>=<span class="string">&quot;https://www.thymeleaf.org/extras/spring-security&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>security案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>welcome<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/home&#125;&quot;</span>&gt;</span>会员中心<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（3）创建需要权限验证的页面"><a href="#（3）创建需要权限验证的页面" class="headerlink" title="（3）创建需要权限验证的页面"></a>（3）创建需要权限验证的页面</h3><p>  其实可以和不需要鉴权的页面一样，鉴权可以不在HTML页面中进行，见以下代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;https://www.thymeleaf.org&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:sec</span>=<span class="string">&quot;https://www.thymeleaf.org/extras/spring-security&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>home<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello 会员中心<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:inline</span>=<span class="string">&quot;text&quot;</span>&gt;</span>hello<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/logout&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登出&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  使用 Spring Security 5 之后，可以在模板中用<span sec:authentication="name"></span> 或[[$</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTful与Swagger（接口架构风格）- SpringBoot（17）</title>
      <link href="/2022/07/26/RESTful%E4%B8%8ESwagger%EF%BC%88%E6%8E%A5%E5%8F%A3%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%EF%BC%89-%20SpringBoot%EF%BC%8817%EF%BC%89/"/>
      <url>/2022/07/26/RESTful%E4%B8%8ESwagger%EF%BC%88%E6%8E%A5%E5%8F%A3%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%EF%BC%89-%20SpringBoot%EF%BC%8817%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-认识REST"><a href="#1-认识REST" class="headerlink" title="1.认识REST"></a>1.认识REST</h1><h2 id="1-1什么是REST"><a href="#1-1什么是REST" class="headerlink" title="1.1什么是REST"></a>1.1什么是REST</h2><p>  REST是软件架构的规范体系结构，它将资源的状态以适合客户端的形式从服务器端发送到客户端（或相反方向）。在REST中,通过URL进行资源定位，用https动作GET、POST、DELETE、PUSH等）描述操作，完成功能。</p><p>  道循RESTful风格，可以使开发的接口通用，以便调用者理解接口的作用。基于REST构建的 API 就是 RESTful （ REST 风格）API.</p><p>  各大机构提供的API基本都是RESTful风格的。这样可以统一规范，减少沟通、学习和开发 的成本。</p><h2 id="1-2-REST的特征"><a href="#1-2-REST的特征" class="headerlink" title="1.2 REST的特征"></a>1.2 REST的特征</h2><ul><li>客户一服务器（client-server）:提供服务的服务器和使用服务的客户端需要被隔离对待。</li><li>无状态（stateless）:服务器端不存储客户的请求中的信息，客户的每一个请求必须包含服务器处理该请求所需的所有信息，所有的资源都可以通过URI定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而变化。</li></ul><p>  Restful是典型的基于https的协议。https连接最显著的特点是：客户端发送的每次请求都需要服务器回送响应；在请求结束后，主动释放连接：</p><p>  从建立连接到关闭连接的过程称为“一次连接”，前后的请求没有必然的联系，所以是无状态的</p><p>  可缓存(cachable)：服务器必须让客户知道请求是否可以被缓存。</p><ul><li><p>分层系统(layered System):服务器和客户之间的通信必须被标准化。</p></li><li><p>统一接口 (uniform interface):客户和服务器之间通信的方法必须统一，REStful风格的 数据元操作 CRUD (create、read、update, delete)分别对应 https 方法—— GET 用来获取资源，POST用来新建资源，PUT用来更新资源，DELETE用来删除资源，这样就统一了数据操作的接口。</p></li><li><p>https状态码：状态码在REST中都有特定的意义：200、201、_202__、_204、400、401、 403、500，比如，401表示用户身份认证失败；403表示验证身份通过了，但资源没有权限进行操作。</p></li><li><p>支持按需代码(Code-On-Demand,可选)：服务器可以提供一些代码或脚本，并在客户的运行环境中执行。</p></li></ul><h2 id="1-3-认识https方法与CRUD动作映射"><a href="#1-3-认识https方法与CRUD动作映射" class="headerlink" title="1.3 认识https方法与CRUD动作映射"></a>1.3 认识https方法与CRUD动作映射</h2><p>RESTful风格使用同一个URL,通过约定不同的https方法来实施不同的业务。 普通网页的CRUD和RESTful风格的CRUD的区别，见下表。</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/RESTful%E4%B8%8ESwagger%EF%BC%88%E6%8E%A5%E5%8F%A3%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%EF%BC%89-%20SpringBoot%EF%BC%8817%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><p>  可以看出，RESTful风格的CRUD比传统的CRUD简单明了，它通过https方法来区分增加、修改、删除和查询。</p><h2 id="1-4-实现RESTfuI风格的数据增加、删除、修改和查询"><a href="#1-4-实现RESTfuI风格的数据增加、删除、修改和查询" class="headerlink" title="1.4 实现RESTfuI风格的数据增加、删除、修改和查询"></a>1.4 实现RESTfuI风格的数据增加、删除、修改和查询</h2><p>在SpringBoot中，如果要返回JSON数据，则只需要在控制器中用@RestController注解。 如果提交https方法，则只需要使用注解@RequestMapping来实现，它有以下两个属性。</p><ul><li>Value：用来制定URI。</li><li>Method：用来制定https请求方法。</li></ul><p>  为了不重复编码，尽量在类上使用@RequestMapping(“”)来指定上一级URL</p><p>  使用RESTful风格操作数据的方法见以下代码。</p><h3 id="（1）获取列表采用的是GET方式，返回List，例如，下面代码返回User的List。"><a href="#（1）获取列表采用的是GET方式，返回List，例如，下面代码返回User的List。" class="headerlink" title="（1）获取列表采用的是GET方式，返回List，例如，下面代码返回User的List。"></a>（1）获取列表采用的是GET方式，返回List，例如，下面代码返回User的List。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUserList</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;(userRepository.findAll());</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）增加内容-提交内容-采用的是POST方式，一般返回String类型或int类型的数据，见-以下代码："><a href="#（2）增加内容-提交内容-采用的是POST方式，一般返回String类型或int类型的数据，见-以下代码：" class="headerlink" title="（2）增加内容(提交内容)采用的是POST方式，一般返回String类型或int类型的数据，见 以下代码："></a>（2）增加内容(提交内容)采用的是POST方式，一般返回String类型或int类型的数据，见 以下代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    userRepository.save(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）删除内容，必须采用DEIETE方法。一般都是根据id主键进行删除的"><a href="#（3）删除内容，必须采用DEIETE方法。一般都是根据id主键进行删除的" class="headerlink" title="（3）删除内容，必须采用DEIETE方法。一般都是根据id主键进行删除的"></a>（3）删除内容，必须采用DEIETE方法。一般都是根据id主键进行删除的</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span>&#123;</span><br><span class="line">    userRepository.deleteById(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）修改内容，则采用PUT方法。"><a href="#（4）修改内容，则采用PUT方法。" class="headerlink" title="（4）修改内容，则采用PUT方法。"></a>（4）修改内容，则采用PUT方法。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.PUT)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    userRepository.save(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）查询内容，和上面获取列表的方法一样，也是采用GET方法。"><a href="#（5）查询内容，和上面获取列表的方法一样，也是采用GET方法。" class="headerlink" title="（5）查询内容，和上面获取列表的方法一样，也是采用GET方法。"></a>（5）查询内容，和上面获取列表的方法一样，也是采用GET方法。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span>&#123;</span><br><span class="line">    Optional&lt;User&gt; user = userRepository.findById(id.longValue());</span><br><span class="line">    <span class="keyword">return</span> user.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  对于RESTful风格的增加、删除、修改和查询，可以编写测试单元，也可以用Postman测试, 分别用GET、POST、PUT、DELETE方法提交测试。虽然这样实现了 RESTful风格，但还有一 个问题——返回的数据并不统一，在实际生产环境中还需要进行改进,所以需要设计统一的RESTful 风格的数据接口。</p><h1 id="2-设计统一的RESTful-风格的数据接口"><a href="#2-设计统一的RESTful-风格的数据接口" class="headerlink" title="2.设计统一的RESTful 风格的数据接口"></a>2.设计统一的RESTful 风格的数据接口</h1><p>  近年来，随着移动互联网的发展，各种类型的客户端层岀不穷。如果不统一数据接口，则会造成冗余编码，增加成本。RESTful风格的API正适合通过一套统一的接口为PC、手机APP等设备提供数据服务。</p><h2 id="2-1-版本控制"><a href="#2-1-版本控制" class="headerlink" title="2.1 版本控制"></a>2.1 版本控制</h2><p>  随着业务需求的变更、功能的迭代，API的更改是不可避免的。当一个API修改时，就会出现很多问题，比如，可能会在API中新增参数、修改返回的数据类型。这就要考虑根据原先版本API 编写的客户端如何保留或顺利过渡。所以，需要进行版本控制。</p><p>  REST不提供版本控制指南，常用的方法可以分为3种。</p><h3 id="（1）通过URL"><a href="#（1）通过URL" class="headerlink" title="（1）通过URL"></a>（1）通过URL</h3><p>  通过URL是最直接的方法，尽管它违背了 URI应该引用唯一资源的原则。当版本更新时，还可以保障客户端不会受到影响，如下面使用不同URL来确定不同版本。</p><p>二级目录的方式：</p><ul><li>API 版本 V1: https:&#x2F;&#x2F; eg.com&#x2F;api&#x2F;v1</li><li>API 版本 V2： <a href="https://eg.com/api/v2">https://eg.com/api/v2</a></li></ul><p>  二级域名的方式：</p><ul><li>API 版本 V1： <a href="https://v1.eg.com/">https://v1.eg.com</a></li><li>API 版本 V2： <a href="https://v2.eg.com/">https://v2.eg.com</a></li></ul><p>  还可以包括日期、项目名称或其他标识符。这些标识符对于开发API的团队来说足够有意义， 并旦随着版本的变化也足够灵活。</p><h3 id="（2）通过自定义请求头"><a href="#（2）通过自定义请求头" class="headerlink" title="（2）通过自定义请求头"></a>（2）通过自定义请求头</h3><p>自定义头（例如，Accept-version）允许在版本之间保留URL。</p><h3 id="（3）通过Accept标头"><a href="#（3）通过Accept标头" class="headerlink" title="（3）通过Accept标头"></a>（3）通过Accept标头</h3><p>  客户端在请求资源之前，必须要指定特定头，然后API接口负责确定要发送哪个版本的资源</p><h2 id="2-2-过滤信息"><a href="#2-2-过滤信息" class="headerlink" title="2.2 过滤信息"></a>2.2 过滤信息</h2><p>  如果记录数量很务，则服务器不可能一次都将它们返回给用户。API应该提供参数，实现分页返回結果。下面是一些常用的参数</p><ul><li>?limit&#x3D;10：指定返回记录的数量。</li><li>?page&#x3D;5&amp;size&#x3D;10：指定第几页，以及每页的记录数。</li><li>?search_type&#x3D;1:指定筛选条件。</li></ul><h3 id="2-3-确定https的方法"><a href="#2-3-确定https的方法" class="headerlink" title="2.3 确定https的方法"></a>2.3 确定https的方法</h3><p>在RESTful中，https的方法有以下几种。</p><ul><li>GET：代表请求资源。</li><li>POST：代表添加资源。</li><li>PUT：代表修改资源。PUT是进行全部的修改，大家在编写修改功能时可能会遇到这样的情况：只修改了一个字段，但提交之后导致其他字段为空。这是因为，其他字段的值没有一 起提交，数据库默认为空值。如果只修改一个或几个字段，则可以使用PATCH方法。</li><li>DELETE：代表删除资源。</li><li>HEAD：代表发送https头消息，GET中其实也带了 https头消息。</li><li>PATCH： PUT与PATCH方法比较相似，但它们的用法却完全不同，PUT用于替换资源, 而PATCH用于更新部分资源。</li><li>OPTIONS：用于获取URI所支持的方法。返回的响应消息会在https头中包含”Allow” 的信息，其值是所支持的方法，如GET。</li></ul><h2 id="2-4-确定https的返回状态"><a href="#2-4-确定https的返回状态" class="headerlink" title="2.4 确定https的返回状态"></a>2.4 确定https的返回状态</h2><p>https的返回状态一般有以下几种。</p><ul><li>200：成功。</li><li>400：错误请求。</li><li>404：没找到资源。</li><li>403：禁止。</li><li>406：不能使用请求内容特性来响应请求资源，比如请求的是HTML文件，但是消费者的 https头包含了 JSON要求。</li><li>500：服务器内部错误。</li></ul><h2 id="2-5定义统一返回的格式"><a href="#2-5定义统一返回的格式" class="headerlink" title="2.5定义统一返回的格式"></a>2.5定义统一返回的格式</h2><p>为了保障前后端的数据交互的顺畅，建议规范数据的返回，并采用固定的数据格式封装。如，</p><p>异常信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;code&quot;</span>:<span class="string">&quot;10001&quot;</span>,</span><br><span class="line">    <span class="string">&quot;msg&quot;</span>:<span class="string">&quot;异常信息&quot;</span>,</span><br><span class="line">    <span class="string">&quot;data&quot;</span>:<span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;code&quot;</span>:<span class="number">200</span>,</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:<span class="string">&quot;成功&quot;</span>,</span><br><span class="line"><span class="string">&quot;data&quot;</span>:&#123;</span><br><span class="line"><span class="string">&quot;id&quot;</span>:<span class="number">1</span>,</span><br><span class="line"><span class="string">&quot;name&quot;</span>:<span class="string">&quot;buretuzi&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-为手机APP、PC、H5网页提供统一风格的API"><a href="#2-6-为手机APP、PC、H5网页提供统一风格的API" class="headerlink" title="2.6 为手机APP、PC、H5网页提供统一风格的API"></a>2.6 为手机APP、PC、H5网页提供统一风格的API</h2><h3 id="（1）实现响应的枚举类"><a href="#（1）实现响应的枚举类" class="headerlink" title="（1）实现响应的枚举类"></a>（1）实现响应的枚举类</h3><p>  枚举是一种特殊的数据类型，它是一种”类类型”，比类型多了一些特殊的约束。创建枚举类型要使用“enum”，表示所创建的类型都是java.lang.Enum（抽象类）的子类。见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ExceptionMsg</span> &#123;</span><br><span class="line">    SUCCESS(<span class="string">&quot;200&quot;</span>,<span class="string">&quot;操作成功&quot;</span>),</span><br><span class="line">    FAILED(<span class="string">&quot;999999&quot;</span>,<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ExceptionMsg</span><span class="params">(String code,String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）实现返回的对象实体"><a href="#（2）实现返回的对象实体" class="headerlink" title="（2）实现返回的对象实体"></a>（2）实现返回的对象实体</h3><p>  实现返回的对象实体，返回Code和Message (信息)，见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Response</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String rspCode=<span class="string">&quot;200&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String rspMsg=<span class="string">&quot;操作成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）封装返回结果"><a href="#（3）封装返回结果" class="headerlink" title="（3）封装返回结果"></a>（3）封装返回结果</h3><p>这里把返回的结果逬行封装，以显示数据，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Response;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReponseData</span> <span class="keyword">extends</span> <span class="title class_">Response</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReponseData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）统一处理异常"><a href="#（4）统一处理异常" class="headerlink" title="（4）统一处理异常"></a>（4）统一处理异常</h3><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.itheima.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.exception.BusinessException;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.https.httpsStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.https.converter.httpsMessageNotReadableException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindingResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.FieldError;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.httpsMediaTypeNotSupportedException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.httpsRequestMethodNotSupportedException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MissingServletRequestParameterException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintViolation;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintViolationException;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ValidationException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line">    <span class="meta">@ResponseStatus(httpsStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MissingServletRequestParameterException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handleMissingServletRequestParameterException</span><span class="params">(MissingServletRequestParameterException e)</span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;缺少请求参数&quot;</span>);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,<span class="number">400</span>);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="comment">//如果发生异常，则进行日志记录、写入数据库或其他处理，此处省略</span></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseStatus(httpsStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(httpsMessageNotReadableException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handlehttpsMessageNotReadableException</span><span class="params">(httpsMessageNotReadableException e)</span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;缺少请求参数&quot;</span>);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,<span class="number">400</span>);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="comment">//如果发生异常，则进行日志记录、写入数据库或其他处理，此处省略</span></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ResponseStatus(httpsStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handleMethodArgumentNotValidException</span><span class="params">(MethodArgumentNotValidException e)</span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;参数验证失败&quot;</span>,e);</span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">result</span> <span class="operator">=</span> e.getBindingResult();</span><br><span class="line">        <span class="type">FieldError</span> <span class="variable">error</span> <span class="operator">=</span> result.getFieldError();</span><br><span class="line">        <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> error.getField();</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> error.getDefaultMessage();</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s: %s&quot;</span>,field,code);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>,message);</span><br><span class="line">        <span class="comment">//如果发生异常，则进行日志记录、写入数据库或其他处理，此处省略</span></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ResponseStatus(httpsStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BindException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handleBindException</span><span class="params">(BindException e)</span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;缺少请求参数&quot;</span>,e);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">result</span> <span class="operator">=</span> e.getBindingResult();</span><br><span class="line">        <span class="type">FieldError</span> <span class="variable">error</span> <span class="operator">=</span> result.getFieldError();</span><br><span class="line">        <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> error.getField();</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> error.getDefaultMessage();</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s: %s&quot;</span>,field,code);</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>,message);</span><br><span class="line">        <span class="comment">//如果发生异常，则进行日志记录、写入数据库或其他处理，此处省略</span></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ResponseStatus(httpsStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ConstraintViolationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handleConstraintViolationException</span><span class="params">(ConstraintViolationException e)</span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;缺少请求参数&quot;</span>,e);</span><br><span class="line">        Set&lt;ConstraintViolation&lt;?&gt;&gt; violations = e.getConstraintViolations();</span><br><span class="line">        ConstraintViolation&lt;?&gt; violation = violations.iterator().next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> violation.getMessage();</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,<span class="number">400</span>);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>,message);</span><br><span class="line">        <span class="comment">//如果发生异常，则进行日志记录、写入数据库或其他处理，此处省略</span></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ResponseStatus(httpsStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ValidationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handleValidationException</span><span class="params">(ValidationException e)</span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;参数验证失败&quot;</span>,e);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,<span class="number">400</span>);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="comment">//如果发生异常，则进行日志记录、写入数据库或其他处理，此处省略</span></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ResponseStatus(httpsStatus.METHOD_NOT_ALLOWED)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(httpsRequestMethodNotSupportedException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handlehttpsRequestMethodNotSupportedException</span><span class="params">(httpsRequestMethodNotSupportedException e)</span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;不支持当前请求方法&quot;</span>,e);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,<span class="number">400</span>);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="comment">//如果发生异常，则进行日志记录、写入数据库或其他处理，此处省略</span></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ResponseStatus(httpsStatus.UNSUPPORTED_MEDIA_TYPE)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(httpsMediaTypeNotSupportedException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handlehttpsMediaTypeNotSupportedException</span><span class="params">(httpsMediaTypeNotSupportedException e)</span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;不支持当前媒体类型&quot;</span>,e);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,<span class="number">415</span>);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="comment">//如果发生异常，则进行日志记录、写入数据库或其他处理，此处省略</span></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">businessExceptionHandler</span><span class="params">(BusinessException e)</span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;自定义业务失败&quot;</span>,e);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,e.getCode());</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="comment">//如果发生异常，则进行日志记录、写入数据库或其他处理，此处省略</span></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">defaultErrorHandler</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;自定义业务失败&quot;</span>,e);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,<span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="comment">//如果发生异常，则进行日志记录、写入数据库或其他处理，此处省略</span></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）编写测试控制器"><a href="#（5）编写测试控制器" class="headerlink" title="（5）编写测试控制器"></a>（5）编写测试控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.exception.BusinessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;BusinessException&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testBusinessExceptionStatus</span><span class="params">(<span class="meta">@RequestParam(&quot;i&quot;)</span> <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="number">600</span>,<span class="string">&quot;这是自定义异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行项目，访问<a href="https://localhost:8080/BusinessException?i=0,%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%A6%82%E4%B8%8B">https://localhost:8080/BusinessException?i=0,在网页中返回如下</a> JSON 格式的数据：</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/RESTful%E4%B8%8ESwagger%EF%BC%88%E6%8E%A5%E5%8F%A3%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%EF%BC%89-%20SpringBoot%EF%BC%8817%EF%BC%89%EF%BC%882%EF%BC%89.png"></p><h3 id="（6）实现数据的增加、删除、修改和查询控制器"><a href="#（6）实现数据的增加、删除、修改和查询控制器" class="headerlink" title="（6）实现数据的增加、删除、修改和查询控制器"></a>（6）实现数据的增加、删除、修改和查询控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.ReponseData;</span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.UserRepository;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Response;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.itheima.exception.ExceptionMsg;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Response <span class="title function_">result</span><span class="params">(ExceptionMsg msg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Response <span class="title function_">result</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> ReponseData <span class="title function_">getUserList</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(userRepository.findAll());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReponseData</span>(ExceptionMsg.SUCCESS,list);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;&quot;,method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> ReponseData <span class="title function_">add</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">        List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(userRepository.findAll());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReponseData</span>(ExceptionMsg.SUCCESS,user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        userRepository.deleteById(id);</span><br><span class="line">        <span class="keyword">return</span> result(ExceptionMsg.SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.PUT)</span></span><br><span class="line">    <span class="keyword">public</span> ReponseData <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReponseData</span>(ExceptionMsg.SUCCESS,user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> ReponseData <span class="title function_">findUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        Optional&lt;User&gt; user = userRepository.findById((<span class="type">long</span>) id);</span><br><span class="line">        <span class="keyword">if</span> (user.get()!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReponseData</span>(ExceptionMsg.SUCCESS,user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReponseData</span>(ExceptionMsg.FAILED,user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-用Swagger实现接口文档"><a href="#3-用Swagger实现接口文档" class="headerlink" title="3. 用Swagger实现接口文档"></a>3. 用Swagger实现接口文档</h1><p>    在项目开发中，一般都是前后端分离开发的，需要由前后端工程师共同定义接口:编写接口文档，之后大家都根据这个接口文档进行开发、维护。为了便于编写和维护稳定，可以使用Swagger来编写API接口文档，以提升团队的沟通效率。</p><h2 id="3-1-配置Swagger"><a href="#3-1-配置Swagger" class="headerlink" title="3.1 配置Swagger"></a>3.1 配置Swagger</h2><h3 id="（1）添加Swagger依赖"><a href="#（1）添加Swagger依赖" class="headerlink" title="（1）添加Swagger依赖"></a>（1）添加Swagger依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（2）创建Swagger配置类"><a href="#（2）创建Swagger配置类" class="headerlink" title="（2）创建Swagger配置类"></a>（2）创建Swagger配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Swagger配置类</span></span><br><span class="line"><span class="comment"> * 在与Spring Boot集成时，放在与Application.java同级的目录下</span></span><br><span class="line"><span class="comment"> * 通过注解<span class="doctag">@Configuration</span>让Spring来加载该类配置</span></span><br><span class="line"><span class="comment"> * 再通过注解<span class="doctag">@EnableSwagger</span>2来启用Swagger2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Configuration</span></span><br><span class="line"> <span class="meta">@EnableSwagger2</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swagger2</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建API应用</span></span><br><span class="line"><span class="comment">     * apiInfo增加API相关信息</span></span><br><span class="line"><span class="comment">     * 通过select()函数返回一个ApiSelectorBuilder实例，用来控制哪些接口暴露给Swagger来展现</span></span><br><span class="line"><span class="comment">     * 本例采用指定扫描的包路径来定义指定要建立API的目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">     <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建该API的基本信息(这些基本信息会展现在文档页面中)</span></span><br><span class="line"><span class="comment">     * 访问地址：https:/项目实际地址/swagger-ui.html</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;RESTful APIs&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;RESTful APIs&quot;</span>)</span><br><span class="line">                .termsOfServiceUrl(<span class="string">&quot;https://localhost:8080/&quot;</span>)</span><br><span class="line">                .contact(<span class="string">&quot;long&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  代码解释如下。</p><ul><li>@Configuration:   让Spring来加载该类配置。</li><li>@EnableSwagger2:  启用 Swagger2.createRestApi 函数创建 Docket 的 Bean</li><li>apilnfo()：用来展示该API的基本信息。</li><li>select()：返回一个ApiSelectorBuilder实例，用来控制哪些接口暴露给Swagger来展现。</li><li>apis(RequestHandlerSelectors.basePackage())：配置包扫描路径。Swagger 会扫描包下所有Controller定义的API,并产生文档内容。如果不想产生API,则使用注解 @Apilgnore</li></ul><h3 id="（3）编写接口文档"><a href="#（3）编写接口文档" class="headerlink" title="（3）编写接口文档"></a>（3）编写接口文档</h3><p>在完成上述配置后，即生成了文档，但是这样生成的文档主要针对请求本身，而描述自动根据方法等命名产生，对用户并不友好。所以，通常需要自己增加一些说明以丰富文档内容。可以通过以下注解来增加说明。</p><ul><li>@Api：描述类&#x2F;接口的主要用途。</li><li>@ApiOperation：描述方法用途，给API增加说明。</li><li>@ApilmplicitParam:   挡述方法的参数，给参数増加说距。</li><li>@ApilmplicitParams:   描述方法的参数(Multi-Params ),给参数增加说明。</li><li>@Apilgnore：忽略某类&#x2F;方法&#x2F;参数的义档。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;删除用户&quot;,notes = &quot;根据URL的id来指定删除对象&quot;)</span></span><br><span class="line"><span class="meta">@ApiImplicitParam(name = &quot;id&quot;,value = &quot;文章ID&quot;,required = true,dataType = &quot;Long&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">del</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    userRepository.deleteById(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  完成上述代码后，启动项目，访问<a href="https://localhost:8080/swagger-ui.html%E5%B0%B1%E8%83%BD%E7%9C%8B%E5%88%B0%E6%89%80%E5%B1%95%E7%A4%BA%E7%9A%84RESTful">https://localhost:8080/swagger-ui.html就能看到所展示的RESTful</a> API的页面，可以通过单击具体的API测试请求，来查看代码中配置的信息，以及参数的描述信息。</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/RESTful%E4%B8%8ESwagger%EF%BC%88%E6%8E%A5%E5%8F%A3%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%EF%BC%89-%20SpringBoot%EF%BC%8817%EF%BC%89%EF%BC%883%EF%BC%89.png"></p><h2 id="3-2-用RestTemplate发起请求"><a href="#3-2-用RestTemplate发起请求" class="headerlink" title="3.2 用RestTemplate发起请求"></a>3.2 用RestTemplate发起请求</h2><h3 id="（1）认识-RestTemplate"><a href="#（1）认识-RestTemplate" class="headerlink" title="（1）认识 RestTemplate"></a>（1）认识 RestTemplate</h3><p>在Java应用程序中访问RESTful服务，可以使用Apache的httpsClient来实现。不过此方法使用起来太烦琐。Spring提供了一种简单便捷的模板类一RestTemplate来进行操作。RestTemplate是Spring提供的用于访问REST服务的客户端，它提供了多种便捷访问远程https 服务的方法，能够大大提高客户端的编写效率。</p><p>  RestTemplate用于同步Client端的核心类，简化与https服务的通信。在默认情况下， RestTemplate默认依赖JDK的https连接工具。也可以通过setRequestFactory属性切换到不同的 https 源，比如 Apache httpsComponents, Netty 和 Okhttps。</p><p>  RestTemplate简化了提交表单数据的难度，并附帯自动转换为JSON格式数据的功能。该类的入口主要是根据https的6种方法制定的，见下表。</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/RESTful%E4%B8%8ESwagger%EF%BC%88%E6%8E%A5%E5%8F%A3%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%EF%BC%89-%20SpringBoot%EF%BC%8817%EF%BC%89%EF%BC%884%EF%BC%89.png"></p><p>  此外，exchange和excute也可以使用上述方法。</p><p>  RestTemplate 默认使用 httpsMessageConverter 将 https 消息转换成 POJO，或从 POJO 转换成https消息，默认情况下会注册MIME类型的转换器，但也可以通过setMessageConverters 注册其他类型的转换器。</p><h3 id="（2）用-RestTemplate-发送-GET-请求"><a href="#（2）用-RestTemplate-发送-GET-请求" class="headerlink" title="（2）用 RestTemplate 发送 GET 请求"></a>（2）用 RestTemplate 发送 GET 请求</h3><h4 id="1-创建测试实体"><a href="#1-创建测试实体" class="headerlink" title="1.创建测试实体"></a>1.创建测试实体</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-创建用于测试的API"><a href="#2-创建用于测试的API" class="headerlink" title="2.创建用于测试的API"></a>2.创建用于测试的API</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/getParameter&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getParameter</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/getuser1&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;buretuzi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/postuser&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">postUser</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name：&quot;</span>+user.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;id：&quot;</span>+user.getId());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-使用getForEntity测试"><a href="#3-使用getForEntity测试" class="headerlink" title="3.使用getForEntity测试"></a>3.使用getForEntity测试</h4><h5 id="（1）返回String-不带参数，见以下代码："><a href="#（1）返回String-不带参数，见以下代码：" class="headerlink" title="（1）返回String,不带参数，见以下代码："></a>（1）返回String,不带参数，见以下代码：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.client.RestTemplateBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.https.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nparameters</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">RestTemplateBuilder</span> <span class="variable">restTemplateBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplateBuilder</span>();</span><br><span class="line">        <span class="type">RestTemplate</span> <span class="variable">client</span> <span class="operator">=</span> restTemplateBuilder.build();</span><br><span class="line">        ResponseEntity&lt;String&gt; responseEntity = client.getForEntity(<span class="string">&quot;https://localhost:8080/getuser1&quot;</span>,String.class);</span><br><span class="line">        System.out.println(responseEntity.getBody());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  控制台打印结果：</p><p><code>  11:01:35.973 [main] DEBUG org.springframework.web.client.RestTemplate - https GET https://localhost:8080/getuser1</code><br><code>  11:01:35.991 [main] DEBUG org.springframework.web.client.RestTemplate - Accept=[text/plain, application/json, application/*+json, */*]</code><br><code>  11:01:36.073 [main] DEBUG org.springframework.web.client.RestTemplate - Response 200 OK</code><br><code>  11:01:36.073 [main] DEBUG org.springframework.web.client.RestTemplate - Reading to [java.lang.String] as &quot;application/json&quot;</code><br><code>  &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;buretuzi&quot;&#125;</code></p><h5 id="（2）返回String-带参数的例子。"><a href="#（2）返回String-带参数的例子。" class="headerlink" title="（2）返回String,带参数的例子。"></a>（2）返回String,带参数的例子。</h5><p>     在调用服务提供者提供的接口时，有时需要传递参数，有以下两种不同的方式。</p><p>    ①用一个数字做占位符。最后是一个可变长度的参数，用来替换前面的占位符。使用方法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withparameters</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RestTemplateBuilder</span> <span class="variable">restTemplateBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplateBuilder</span>();</span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">client</span> <span class="operator">=</span> restTemplateBuilder.build();</span><br><span class="line">    ResponseEntity&lt;String&gt; responseEntity = client.getForEntity(<span class="string">&quot;https://localhost:8080/getParameter?name=&#123;1&#125;&amp;id=&#123;2&#125;&quot;</span>,String.class,<span class="string">&quot;buretuzi&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(responseEntity.getBody());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  打印结果：</p><p><code>  11:06:20.893 [main] DEBUG org.springframework.web.client.RestTemplate - https GET https://localhost:8080/getParameter?name=buretuzi&amp;id=2</code><br><code>  11:06:20.893 [main] DEBUG org.springframework.web.client.RestTemplate - Accept=[text/plain, application/json, application/*+json, */*]</code><br><code>  11:06:20.908 [main] DEBUG org.springframework.web.client.RestTemplate - Response 200 OK</code><br><code>  11:06:20.908 [main] DEBUG org.springframework.web.client.RestTemplate - Reading to [java.lang.String] as &quot;application/json&quot;</code><br><code>  &#123;&quot;id&quot;:2,&quot;name&quot;:&quot;buretuzi&quot;&#125;</code></p><p>   ② 使用name&#x3D;{name}这种形式。最后一个参数是一个map, map的key即为前边占位符的名字，map的value为参数值。使用方法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withparameters2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RestTemplateBuilder</span> <span class="variable">restTemplateBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplateBuilder</span>();</span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">client</span> <span class="operator">=</span> restTemplateBuilder.build();</span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;buretuzi&quot;</span>);</span><br><span class="line">    ResponseEntity&lt;String&gt; responseEntity = client.getForEntity(<span class="string">&quot;https://localhost:8080/getParameter?name=&#123;name&#125;&amp;id=3&quot;</span>,String.class,map);</span><br><span class="line">    System.out.println(responseEntity.getBody());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  打印结果：</p><p><code>  11:19:28.842 [main] DEBUG org.springframework.web.client.RestTemplate - https GET https://localhost:8080/getParameter?name=buretuzi&amp;id=3</code><br><code>  11:19:28.848 [main] DEBUG org.springframework.web.client.RestTemplate - Accept=[text/plain, application/json, application/*+json, */*]</code><br><code>  11:19:28.880 [main] DEBUG org.springframework.web.client.RestTemplate - Response 200 OK</code><br><code>  11:19:28.880 [main] DEBUG org.springframework.web.client.RestTemplate - Reading to [java.lang.String] as &quot;application/json&quot;</code><br><code>  &#123;&quot;id&quot;:3,&quot;name&quot;:&quot;buretuzi&quot;&#125;  </code></p><h5 id="（3）返回对象，见以下代码："><a href="#（3）返回对象，见以下代码：" class="headerlink" title="（3）返回对象，见以下代码："></a>（3）返回对象，见以下代码：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RestTemplateBuilder</span> <span class="variable">restTemplateBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplateBuilder</span>();</span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">client</span> <span class="operator">=</span> restTemplateBuilder.build();</span><br><span class="line">    ResponseEntity&lt;User&gt; responseEntity = client.getForEntity(<span class="string">&quot;https://localhost:8080/getuser1&quot;</span>,User.class);</span><br><span class="line">    System.out.println(responseEntity.getBody().getId());</span><br><span class="line">    System.out.println(responseEntity.getBody().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  打印结果：</p><p><code>    1</code><br><code>    buretuzi</code></p><h4 id="4-使用-getForObject"><a href="#4-使用-getForObject" class="headerlink" title="4.使用 getForObject"></a>4.使用 getForObject</h4><p>getForObject函数是对getForEntity函数的进一步封装。如果你只关注返回的消息体的内容, 对其他信息都不关注，则可以使用getForObject,见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getForObject</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RestTemplateBuilder</span> <span class="variable">restTemplateBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplateBuilder</span>();</span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">client</span> <span class="operator">=</span> restTemplateBuilder.build();</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> client.getForObject(<span class="string">&quot;https://localhost:8080/getuser1&quot;</span>,User.class);</span><br><span class="line">    System.out.println(user.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）用-RestTemplate-发送-POST-请求"><a href="#（3）用-RestTemplate-发送-POST-请求" class="headerlink" title="（3）用 RestTemplate 发送 POST 请求"></a>（3）用 RestTemplate 发送 POST 请求</h3><p>在 RestTemplate 中，POST 请求可以通过 postForEntity、postForObject、postForLocation、exchange四种方法来发起。</p><h4 id="1-方法一：使用-postForEntity"><a href="#1-方法一：使用-postForEntity" class="headerlink" title="1.方法一：使用 postForEntity"></a>1.方法一：使用 postForEntity</h4><ul><li>postForEntity(String url,Object request,Class responseType,Object… urlVariables)</li><li>postForEntity(String url,Object request,Class responseType,Map urlVariables)</li><li>postForEntity(String url,Object request,Class responseType)</li></ul><h4 id="2-方法二：使用-postForObject"><a href="#2-方法二：使用-postForObject" class="headerlink" title="2.方法二：使用 postForObject"></a>2.方法二：使用 postForObject</h4><ul><li>postForObject(String url,Object request,Class responseType,Object… urlVariables)</li><li>postForObject(String url,Object request,Class responseType,Map urlVariables)</li><li>postForObject(String url,Object request,Class responseType)</li></ul><h4 id="3-方法三：使用-postForLocation"><a href="#3-方法三：使用-postForLocation" class="headerlink" title="3.方法三：使用 postForLocation"></a>3.方法三：使用 postForLocation</h4><p>postForLocation也用于提交资源。在提交成功之后，会返回新资源的URI。它的参数和前面两种方法的参数基本一致，只不过该方法的返回值为URI,表示新资源的位置</p><ul><li>postForLocation(String url,Object request,Object… urlVariables)</li><li>postForLocation(String url,Object request,Map urlVariables)</li><li>postForLocation(String url,Object request)</li></ul><h4 id="4-方法四：使用exchange"><a href="#4-方法四：使用exchange" class="headerlink" title="4.方法四：使用exchange"></a>4.方法四：使用exchange</h4><p>使用exchange方法可以指定调用方式，使用方法如下：</p><p>  ResponseEntity<String> response&#x3D;tempIate.exchang(newUrl, httpsMethod.DELETE, request, String.class);</p><h4 id="5-实现发送POST请求"><a href="#5-实现发送POST请求" class="headerlink" title="5.实现发送POST请求"></a>5.实现发送POST请求</h4><h5 id="（1）使用-postForEntity"><a href="#（1）使用-postForEntity" class="headerlink" title="（1）使用 postForEntity"></a>（1）使用 postForEntity</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postForEntity</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RestTemplateBuilder</span> <span class="variable">restTemplateBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplateBuilder</span>();</span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">client</span> <span class="operator">=</span> restTemplateBuilder.build();</span><br><span class="line">    MultiValueMap&lt;String,Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;String,Object&gt;();</span><br><span class="line">    paramMap.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;buretuzi&quot;</span>);</span><br><span class="line">    paramMap.add(<span class="string">&quot;id&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    ResponseEntity&lt;User&gt; responseEntity = client.postForEntity(<span class="string">&quot;https://localhost:8080/postuser&quot;</span>,paramMap,User.class);</span><br><span class="line">    System.out.println(responseEntity.getBody().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  代码解释如下。</p><ul><li>MultiValueMap：封装参数，千万不要替换为Map与HashMap,否则参数无法被传递</li><li>postForEntity(“url”, paramMap, User.class)：参数分别表示要调用的服务的地址、上传的参数、返回的消息体的数据类型。</li></ul><p>  运行测试单元，控制台输出如下结果：</p><p><code>  11:39:07.001 [main] DEBUG org.springframework.web.client.RestTemplate - https POST https://localhost:8080/postuser</code><br><code>  11:39:07.032 [main] DEBUG org.springframework.web.client.RestTemplate - Accept=[application/json, application/*+json]</code><br><code>  11:39:07.032 [main] DEBUG org.springframework.web.client.RestTemplate - Writing [&#123;name=[buretuzi], id=[4]&#125;] with           org.springframework.https.converter.support.AllEncompassingFormhttpsMessageConverter</code><br><code>  11:39:07.482 [main] DEBUG org.springframework.web.client.RestTemplate - Response 200 OK</code><br><code>  11:39:07.482 [main] DEBUG org.springframework.web.client.RestTemplate - Reading to [com.intehel.domain.User]</code><br><code>  buretuzi </code> </p><h5 id="（2）使用-postForObject"><a href="#（2）使用-postForObject" class="headerlink" title="（2）使用 postForObject"></a>（2）使用 postForObject</h5><p>postForObject和getForObject相对应，只关注返回的消息体，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postForObject</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RestTemplateBuilder</span> <span class="variable">restTemplateBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplateBuilder</span>();</span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">client</span> <span class="operator">=</span> restTemplateBuilder.build();</span><br><span class="line">    MultiValueMap&lt;String,Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;String,Object&gt;();</span><br><span class="line">    paramMap.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;buretuzi&quot;</span>);</span><br><span class="line">    paramMap.add(<span class="string">&quot;id&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> client.postForObject(<span class="string">&quot;https://localhost:8080/postuser&quot;</span>,paramMap,String.class);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试单元，控制台输岀如下结果：</p><p><code>  11:44:46.470 [main] DEBUG org.springframework.web.client.RestTemplate - https POST https://localhost:8080/postuser</code><br><code>  11:44:46.470 [main] DEBUG org.springframework.web.client.RestTemplate - Accept=[text/plain, application/json, application/*+json, */*]</code><br><code>  11:44:46.486 [main] DEBUG org.springframework.web.client.RestTemplate - Writing [&#123;name=[buretuzi], id=[4]&#125;] with org.springframework.https.converter.support.AllEncompassingFormhttpsMessageConverter</code><br><code>  11:44:46.918 [main] DEBUG org.springframework.web.client.RestTemplate - Response 200 OK</code><br><code>  11:44:46.918 [main] DEBUG org.springframework.web.client.RestTemplate - Reading to [java.lang.String] as &quot;application/json&quot;</code><br><code>  &#123;&quot;id&quot;:4,&quot;name&quot;:&quot;buretuzi&quot;&#125; </code></p><h5 id="（3）使用postForexchange-见以下代码："><a href="#（3）使用postForexchange-见以下代码：" class="headerlink" title="（3）使用postForexchange,见以下代码："></a>（3）使用postForexchange,见以下代码：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postForExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    MultiValueMap&lt;String,Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;String,Object&gt;();</span><br><span class="line">    paramMap.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;buretuzi&quot;</span>);</span><br><span class="line">    paramMap.add(<span class="string">&quot;id&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="type">RestTemplateBuilder</span> <span class="variable">restTemplateBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplateBuilder</span>();</span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">client</span> <span class="operator">=</span> restTemplateBuilder.build();</span><br><span class="line">    <span class="type">httpsHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">httpsHeaders</span>();</span><br><span class="line">    httpsEntity&lt;MultiValueMap&lt;String,Object&gt;&gt; httpsEntity = <span class="keyword">new</span> <span class="title class_">httpsEntity</span>&lt;MultiValueMap&lt;String,Object&gt;&gt;(paramMap,headers);</span><br><span class="line">    ResponseEntity&lt;String&gt; response = client.exchange(<span class="string">&quot;https://localhost:8080/postuser&quot;</span>, httpsMethod.POST, httpsEntity,String.class,paramMap);</span><br><span class="line">    System.out.println(response.getBody());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试单元，控制台输岀如下结果：</p><p><code>  11:59:12.988 [main] DEBUG org.springframework.web.client.RestTemplate - https POST https://localhost:8080/postuser</code><br><code>  11:59:13.004 [main] DEBUG org.springframework.web.client.RestTemplate - Accept=[text/plain, application/json, application/*+json, */*]</code><br><code>  11:59:13.004 [main] DEBUG org.springframework.web.client.RestTemplate - Writing [&#123;name=[buretuzi], id=[4]&#125;] with org.springframework.https.converter.support.AllEncompassingFormhttpsMessageConverter</code><br><code>  11:59:13.436 [main] DEBUG org.springframework.web.client.RestTemplate - Response 200 OK</code><br><code>  11:59:13.436 [main] DEBUG org.springframework.web.client.RestTemplate - Reading to [java.lang.String] as &quot;application/json&quot;</code><br><code>  &#123;&quot;id&quot;:4,&quot;name&quot;:&quot;buretuzi&quot;&#125;</code></p><h5 id="（4）使用-postForLocation"><a href="#（4）使用-postForLocation" class="headerlink" title="（4）使用 postForLocation"></a>（4）使用 postForLocation</h5><p>它用于提交数据，并获取返回的URI。一般登录、注册都是POST请求，操作完成之后，跳转到某个页面，这种场景就可以使用postForLocation所以，先要添加处理登录的API,见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intehel.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.https.httpsServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;success&quot;,method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">loginSuccess</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;welcome&quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;post&quot;,method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">post</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">                       <span class="meta">@RequestParam(value = &quot;name&quot;,required = false)</span>String name,</span></span><br><span class="line"><span class="params">                       <span class="meta">@RequestParam(value = &quot;password&quot;,required = false)</span>String password,</span></span><br><span class="line"><span class="params">                       <span class="meta">@RequestParam(value = &quot;id&quot;,required = false)</span>Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/success?name=&quot;</span>+name+<span class="string">&quot;&amp;id=&quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  然后使用postForLocation请求，用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postForLocation</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RestTemplateBuilder</span> <span class="variable">restTemplateBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplateBuilder</span>();</span><br><span class="line">    MultiValueMap&lt;String,Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;String,Object&gt;();</span><br><span class="line">    paramMap.add(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;buretuzi&quot;</span>);</span><br><span class="line">    paramMap.add(<span class="string">&quot;id&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">client</span> <span class="operator">=</span> restTemplateBuilder.build();</span><br><span class="line">    <span class="type">URI</span> <span class="variable">response</span> <span class="operator">=</span> client.postForLocation(<span class="string">&quot;https://localhost:8080/post&quot;</span>,paramMap);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行测试单元，控制台输出如下结果:</p><p>  13:59:06.415 [main] DEBUG org.springframework.web.client.RestTemplate - https POST <a href="https://localhost:8080/post">https://localhost:8080/post</a><br>  13:59:06.415 [main] DEBUG org.springframework.web.client.RestTemplate - Writing [{name&#x3D;[buretuzi], id&#x3D;[4]}] with   org.springframework.https.converter.support.AllEncompassingFormhttpsMessageConverter<br>  13:59:06.951 [main] DEBUG org.springframework.web.client.RestTemplate - Response 302 FOUND<br>  <a href="https://localhost:8080/success?name=buretuzi&id=4">https://localhost:8080/success?name=buretuzi&id=4</a></p><h3 id="（4）用-RestTemplate-发送-PUT和DELETE-请求"><a href="#（4）用-RestTemplate-发送-PUT和DELETE-请求" class="headerlink" title="（4）用 RestTemplate 发送 PUT和DELETE 请求"></a>（4）用 RestTemplate 发送 PUT和DELETE 请求</h3><h4 id="1-PUT请求"><a href="#1-PUT请求" class="headerlink" title="1.PUT请求"></a>1.PUT请求</h4><p>  在RestTemplate中，发送“修改”请求和前面介绍的postForEntity方法的参数基本一致, 只是修改请求没有返回值，用法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RestTemplateBuilder</span> <span class="variable">restTemplateBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplateBuilder</span>();</span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">client</span> <span class="operator">=</span> restTemplateBuilder.build();</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;buretuzi&quot;</span>);</span><br><span class="line">    client.put(<span class="string">&quot;https://localhost:8080/&#123;1&#125;&quot;</span>,user,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-DELETE-请求"><a href="#2-DELETE-请求" class="headerlink" title="2.DELETE 请求"></a>2.DELETE 请求</h4><p>删除请求，可以通过调用DELETE方法来实现，用法见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RestTemplateBuilder</span> <span class="variable">restTemplateBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplateBuilder</span>();</span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">client</span> <span class="operator">=</span> restTemplateBuilder.build();</span><br><span class="line">    client.delete(<span class="string">&quot;https://localhost:8080/&#123;1&#125;&quot;</span>,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  最后的“4”用来替換前面的占位符{1}。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis与实现分页- SpringBoot（16）</title>
      <link href="/2022/07/23/Mybatis%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5-%20SpringBoot%EF%BC%8816%EF%BC%89/"/>
      <url>/2022/07/23/Mybatis%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5-%20SpringBoot%EF%BC%8816%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-认识Mybatis"><a href="#1-认识Mybatis" class="headerlink" title="1.认识Mybatis"></a>1.认识Mybatis</h1><p>  MyBatis和JPA一样，也是一款优秀的持久层框架，它支持定制化SQL、存储过程，以及高级映射。它可以使用简单的XML或注解来配置和映射原生信息，将接口和Java的POJOs （ Plain Old Java Objects,普通的Java对象）映射成数据库中的记录。</p><p>  MyBatis 3提供的注解可以取代XML例如，使用注解@Select直接编写SQL完成数据查询; 使用高级注解@SelectProvider还可以编写动态SQL,以应对复杂的业务需求。</p><h1 id="2-Mybatis详细介绍"><a href="#2-Mybatis详细介绍" class="headerlink" title="2.Mybatis详细介绍"></a>2.Mybatis详细介绍</h1><h2 id="2-1-CRUD注解"><a href="#2-1-CRUD注解" class="headerlink" title="2.1 CRUD注解"></a>2.1 CRUD注解</h2><p>増加、删除、修改和查询是主要的业务操作，必须掌握这些基础注解的使用方法。MyBatis提供的操作数据的基础注解有以下4个。</p><ul><li>@Select：用于构建查询语句。</li><li>@Insert：用于构建添加语句。</li><li>@Update：用于构建修改语句。</li><li>@Delete：用于构建删除语句。</li></ul><p>  下面来看看它们具体如何使用，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">queryById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span><span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&#123;&quot;insert into user(name,age) values(#&#123;name&#125;,#&#123;age&#125;)&quot;&#125;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update user set name = #&#123;name&#125;,age = #&#123;age&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateById</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    Page&lt;User&gt; <span class="title function_">getUserList</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从上述代码可以看岀：首先要用@Mapper注解来标注类，把UserMapper这个DAO交给 Spring管理。这样Spring会自动生成一个实现类，不用再写UserMapper的映射文件了。最后使用基础的CRUD注解来添加要实现的功能。</p><h2 id="2-2-映射注解"><a href="#2-2-映射注解" class="headerlink" title="2.2 映射注解"></a>2.2 映射注解</h2><p>MyBatis的映射注解用于建立实体和关系的映射。它有以下3个注解。</p><ul><li>@Results：用于填写结果集的多个字段的映射关系。</li><li>@Result：用于填写结果集的单个字段的映射关系，</li><li>@ResultMap：根据 ID 关联 XML 里面的<resultMap></li></ul><p>  可以在查询SQL的基础上，指定返回的结果集的映射关系。其中，property表示实体对象的属性名，column表示对应的数据库字段名。使用方法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;username&quot;,column = &quot;USERNAME&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;password&quot;,column = &quot;PASSWORD&quot;)</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user &quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h2 id="2-3高级注解"><a href="#2-3高级注解" class="headerlink" title="2.3高级注解"></a>2.3高级注解</h2><h3 id="1-高级注解"><a href="#1-高级注解" class="headerlink" title="1.高级注解"></a>1.高级注解</h3><p>  MyBatis 3.x版本主要提供了以下4个CRUD的高级注解。</p><ul><li>@SelectProvider：用于构建动态查询SQL。</li><li>@lnsertProvider：用于构建动态添加SQL。</li><li>@UpdateProvider：用于构建动态更新SQL。</li><li>@DeleteProvider：用于构建动态删除SQL。</li></ul><p>  高级注解主要用于编写动态SQL，这里以@SelectProvider为例，它主要包含两个注解属性， 其中，type表示工具类，method表示工具类的某个方法(用于返回具体的SQL )。以下代码可以构建动态SQL,实现查询功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.itheima.util.UserSql;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@SelectProvider(type = UserSql.class,method = &quot;listAll&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">listAllUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSql</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">listAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SELECT * FROM user&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-MyBatis3注解的用法举例"><a href="#2-MyBatis3注解的用法举例" class="headerlink" title="2. MyBatis3注解的用法举例"></a>2. MyBatis3注解的用法举例</h3><p>  (1)如果要查询所有的值，则基础CRUD的代码是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>  也可以用映射注解来一一映射，见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;id&quot;,column = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;name&quot;,column = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;age&quot;,column = &quot;age&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">listAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>  (2)用多个参数进行查询。</p><p>  如果要用多个参数逬行查询，则必须加上注解@Param,否则无法使用EL表达式获取参数.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user where name like #&#123;name&#125; and age like #&#123;age&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">getUserByNameAndAge</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;age&quot;)</span> <span class="type">int</span> age)</span>;</span><br></pre></td></tr></table></figure><p>  还可以根据官方提供的API来编写动态SQL</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;age&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>()&#123;&#123;</span><br><span class="line">        SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        FROM(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="literal">null</span> &amp;&amp; age != <span class="number">0</span>)&#123;</span><br><span class="line">            WHERE(<span class="string">&quot;name like #&#123;name&#125; and age like #&#123;age&#125;&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            WHERE(<span class="string">&quot;1=2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-实例：用MyBatis实现数据的增加、删除、修改、查询和分页"><a href="#3-实例：用MyBatis实现数据的增加、删除、修改、查询和分页" class="headerlink" title="3.实例：用MyBatis实现数据的增加、删除、修改、查询和分页"></a>3.实例：用MyBatis实现数据的增加、删除、修改、查询和分页</h3><p>  （1）创建实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  （2）实现实体和数据表的映射关系</p><p>  实现实体和数据表的映射关系可以在Mapper类上添加注解@Mapper,见以下代码。建议以 后直接在入口类加@MapperScan(“ com.itheima.mapper”),如果対每个 Mapper 都加注解则很麻烦</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">queryById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span><span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&#123;&quot;insert into user(name,age) values(#&#123;name&#125;,#&#123;age&#125;)&quot;&#125;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update user set name = #&#123;name&#125;,age = #&#123;age&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateById</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-配置分页功能"><a href="#3-配置分页功能" class="headerlink" title="3.配置分页功能"></a>3.配置分页功能</h2><h3 id="（1）增加分页依赖"><a href="#（1）增加分页依赖" class="headerlink" title="（1）增加分页依赖"></a>（1）增加分页依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（2）创建分页配置类"><a href="#（2）创建分页配置类" class="headerlink" title="（2）创建分页配置类"></a>（2）创建分页配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageHelper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageHelperConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PageHelper <span class="title function_">pageHelper</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">PageHelper</span> <span class="variable">pageHelper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageHelper</span>();</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;offsetAsPageNum&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;rowBoundsWithCount&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;reasonable&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        pageHelper.setProperties(properties);</span><br><span class="line">        <span class="keyword">return</span> pageHelper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释如下。</p><ul><li>@Configuration:  表示PageHelperConfig这个类是用来做配置的。</li><li>@Bean：表示启动PageHelper拦截器。</li><li>offsetAsPageNum: 当设置为 true 时,会将 RowBounds 第 1 个参数 offset 当成 pageNum (页码)使用。</li><li>rowBoundsWithCount:当设置为true时，使用RowBounds分页会进行count查询。</li><li>reasonable :在启用合理化时，如果pageNum&lt;1 ,则会查询第一页；如果 pageNum&gt;pages,则会查询最后一页。</li></ul><h3 id="（3）实现分页控制器"><a href="#（3）实现分页控制器" class="headerlink" title="（3）实现分页控制器"></a>（3）实现分页控制器</h3><p>  1.实现分页控制器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageHelper;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageInfo;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.itheima.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserListController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/pagelist&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">listCategory</span><span class="params">(Model model, <span class="meta">@RequestParam(value = &quot;start&quot;,defaultValue = &quot;1&quot;)</span> <span class="type">int</span> start,</span></span><br><span class="line"><span class="params">                               <span class="meta">@RequestParam(value = &quot;size&quot;,defaultValue = &quot;20&quot;)</span> <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        PageHelper.startPage(start, size,<span class="string">&quot;id desc&quot;</span>);</span><br><span class="line">        List&lt;User&gt; users = userMapper.queryAll();</span><br><span class="line">        PageInfo&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(users);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;page&quot;</span>, page);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释如下。</p><ul><li>start：在参数里接收当前是第几页。</li><li>size：每页显示多少条数据。默认值分别是0和20</li><li>startPage(start,size,”id desc”):根据 start、size 进行分页，并且设置 id 倒排序。</li><li>List<User>：返回当前分页的集合。</li><li>Pagelnfo<User>：根据返回的集合创建Pagelnfo対象。</li><li>addAttribute(“page”, page)：把 page ( Pagelnfo 对象)传递给视图，以供后续显示。</li></ul><p>  2.创建分页视图：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns</span>=<span class="string">&quot;https://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:th</span>=<span class="string">&quot;https://www.thymeleaf.org&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:sec</span>=<span class="string">&quot;https://www.thymeleaf.org/tyemeleaf-extras-springsecurity5&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;u:$&#123;page.list&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">scope</span> = <span class="string">&quot;row&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;u.id&#125;&quot;</span>&gt;</span>id<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;u.name&#125;&quot;</span>&gt;</span>name<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;pagelist?start=1&#125;&quot;</span>&gt;</span>[首页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;not page.isFirstPage&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/pagelist(start=$&#123;page.pageNum-1&#125;)&#125;&quot;</span>&gt;</span>[上页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;not page.isLastPage&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/pagelist(start=$&#123;page.pageNum+1&#125;)&#125;&quot;</span>&gt;</span>[下页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/pagelist(start=$&#123;page.pages&#125;)&#125;&quot;</span>&gt;</span>[末页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            当前页/总页数：<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;page.pageNum&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;pagelist(start=$&#123;page.pageNum&#125;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            /<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;page.pages&#125;&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/pagelist(start=$&#123;page.pages&#125;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3-比较JPA与Mybatis"><a href="#3-比较JPA与Mybatis" class="headerlink" title="3.比较JPA与Mybatis"></a>3.比较JPA与Mybatis</h1><p>1.关注度</p><p>JPA在全球范围内的用户数最多，而MyBatis是国内互联网公司的主流选择</p><p>2.Hibernate 的优势</p><ul><li>DAO层开发比MyBatis简单，MyBatis需要维护SQL和结果映射。</li><li>对对象的维护和缓存要比MyBatis好，对増加、删除、修改和查询对象的维护更方便。</li><li>数据库移植性很好。MyBatis的数据库移植性不好，不同的数据库需要写不同的SQL语句。</li><li>有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。</li></ul><p>3.MyBatis的优势</p><ul><li>可以进行更为细致的SQL优化，可以减少查询字段（大部分人这么认为，但是实际上 Hibernate —样可以实现）。</li><li>容易掌握。Hibernate门槛较高（大部分人都这么认为）</li></ul><p>4.简单总结</p><ul><li>MyBatis：小巧、方便、高效、简单、直接、半自动化。</li><li>Hibernate：强大、方便、高效、复杂、间接、全自动化。</li></ul><p>它们各自的缺点都可以依据各目更深入的技术方案来解决。所以，笔者的建议是：</p><ul><li>如果没有SQL语言的基础，则建议使用JPA。</li><li>如果有SQL语言基础，则建议使用MyBatis,因为国内使用MyBatis的人比使用JPA的人多很多。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ORM ( Object Relation Mapping )和JPA—Java持久层API- SpringBoot（15）</title>
      <link href="/2022/07/20/ORM%20(%20Object%20Relation%20Mapping%20)%E5%92%8CJPA%E2%80%94Java%E6%8C%81%E4%B9%85%E5%B1%82API-%20SpringBoot%EF%BC%8815%EF%BC%89/"/>
      <url>/2022/07/20/ORM%20(%20Object%20Relation%20Mapping%20)%E5%92%8CJPA%E2%80%94Java%E6%8C%81%E4%B9%85%E5%B1%82API-%20SpringBoot%EF%BC%8815%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-认识ORM"><a href="#1-认识ORM" class="headerlink" title="1.认识ORM"></a>1.认识ORM</h1><p>  ORM ( Object Relation Mapping )是对象&#x2F;关系映射。它提供了概念性的、易于理解的数据模型，将数据库中的表和内存中的对象建立映射关系。它是随着面向对象的软件开发方法的发展而产生的，面向对象的开发方法依然是当前主流的开发方法。</p><p>  对象和关系型数据是业务实体的两种表现形式。业务实体在内存中表现为对象，在数据库中表现为关系型数据。内存中的对象不会被永久保存，只有关系型数据库(或NoSQL数据库，或文件) 中的对象会被永久保存。</p><p>  对象&#x2F;关系映射(ORM)系统一般以中间件的形式存在，因为内存中的对象之间存在关联和继承关系，而在数据库中，关系型数据无法直接表达多对多的关联和继承关系。对象、数据库通过ORM 映射的关系如图所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/ORM%20(%20Object%20Relation%20Mapping%20)%E5%92%8CJPA%E2%80%94Java%E6%8C%81%E4%B9%85%E5%B1%82API-%20SpringBoot%EF%BC%8815%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><h1 id="2-JPA"><a href="#2-JPA" class="headerlink" title="2.JPA"></a>2.JPA</h1><h2 id="2-1认识-Spring-Data"><a href="#2-1认识-Spring-Data" class="headerlink" title="2.1认识 Spring Data"></a>2.1认识 Spring Data</h2><p>Spring Data是Spring的一个子项目，旨在统一和简化各类型数据的持久化存储方式，而不拘泥于是关系型数据库还是NoSQL数据库。无论是哪种持久化存储方式，数据访问对象(Data Access Objects, DAO)都会提供对对象的增加、删除、修改和查询的方法，以及排序和分页方法等。Spring Data 提供了基于这些层面的统一接口(如：CrudRepository、PagingAndSorting- Repository),以实现持久化的存储。Spring Data包含多个子模块，主要分为主模块和社区模块。</p><h3 id="（1）主要模块"><a href="#（1）主要模块" class="headerlink" title="（1）主要模块"></a>（1）主要模块</h3><ul><li>Spring Data Commons：提供共享的基础框架，适合各个子项目使用，支持跨数据库持久化。</li><li>Spring Data JDBC：提供了对 JDBC 的支持，其中封装了 JDBCTemplate</li><li>Spring Data JDBC Ext：提供了对JDBC的支持，并扩展了标准的JDBC,支持Oracle RAD、高级队列和高级数据类型。</li><li>Spring Data JPA：简化创建JPA数据访问层和跨存储的持久层功能。</li><li>Spring Data KeyValue：集成了Redis和Riak,提供多个常用场景下的简单封装，便于构建 key-value 模块。</li><li>Spring Data LDAP：集成了 Spring Data repository 对 Spring LDAP 的支持。</li><li>Spring Data MongoDB：集成了对数据库 MongoDB 支持。</li><li>Spring Data Redts：集成了对 Redis 的支持。</li><li>Spring Data REST：集成了对 RESTful 资源的支持。</li><li>Spring Data for Apache Cassandra :集成了对大规模、高可用数据源 Apache Cassandra 的支持。</li><li>Spring Data for Apace Geode:集成了对 Apache Geode 的支持。</li><li>Spring Data for Apache Solr：集成了对 Apache Solr 的支持</li><li>Spring Data for Pivotal GemFire：集成了对 Pivotal GemFire 的支持。</li></ul><h3 id="（2）社区模块"><a href="#（2）社区模块" class="headerlink" title="（2）社区模块"></a>（2）社区模块</h3><ul><li>Spring Data Aerospike：集成了对 Aerospike 的支持</li><li>Spring Data ArangoDB：集成了对 ArangoDB 的支持</li><li>Spring Data Couchbase：集成了对 Couchbase 的支持</li><li>Spring Data Azure Cosmos DB：集成了对 Azure Cosmos 的支持。</li><li>Spring Data Cloud Datastore：集成了对 Google Datastore 的支持。</li><li>Spring Data Cloud Spanner：集成了对 Google Spanner 的支持。</li><li>Spring Data DynamoDB：集成了对 DynamoDB 的支持。</li><li>Spring Data Elasticsearch：集成了对搜索引擎框架 Elasticsearch 的支持。</li><li>Spring Data Hazelcast：集成了对 Hazelcast 的支持。</li><li>Spring Data Jest：集成了对基于 Jest REST client 的 Elasticsearch 的支持。</li><li>Spring Data Neo4j：集成了对Neo4j数据库的支持。</li><li>Spring Data Vault：集成了对 Vault 的支持。</li></ul><h2 id="2-2认识JPA"><a href="#2-2认识JPA" class="headerlink" title="2.2认识JPA"></a>2.2认识JPA</h2><p>JPA (Java Persistence API )是Java的持久化API,用于对象的持久化。它是一个非常强大的ORM持久化的解决方案，免去了使用JDBCTemplate开发的编写脚本工作。JPA通过简单约定好接口方法的规则自动生成相应的JPQL语句，然后映射成POJO对象。</p><p>  JPA是一个规范化接口，封装了Hibernate的操作作为默认实现，让用户不通过任何配置即可完成数据库的操作。JPA、Spring Date和Hibernate的关系如图所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/ORM%20(%20Object%20Relation%20Mapping%20)%E5%92%8CJPA%E2%80%94Java%E6%8C%81%E4%B9%85%E5%B1%82API-%20SpringBoot%EF%BC%8815%EF%BC%89%EF%BC%882%EF%BC%89.png"></p><p>  Hibernate 主要通过 hibernate-annotation、hibernate-entitymanager、hibernate-core 三个组件来操作数据。</p><ul><li>hibernate-annotation: 是Hibernate 支持 annotation 方式配置的基础，它包括标准的 JPA annotations、Hibernate 自身特殊功能的 annotation</li><li>hibernate-core：是Hibernate的核心实现，提供了 Hibernate所有的核心功能。</li><li>hibernate-entitymanager：实现了标准的 JPA,它是 hibernate-core 和 JPA 之间的适配器，它不直接提供ORM的功能，而是对hibernate-core 行封装，使得Hibernate符合JPA的规范。</li></ul><p>  可使用以下代码来创建实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  对比JPA与JDBCTemplate创建实体的方式可以看出：JPA的实现方式简单明了，不需要重写映射（支持自定义映射），只需要设置好属性即可。id的自増由数据库自动管理，也可以由程序管理，其他的工作JPA自动处理好了。</p><h2 id="2-3使用JPA"><a href="#2-3使用JPA" class="headerlink" title="2.3使用JPA"></a>2.3使用JPA</h2><h3 id="（1）添加JPA和MySQL数据库的依赖"><a href="#（1）添加JPA和MySQL数据库的依赖" class="headerlink" title="（1）添加JPA和MySQL数据库的依赖"></a>（1）添加JPA和MySQL数据库的依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（2）配置数据库连接信息"><a href="#（2）配置数据库连接信息" class="headerlink" title="（2）配置数据库连接信息"></a>（2）配置数据库连接信息</h3><p>   Spring Boot项目使用MySQL等关系型数据库，需要配置连接信息，可以在 application.yml文件中进行配置。以下代码配置了与MySQL数据库的连接信息：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">jooq:</span></span><br><span class="line">    <span class="attr">sql-dialect:</span> <span class="string">org.hibernate.dialect.Mysql5InnoDBDialect</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>代码解释如下。</p><ul><li>spring.datasource.username :要填写的数据库用户名。</li><li>spring.datasource.password :要填写的数据库密码。</li><li>spring.jpa.show-sql&#x3D; true:开发工具的控制台是否显示SQL语句，建议打开。</li><li>spring.jpa.properties.hibernate.hbm2ddl.auto : hibernate 的配置属性，其主要作用 是：自动创建、更新、验证数据库表结构。该参数的几种配置见下表</li></ul><p>  <img src="https://image.buretuzi.online/blog/article/springboot/ORM%20(%20Object%20Relation%20Mapping%20)%E5%92%8CJPA%E2%80%94Java%E6%8C%81%E4%B9%85%E5%B1%82API-%20SpringBoot%EF%BC%8815%EF%BC%89%EF%BC%883%EF%BC%89.png"></p><h2 id="2-4了解JPA注解和属性"><a href="#2-4了解JPA注解和属性" class="headerlink" title="2.4了解JPA注解和属性"></a>2.4了解JPA注解和属性</h2><h3 id="（1）JPA的常用注解"><a href="#（1）JPA的常用注解" class="headerlink" title="（1）JPA的常用注解"></a>（1）JPA的常用注解</h3><p>  <img src="https://image.buretuzi.online/blog/article/springboot/ORM%20(%20Object%20Relation%20Mapping%20)%E5%92%8CJPA%E2%80%94Java%E6%8C%81%E4%B9%85%E5%B1%82API-%20SpringBoot%EF%BC%8815%EF%BC%89%EF%BC%884%EF%BC%89.png"></p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/ORM%20(%20Object%20Relation%20Mapping%20)%E5%92%8CJPA%E2%80%94Java%E6%8C%81%E4%B9%85%E5%B1%82API-%20SpringBoot%EF%BC%8815%EF%BC%89%EF%BC%885%EF%BC%89.png"></p><h3 id="（2）映射关系的注解"><a href="#（2）映射关系的注解" class="headerlink" title="（2）映射关系的注解"></a>（2）映射关系的注解</h3><p>  <img src="https://image.buretuzi.online/blog/article/springboot/ORM%20(%20Object%20Relation%20Mapping%20)%E5%92%8CJPA%E2%80%94Java%E6%8C%81%E4%B9%85%E5%B1%82API-%20SpringBoot%EF%BC%8815%EF%BC%89%EF%BC%886%EF%BC%89.png"></p><h3 id="（3）映射关系的属性"><a href="#（3）映射关系的属性" class="headerlink" title="（3）映射关系的属性"></a>（3）映射关系的属性</h3><p>  <img src="https://image.buretuzi.online/blog/article/springboot/ORM%20(%20Object%20Relation%20Mapping%20)%E5%92%8CJPA%E2%80%94Java%E6%8C%81%E4%B9%85%E5%B1%82API-%20SpringBoot%EF%BC%8815%EF%BC%89%EF%BC%887%EF%BC%89.png"></p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/ORM%20(%20Object%20Relation%20Mapping%20)%E5%92%8CJPA%E2%80%94Java%E6%8C%81%E4%B9%85%E5%B1%82API-%20SpringBoot%EF%BC%8815%EF%BC%89%EF%BC%888%EF%BC%89.png"></p><p>在 Spring Data JPA 中，要控制 Session 的生命周期：否则会出现”could not initialize proxy</p><p>  [xxxx#18]-no Session”错误。可以在配置文件中配置以下代码来控制Session的生命周期：  </p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">open-in-view:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">properties:</span></span><br><span class="line">  <span class="attr">hibernate:</span></span><br><span class="line">    <span class="attr">enable_lazy_load_no_trans:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="2-5-实例：用JPA构建实体数据表"><a href="#2-5-实例：用JPA构建实体数据表" class="headerlink" title="2.5 实例：用JPA构建实体数据表"></a>2.5 实例：用JPA构建实体数据表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotEmpty;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Size;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Article</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: IDENTITY代表由数据库控制，auto代表由Spring Boot应用程序统一控制（有多个表时，id 的自增值不一定从1开始）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="meta">@Column(nullable = false,unique = true)</span></span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;标题不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *Description:枚举类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Column(columnDefinition = &quot;enum(&#x27;图&#x27;,&#x27;图文&#x27;,&#x27;文&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String type;<span class="comment">//类型</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *Description： Boolean 类型默认false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean available= Boolean.FALSE;</span><br><span class="line">    <span class="meta">@Size(min = 0,max = 20)</span></span><br><span class="line">    <span class="keyword">private</span> String keyword;</span><br><span class="line">    <span class="meta">@Size(max = 255)</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String body;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description：创建虚拟字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> List keywordlists;</span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">getKeywordlists</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (List) Arrays.asList(<span class="built_in">this</span>.keyword.trim().split(<span class="string">&quot;|&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKeywordlists</span><span class="params">(List keywordlists)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.keywordlists = keywordlists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6认识JPA的接口"><a href="#2-6认识JPA的接口" class="headerlink" title="2.6认识JPA的接口"></a>2.6认识JPA的接口</h2><p>JPA提供了操作数据库的接口。在开发过程中继承和使用这些接口，可简化现有的持久化开发 工作。可以使Spring找到自定义接口，并生成代理类，后续可以把自定义接口注入Spring容器中进行管理。在自定义接口过程中，可以不写相关的SQL操作，由代理类自动生成。</p><h3 id="（1）JPA-接口-JpaRepository"><a href="#（1）JPA-接口-JpaRepository" class="headerlink" title="（1）JPA 接口 JpaRepository"></a>（1）JPA 接口 JpaRepository</h3><p>JpaRepository 继承自 PagingAndSortingRepository， 该接口提供了 JPA 的相关实用功能, 以及通过Example进行查询的功能。Example对象是JPA提供用来构造查询条件的对象。该接口的关键代码如下：</p><p>  public interface JpaRepository&lt;T, ID&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, Query By ExampleExecutor<T> {}</p><p>  在上述代码中，T表示实体对象，ID表示主键。ID必须实现序列化。</p><p>  JpaRepository提供的方法见下表</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/ORM%20(%20Object%20Relation%20Mapping%20)%E5%92%8CJPA%E2%80%94Java%E6%8C%81%E4%B9%85%E5%B1%82API-%20SpringBoot%EF%BC%8815%EF%BC%89%EF%BC%889%EF%BC%89.png"></p><h3 id="（2）分页排序接口-PagingAndSortingRepository"><a href="#（2）分页排序接口-PagingAndSortingRepository" class="headerlink" title="（2）分页排序接口 PagingAndSortingRepository"></a>（2）分页排序接口 PagingAndSortingRepository</h3><p>  PagingAndSortingRepository继承自CrudRepository提供的分页和排序方法。其关键代码如下：</p><p><code>  @NoRepositoryBean</code></p><p><code>  public interface PagingAndSortingRepository&lt;T, ID&gt; extends CrudRepository&lt;T, ID&gt; &#123;</code></p><p><code>    lterable&lt;T&gt; findAll（Sort var1）;</code></p><p><code>    Page&lt;T&gt; findAII（Pageable var1）;</code></p><p><code>  &#125;</code></p><p>其方法有如下两种。</p><ul><li>lterable<T> findAII(Sort sort):排序功能。它按照”sort”制定的排序返回数据。</li><li>Page<T> findAII(Pageable pageable)：分页查询(含排序功能),</li></ul><h3 id="（3）数据操作接口-CrudRepository"><a href="#（3）数据操作接口-CrudRepository" class="headerlink" title="（3）数据操作接口 CrudRepository"></a>（3）数据操作接口 CrudRepository</h3><p>CrudRepository接口继承自Repository接口，并新增了增加、删除、修改和查询方法。</p><p>   CrudRepository提供的方法见下表</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/ORM%20(%20Object%20Relation%20Mapping%20)%E5%92%8CJPA%E2%80%94Java%E6%8C%81%E4%B9%85%E5%B1%82API-%20SpringBoot%EF%BC%8815%EF%BC%89%EF%BC%8810%EF%BC%89.png"></p><h3 id="（4）分页接口-Pageable-和-Page"><a href="#（4）分页接口-Pageable-和-Page" class="headerlink" title="（4）分页接口 Pageable 和 Page"></a>（4）分页接口 Pageable 和 Page</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/article&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">articleList</span><span class="params">(<span class="meta">@RequestParam(value = &quot;start&quot;,defaultValue = &quot;0&quot;)</span> Integer start,</span></span><br><span class="line"><span class="params">                                <span class="meta">@RequestParam(value = &quot;limit&quot;,defaultValue = &quot;10&quot;)</span> Integer limit)</span>&#123;</span><br><span class="line">    start = start &lt; <span class="number">0</span>?<span class="number">0</span>:start;</span><br><span class="line">    <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sort</span>(Sort.Direction.DESC,<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(start, limit, sort);</span><br><span class="line">    Page&lt;Article&gt; page = articleRepository.findAll(pageable);</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;admin/article/list&quot;</span>);</span><br><span class="line">    mav.addObject(<span class="string">&quot;page&quot;</span>,page);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）排序类Sort"><a href="#（5）排序类Sort" class="headerlink" title="（5）排序类Sort"></a>（5）排序类Sort</h3><p>Sort类专门用来处理排序。最简单的排序就是先传入一个属性列，然后根据属性列的值进行排序。默认情况下是升序排列。它还可以根据提供的多个字段属性值进行排序。例如以下代码是通过 Sort.Order对象的List集合来创建Sort对象的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Sort.Order&gt; orders = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Sort.Order&gt;();</span><br><span class="line">orders.add(<span class="keyword">new</span> <span class="title class_">Sort</span>.Order(Sort.Direction.DESC,<span class="string">&quot;id&quot;</span>));</span><br><span class="line">orders.add(<span class="keyword">new</span> <span class="title class_">Sort</span>.Order(Sort.Direction.ASC,<span class="string">&quot;view&quot;</span>));</span><br><span class="line"><span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(start,limit,sort);</span><br><span class="line"><span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(start,limit,Sort.by(orders));</span><br></pre></td></tr></table></figure><p>Sort排序的方法还有下面几种：</p><ul><li>直接创建Sort对象，适合对单一属性做排序。</li><li>通过Sort.Order对象创建Sort对象，适合对单一属性做排序。</li><li>通过属性的List集合创建Sort对象，适合对多个属性采取同一种排序方式的排序。</li><li>通过Sort.Order对象的List集合创建Sort对象，适合所有情况，比较容易设置排序方式。</li><li>忽略大小写排序。</li><li>使用JpaSort.unsafe进行排序。</li><li>使用聚合函数进行排序。</li></ul><h1 id="3-JPA的查询方式"><a href="#3-JPA的查询方式" class="headerlink" title="3.JPA的查询方式"></a>3.JPA的查询方式</h1><h2 id="3-1使用约定方法名"><a href="#3-1使用约定方法名" class="headerlink" title="3.1使用约定方法名"></a>3.1使用约定方法名</h2><p>约定方法名一定要根据命名规范来写，Spring Data会根据前缀、中间连接词（Or、And、Like、NotNull等类似SQL中的关键词）、内部拼接SQL代理生成方法的实现。约定方法名的方法见下表</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/ORM%20(%20Object%20Relation%20Mapping%20)%E5%92%8CJPA%E2%80%94Java%E6%8C%81%E4%B9%85%E5%B1%82API-%20SpringBoot%EF%BC%8815%EF%BC%89%EF%BC%8811%EF%BC%89.png"></p><p>接口方法的命名规则也很简单，只要明白And、Or、Is、Equal、Greater、StartingWith等英文单词的含义，就可以写接口方法。具体用法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.Repository;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;User,Long&gt; &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByEmailOrName</span><span class="params">(String email,String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码表示，通过email或name来查找User对象。</p><p>约定方法名还可以支持以下几种语法：</p><ul><li>User findFirstByOrderByNameAsc()</li><li>Page<User> queryFirst100ByName(String name, Pageable pageable) </li><li>Slice<User> findTop100ByName(String name, Pageable pageable)</li><li>List<User> findFirst100ByName(String name, Sort sort)</li><li>List<User> findTop100ByName(String name, Pageable pageable)</li></ul><h2 id="3-2用JPQL进行查询"><a href="#3-2用JPQL进行查询" class="headerlink" title="3.2用JPQL进行查询"></a>3.2用JPQL进行查询</h2><p>  JPQL语言(Java Persistence Query Language)是一种和SQL非常类似的中间性和对象化查询语言，它最终会被编译成针对不同底层数据库的SQL语言，从而屏蔽不同数据库的差异。</p><p>  JPQL语言通过Query接口封装执行，Query接口封装了执行数据库查询的相关方法。调用 EntityManager的Query、NamedQuery及NativeQuery方法可以获得查询对象，进而可调用 Query接口的相关方法来执行查询操作。</p><p>  JPQL是面向对象进行查询的语言，可以通过自定义的JPQL完成UPDATE和DELETE操作。JPQL不支持使用INSERT，对于UPDATE或DELETE操作，必须使用注解@Modifying 进行修饰。</p><h3 id="（1）下面代码表示根据name值进行查找"><a href="#（1）下面代码表示根据name值进行查找" class="headerlink" title="（1）下面代码表示根据name值进行查找"></a>（1）下面代码表示根据name值进行查找</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User,Long&gt; &#123;</span><br><span class="line">    <span class="meta">@Query(&quot;select u from User u where u.name = ?1&quot;)</span></span><br><span class="line">    User <span class="title function_">findByName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）下面代码表示根据name值逬行模糊查找"><a href="#（2）下面代码表示根据name值逬行模糊查找" class="headerlink" title="（2）下面代码表示根据name值逬行模糊查找"></a>（2）下面代码表示根据name值逬行模糊查找</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User,Long&gt; &#123;</span><br><span class="line">    <span class="meta">@Query(&quot;select u from User u where u.name like %?1&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3用原生SQL进行查询"><a href="#3-3用原生SQL进行查询" class="headerlink" title="3.3用原生SQL进行查询"></a>3.3用原生SQL进行查询</h2><h3 id="（1）根据ID查询用户"><a href="#（1）根据ID查询用户" class="headerlink" title="（1）根据ID查询用户"></a>（1）根据ID查询用户</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Query(value = &quot;select * from user u where u.id = :id&quot;, nativeQuery = true)</span></span><br><span class="line">Optional&lt;User&gt; <span class="title function_">findById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br></pre></td></tr></table></figure><h3 id="（2）查询所有用户"><a href="#（2）查询所有用户" class="headerlink" title="（2）查询所有用户"></a>（2）查询所有用户</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(value = &quot;select * from user&quot;, nativeQuery = true)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findAllNative</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="（3）根据email查询用户"><a href="#（3）根据email查询用户" class="headerlink" title="（3）根据email查询用户"></a>（3）根据email查询用户</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(value = &quot;select * from user where email = ?1&quot;, nativeQuery = true)</span></span><br><span class="line">User <span class="title function_">findByEmail</span><span class="params">(String email)</span>;</span><br></pre></td></tr></table></figure><h3 id="（4）根据name查询用户，并返回分页对象Page"><a href="#（4）根据name查询用户，并返回分页对象Page" class="headerlink" title="（4）根据name查询用户，并返回分页对象Page"></a>（4）根据name查询用户，并返回分页对象Page</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(value = &quot;select * from user where name = ?1&quot;,</span></span><br><span class="line"><span class="meta">    countQuery = &quot;select count(*) from user where name = ?1&quot;,</span></span><br><span class="line"><span class="meta">    nativeQuery = true)</span></span><br><span class="line">Page&lt;User&gt; <span class="title function_">findByName</span><span class="params">(String name, Pageable pageable)</span>;</span><br></pre></td></tr></table></figure><h3 id="（5）根据名字来修改email的值"><a href="#（5）根据名字来修改email的值" class="headerlink" title="（5）根据名字来修改email的值"></a>（5）根据名字来修改email的值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query(&quot;update user set email = :email where name = :name&quot;)</span></span><br><span class="line">Void <span class="title function_">updateUserEmaliByName</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name,<span class="meta">@Param(&quot;email&quot;)</span> String email)</span>;</span><br></pre></td></tr></table></figure><h2 id="3-4-用-Specifications-进行查询"><a href="#3-4-用-Specifications-进行查询" class="headerlink" title="3.4 用 Specifications 进行查询"></a>3.4 用 Specifications 进行查询</h2><p>如果要使 Repository 支持 Specification 查询，则需要在 Repository 中继承 JpaSpecification- Executor接口，具体使用见如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.executor;</span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.ArticleRepository;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Article;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.PageRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.domain.Specification;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.criteria.*;</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testJpaSpecificationExecutor</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleRepository articleRepository;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJpaSpecificationExecutor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">PageRequest</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(pageNo,pageSize);</span><br><span class="line">        Specification&lt;Article&gt; specification = <span class="keyword">new</span> <span class="title class_">Specification</span>&lt;Article&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Predicate <span class="title function_">toPredicate</span><span class="params">(Root&lt;Article&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder)</span> &#123;</span><br><span class="line">                <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> root.get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="type">Predicate</span> <span class="variable">predicate1</span> <span class="operator">=</span> criteriaBuilder.gt(path,<span class="number">2</span>);</span><br><span class="line">                <span class="type">Predicate</span> <span class="variable">predicate2</span> <span class="operator">=</span> criteriaBuilder.equal(root.get(<span class="string">&quot;num&quot;</span>),<span class="number">42283</span>);</span><br><span class="line">                <span class="type">Predicate</span> <span class="variable">predicate</span> <span class="operator">=</span> criteriaBuilder.and(predicate1,predicate2);</span><br><span class="line">                <span class="keyword">return</span> predicate;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Page&lt;Article&gt; page = articleRepository.findAll(specification,pageable);</span><br><span class="line">        System.out.println(<span class="string">&quot;总记录数：&quot;</span>+page.getTotalElements());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前第：&quot;</span>+(page.getNumber()+<span class="number">1</span>)+<span class="string">&quot;页&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总页数：&quot;</span>+page.getTotalPages());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前页面的List：&quot;</span>+page.getContent());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前页面的记录数：&quot;</span>+page.getNumberOfElements());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释如下。</p><ul><li>CriteriaQuery接口: specific的顶层查询对象，它包含查询的各个部分，比如，select、from、 where、group by、order by等。CriteriaQuery对象只对实体类型或嵌入式类型的Criteria 查询起作用。</li><li>root：代表查询的实体类是Criteria查询的根对象，Criteria查询的根定义了实体类型，能为将来的导航获得想要的结果。它与SQL查询中的From子句类似。Root实例是类型化的, 且规定了 From子句中能够出现的类型。查询根实例通过传入一个实体类型给 AbstractQuery.from 方法获得。</li><li>query：可以从中得到Root对象，即告知JPA Criteria查询要查询哪一个实体类。还可以添加查询条件，并结合EntityManager对象得到最终查询的TypedQuery对象。</li><li>CriteriaBuilder对象：用于创建Criteria相关对象的工厂，可以从中获取到Predicate 对象。</li><li>Predicate类型：代表一个查询条件。</li></ul><p>运行上面的测试代码，在控制台会输出如下结果(确保数据库己经存在数据)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hibernate: select card0_.id as id1_0_, card0_.num as num2_0_ from card card0_ where card0_.id&gt;<span class="number">2</span> and card0_.num=<span class="number">422803</span> limit ?</span><br><span class="line">Hibernate: select <span class="title function_">count</span><span class="params">(cardO_.id)</span> as col_0_0_ from card card0_ where cardO_Jd&gt;<span class="number">2</span> and card0_.num=<span class="number">422803</span> </span><br><span class="line">总记录数:<span class="number">6</span></span><br><span class="line">当前第：<span class="number">1</span>页 总页数:<span class="number">2</span> 当前页面的 List: </span><br><span class="line">[Card(id=<span class="number">4</span>, num二<span class="number">422803</span>), Card(id=<span class="number">8</span>, num=<span class="number">422803</span>), Card(id=<span class="number">10</span>, num=<span class="number">422803</span>), Card(id=20t num=<span class="number">422803</span>), Card(id=<span class="number">23</span>, num=<span class="number">422803</span>)] </span><br><span class="line">当前页面的记录数:<span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="3-5-用-ExampleMatcher-进行查询"><a href="#3-5-用-ExampleMatcher-进行查询" class="headerlink" title="3.5 用 ExampleMatcher 进行查询"></a>3.5 用 ExampleMatcher 进行查询</h2><p>Spring Data可以通过Example对象来构造JPQL查询，具体用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="type">ExampleMatcher</span> <span class="variable">matcher</span> <span class="operator">=</span> ExampleMatcher.matching()</span><br><span class="line">        .withIgnorePaths(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        .withIncludeNullValues()</span><br><span class="line">        .withStringMatcher(ExampleMatcher.StringMatcher.ENDING);</span><br><span class="line">Example&lt;User&gt; example = Example.of(user,matcher);</span><br><span class="line">List&lt;User&gt; list = userRepository.findAll(example);</span><br></pre></td></tr></table></figure><h2 id="3-6-用谓语QueryDSL进行查询"><a href="#3-6-用谓语QueryDSL进行查询" class="headerlink" title="3.6 用谓语QueryDSL进行查询"></a>3.6 用谓语QueryDSL进行查询</h2><p>QueryDSL也是基于各种ORM之上的一个通用查询框架,它与Spring Data JPA是同级别的。 使用QueryDSL的API可以写岀SQL语句(Java代码，非真正标准SQL),不需要懂SQL语句。 它能够构建类型安全的查询。这与JPA使用原生查询时有很大的不同，可以不必再对“Object[]‘ 进行操作。它还可以和JPA联合使用。</p><h1 id="4-用JPA开发文章管理模块"><a href="#4-用JPA开发文章管理模块" class="headerlink" title="4.用JPA开发文章管理模块"></a>4.用JPA开发文章管理模块</h1><h3 id="4-1实现文章实体"><a href="#4-1实现文章实体" class="headerlink" title="4.1实现文章实体"></a>4.1实现文章实体</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Article</span> <span class="keyword">extends</span> <span class="title class_">BaseEntity</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="meta">@Column(nullable = false,unique = true)</span></span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;标题不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释如下：</p><ul><li><p>@Entity：声明它是个实体，然后加入了注解@Data, @Data是Lombok插件提供的注解， 以简化代码，自动生成Getter、Setter方法。文章的属性字段一般包含id、title、keyword、body，以及发布时间、更新时间、处理人。这里只简化设置文章id、关键词、标题和内容。</p></li><li><p>@GeneratedValue：将 id 作为主键。GenerationType 为“identity”，代表由数据库统 一控制id的自增。如果属性为“auto”,则是Spring Boot控制id的自增。使用identity 的好处是，通过数据库来管理表的主键的自增，不会影响到其他表</p></li><li><p>nullable &#x3D; false, unique &#x3D; true：建立唯一索引，避免重复。</p></li><li><p>@NotEmpty(message &#x3D;”标题不能为空”)：作为提示和验证消息。</p></li></ul><h2 id="4-2-实现数据持久层"><a href="#4-2-实现数据持久层" class="headerlink" title="4.2 实现数据持久层"></a>4.2 实现数据持久层</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ArticleRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Article,Long&gt;,</span><br><span class="line">        JpaSpecificationExecutor&lt;Article&gt;&#123;</span><br><span class="line">    Article <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-通过创建服务接口和服务接口的实现类来完成业务逻辑功能"><a href="#4-3-通过创建服务接口和服务接口的实现类来完成业务逻辑功能" class="headerlink" title="4.3 通过创建服务接口和服务接口的实现类来完成业务逻辑功能"></a>4.3 通过创建服务接口和服务接口的实现类来完成业务逻辑功能</h2><h3 id="（1）创建服务接口，见以下代码"><a href="#（1）创建服务接口，见以下代码" class="headerlink" title="（1）创建服务接口，见以下代码"></a>（1）创建服务接口，见以下代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ArticleService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Article&gt; <span class="title function_">getArticleList</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Article <span class="title function_">findArticleById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）编写服务接口的实现"><a href="#（2）编写服务接口的实现" class="headerlink" title="（2）编写服务接口的实现"></a>（2）编写服务接口的实现</h3><p>  在impl包下，新建article的impl实现service,并标注这个类为service服务类。</p><p>  通过implements声明使用ArticleService接口，并重写其方法，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ArticleService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleRepository articleRepository;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Article&gt; <span class="title function_">getArticleList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> articleRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Article <span class="title function_">findArticleById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> articleRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）实现增加、删除、修改和查询的控制层API功能"><a href="#（3）实现增加、删除、修改和查询的控制层API功能" class="headerlink" title="（3）实现增加、删除、修改和查询的控制层API功能"></a>（3）实现增加、删除、修改和查询的控制层API功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.ArticleRepository;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Article;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.PageRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Sort;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;article&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleRepository articleRepository;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">articlelist</span><span class="params">(<span class="meta">@RequestParam(value = &quot;start&quot;,defaultValue = &quot;0&quot;)</span>Integer start,</span></span><br><span class="line"><span class="params">                                    <span class="meta">@RequestParam(value = &quot;limit&quot;,defaultValue = &quot;5&quot;)</span>Integer limit)</span> &#123;</span><br><span class="line">        start = start &lt; <span class="number">0</span> ? <span class="number">0</span> : start;</span><br><span class="line">        <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> Sort.by(Sort.Direction.DESC, <span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(start, limit, sort);</span><br><span class="line">        Page&lt;Article&gt; page = articleRepository.findAll(pageable);</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;article/list&quot;</span>);</span><br><span class="line">        mav.addObject(<span class="string">&quot;page&quot;</span>, page);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">getArticle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="type">Article</span> <span class="variable">article</span> <span class="operator">=</span> articleRepository.findById(id);</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;article/show&quot;</span>);</span><br><span class="line">        mav.addObject(<span class="string">&quot;article&quot;</span>, article);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addArticle</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;article/add&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">saveArticle</span><span class="params">(Article model)</span>&#123;</span><br><span class="line">        articleRepository.save(model);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/article/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteArticle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span>&#123;</span><br><span class="line">        articleRepository.deleteById(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/edit/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">editArticle</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="type">Article</span> <span class="variable">model</span> <span class="operator">=</span> articleRepository.findById(id);</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;article/edit&quot;</span>);</span><br><span class="line">        mav.addObject(<span class="string">&quot;article&quot;</span>, model);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">editArticleSave</span><span class="params">(Article model,<span class="type">long</span> id)</span>&#123;</span><br><span class="line">        model.setId(id);</span><br><span class="line">        articleRepository.save(model);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-实现自动填充字段"><a href="#5-实现自动填充字段" class="headerlink" title="5.实现自动填充字段"></a>5.实现自动填充字段</h1><p>在操作实体类时，通常需要记录创建时间和更新时间。如果每个对象的新增或修改都用手工来操作，则会显得比较烦琐。这时可以使用Spring Data JPA的注解@EnableJpaAuditing来实现自动填充字段功能。具体步骤如下。</p><h3 id="（1）开启JPA的审计功能"><a href="#（1）开启JPA的审计功能" class="headerlink" title="（1）开启JPA的审计功能"></a>（1）开启JPA的审计功能</h3><p>通过在入口类中加上注解@EnableJpaAuditing,来开启JPA的Auditing功能</p><h3 id="（2）创建基类"><a href="#（2）创建基类" class="headerlink" title="（2）创建基类"></a>（2）创建基类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="meta">@EntityListeners(AuditingEntityListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="keyword">private</span> Long createTime;     <span class="comment">//createTime</span></span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="keyword">private</span> Long updateTime;     <span class="comment">//updateTime</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;create_by&quot;)</span></span><br><span class="line">    <span class="meta">@CreatedBy</span></span><br><span class="line">    <span class="keyword">private</span> Long createBy; <span class="comment">//createBy</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;lastmodified_by&quot;)</span></span><br><span class="line">    <span class="meta">@LastModifiedBy</span></span><br><span class="line">    <span class="keyword">private</span> Long lastModifiedBy; <span class="comment">//lastModifiedBy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）赋值给-CreatedBy-和-LastModifiedBy"><a href="#（3）赋值给-CreatedBy-和-LastModifiedBy" class="headerlink" title="（3）赋值给 CreatedBy 和 LastModifiedBy"></a>（3）赋值给 CreatedBy 和 LastModifiedBy</h3><p>  上述代码已经自动实现了创建和更新时间赋值，但是创建人和最后修改人并没有赋值，所以需要实现”AuditorAware”接口来返回需要插入的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InjectAuditor</span> <span class="keyword">implements</span> <span class="title class_">AuditorAware</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="comment">//给 Bean 中的 @CreatedBy @LastModifiedBy 注入操作人</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">getCurrentAuditor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SecurityContext</span> <span class="variable">securityContext</span> <span class="operator">=</span> SecurityContextHolder.getContext();</span><br><span class="line">        <span class="keyword">if</span> (securityContext==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (securityContext.getAuthentication()==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">loginUserName</span> <span class="operator">=</span> securityContext.getAuthentication().getName();</span><br><span class="line">            Optional&lt;String&gt; name = Optional.ofNullable(loginUserName);</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  代码解释如下。</p><p>  @Configuration：表示此类是配置类。让Spring来加我该类配置。</p><p>   SecurityContextHolder:用于获取 SecurityContext,其存放了 Authentication 和特定于请求的安全信息。这里是判断用户是否登录。如果用户登录成功，则荻取用户名，然后把用户名返回给操作人。</p><h3 id="（4）使用基类"><a href="#（4）使用基类" class="headerlink" title="（4）使用基类"></a>（4）使用基类</h3><p>  要在其他类中使用基类，通过在其他类中继承即可</p><h1 id="6-关系映射开发"><a href="#6-关系映射开发" class="headerlink" title="6.关系映射开发"></a>6.关系映射开发</h1><h2 id="6-1认识实体间关系映射"><a href="#6-1认识实体间关系映射" class="headerlink" title="6.1认识实体间关系映射"></a>6.1认识实体间关系映射</h2><p>    对象关系映射（object relational mapping ）是指通过将对象状态映射到数据库列’来开发和 维护对象和关系数据库之间的关系。它能够轻松处理（执行）各种数据库操作，如插入、更新、 删除等</p><h3 id="（1）映射方向"><a href="#（1）映射方向" class="headerlink" title="（1）映射方向"></a>（1）映射方向</h3><p>   ORM的映射方向是表与表的关联（join ）,可分为两种。</p><ul><li>单向关系：代表一个实体可以将属性引用到另一个实体。即只能从A表向B表进行联表查询。</li><li>双向关系：代表每个实体都有一个关系字段(属性)引用了其他实体。</li></ul><h3 id="（2）ORM映射类型"><a href="#（2）ORM映射类型" class="headerlink" title="（2）ORM映射类型"></a>（2）ORM映射类型</h3><ul><li>一对一 (@OneToOne)：实体的每个实例与另一个实体的单个实例相关联。</li><li>一对多(@OneToMany): 一个实体的实例可以与另一个实体的多个实例相关联。</li><li>多对一(@ManyToOne): 一个实体的多个实例可以与另一个实体的单个实例相关联。</li><li>多对多(@ManyToMany)：—个实体的多个实例可能与另一个实体的多个实例有关。在 这个映射中，任何一方都可以成为所有者方。</li></ul><h2 id="实例：实现一对一映射"><a href="#实例：实现一对一映射" class="headerlink" title="实例：实现一对一映射"></a>实例：实现一对一映射</h2><p>  “一对一”映射首先要确定实体间的关系，并考虑表结构，还要考虑实体关系的方向性。</p><p>   若为双向关联，则在保存实体关系的实体中要配合注解@JoinColumn。在没有保存实体关系 的实体中，要用mappedBy属性明确所关联的实体。</p><h3 id="（1）编写实体"><a href="#（1）编写实体" class="headerlink" title="（1）编写实体"></a>（1）编写实体</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Table(name = &quot;stdu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Column(columnDefinition = &quot;enum(&#x27;male&#x27;,&#x27;female&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="meta">@OneToOne(cascade = CascadeType.ALL)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;card_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Card card;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Table(name = &quot;card&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Card</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> Integer num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）编写-Repository-层"><a href="#（2）编写-Repository-层" class="headerlink" title="（2）编写 Repository 层"></a>（2）编写 Repository 层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Card;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CardRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Card,Long&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Optional&lt;Card&gt; <span class="title function_">findById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Student;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Student,Long&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Optional&lt;Student&gt; <span class="title function_">findById</span><span class="params">(Long id)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）编写Service层"><a href="#（3）编写Service层" class="headerlink" title="（3）编写Service层"></a>（3）编写Service层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Card;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CardService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Card&gt; <span class="title function_">getCardList</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Optional&lt;Card&gt; <span class="title function_">findCardById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Student;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentList</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Optional&lt;Student&gt; <span class="title function_">findStudentById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）编写Service实现"><a href="#（4）编写Service实现" class="headerlink" title="（4）编写Service实现"></a>（4）编写Service实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service.Impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Card;</span><br><span class="line"><span class="keyword">import</span> com.itheima.repository.CardRepository;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.CardService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CardServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CardService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CardRepository cardRepository;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Card&gt; <span class="title function_">getCardList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Optional&lt;Card&gt; <span class="title function_">findCardById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service.Impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Student;</span><br><span class="line"><span class="keyword">import</span> com.itheima.repository.StudentRepository;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.StudentService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentRepository studentRepository;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> studentRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Optional&lt;Student&gt; <span class="title function_">findStudentById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> studentRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）编写测试"><a href="#（5）编写测试" class="headerlink" title="（5）编写测试"></a>（5）编写测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Card;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Student;</span><br><span class="line"><span class="keyword">import</span> com.itheima.repository.CardRepository;</span><br><span class="line"><span class="keyword">import</span> com.itheima.repository.StudentRepository;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneToOneTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentRepository studentRepository;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CardRepository cardRepository;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOneToOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student1.setName(<span class="string">&quot;好噶就&quot;</span>);</span><br><span class="line">        student1.setSex(<span class="string">&quot;male&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student2.setName(<span class="string">&quot;会发卡号&quot;</span>);</span><br><span class="line">        student2.setSex(<span class="string">&quot;female&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Card</span> <span class="variable">card1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Card</span>();</span><br><span class="line">        card1.setNum(<span class="number">6565</span>);</span><br><span class="line">        student1.setCard(card1);</span><br><span class="line">        studentRepository.save(student1);</span><br><span class="line">        studentRepository.save(student2);</span><br><span class="line">        <span class="type">Card</span> <span class="variable">card2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Card</span>();</span><br><span class="line">        card2.setNum(<span class="number">7878</span>);</span><br><span class="line">        cardRepository.save(card2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  无需建表、会自动建！运行代码，控制台输出如下：</p><p><code>  Hibernate: create table card (id bigint not null auto_increment, num integer, primary key (id)) engine=InnoDB</code><br><code>  Hibernate: create table stdu (id bigint not null auto_increment, name varchar(255), sex enum(&#39;male&#39;,&#39;female&#39;), card_id bigint, primary key (id)) engine=InnoDB</code><br><code>  Hibernate: alter table stdu add constraint FKgaf9vaxnpmq98oc2d8gskduk9 foreign key (card_id) references card (id)</code></p><p><code>  Hibernate: insert into card (num) values (?)</code><br><code>  Hibernate: insert into stdu (card_id, name, sex) values (?, ?, ?)</code><br><code>  Hibernate: insert into stdu (card_id, name, sex) values (?, ?, ?)</code><br><code>  Hibernate: insert into card (num) values (?)</code></p><p>  时于双向的“一对一”关系映射，发出端和接收端都要使用注解@OneToOne,同时定义一个接收端类型的字段属性和@OneToOne注解中的“mappedBy”属徃：这个在双向关系的接收端是必需的。在双向关系中，有一方为关系的发出端，另一方是关系的反端。即 “Inverse“ <strong><em>端</em></strong> (接收端)</p><h2 id="实例：实现一对多映射"><a href="#实例：实现一对多映射" class="headerlink" title="实例：实现一对多映射"></a>实例：实现一对多映射</h2><p>  单向关系的一对多注解@0neToMany,只用于关系的发出端(“一”的一方)。另外，需要关系的发出端定义一个集合类型的接收端的字段属性。在一对多关联关系映射中，默认是以中间表方式来映射这种关系的。中间表的名称为“用下画线连接关系的拥有端(发出端)和Inverse端(接收端）中间表两个字段分别为两张表的表名加 下画线”_“再加主键组成。当然，也可以改变这种默认的中间表的映射方式。在关系的拥有端，使用@JoinClolum注解定义外键来映射这个关系。</p><h3 id="（1）编写实体-1"><a href="#（1）编写实体-1" class="headerlink" title="（1）编写实体"></a>（1）编写实体</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">School</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@OneToMany()</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;school_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Teacher&gt; teacherList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="keyword">private</span> School school;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）编写-Repository-层-1"><a href="#（2）编写-Repository-层-1" class="headerlink" title="（2）编写 Repository 层"></a>（2）编写 Repository 层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.repository;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.School;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SchoolReposity</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;School,Long&gt; &#123;</span><br><span class="line">    Optional&lt;School&gt; <span class="title function_">findById</span><span class="params">(Long id)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Student;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Student,Long&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Optional&lt;Student&gt; <span class="title function_">findById</span><span class="params">(Long id)</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）编写Service层-1"><a href="#（3）编写Service层-1" class="headerlink" title="（3）编写Service层"></a>（3）编写Service层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.School;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SchoolService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;School&gt; <span class="title function_">getSchoolList</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Optional&lt;School&gt; <span class="title function_">findSchoolById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Teacher;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TeacherService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Teacher&gt; <span class="title function_">getTeacherList</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Optional&lt;Teacher&gt; <span class="title function_">findTeacherById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）编写Service实现-1"><a href="#（4）编写Service实现-1" class="headerlink" title="（4）编写Service实现"></a>（4）编写Service实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service.Impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.School;</span><br><span class="line"><span class="keyword">import</span> com.itheima.repository.SchoolReposity;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.SchoolService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchoolServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SchoolService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SchoolReposity schoolReposity;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;School&gt; <span class="title function_">getSchoolList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> schoolReposity.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Optional&lt;School&gt; <span class="title function_">findSchoolById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> schoolReposity.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service.Impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Teacher;</span><br><span class="line"><span class="keyword">import</span> com.itheima.repository.TeacherReposity;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.TeacherService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">TeacherService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TeacherReposity teacherReposity;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Teacher&gt; <span class="title function_">getTeacherList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> teacherReposity.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Optional&lt;Teacher&gt; <span class="title function_">findTeacherById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> teacherReposity.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（5）编写测试-1"><a href="#（5）编写测试-1" class="headerlink" title="（5）编写测试"></a>（5）编写测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.School;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Teacher;</span><br><span class="line"><span class="keyword">import</span> com.itheima.repository.SchoolReposity;</span><br><span class="line"><span class="keyword">import</span> com.itheima.repository.TeacherReposity;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneToManyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SchoolReposity schoolReposity;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TeacherReposity teacherReposity;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">School</span> <span class="variable">school1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">School</span>();</span><br><span class="line">        school1.setName(<span class="string">&quot;清华&quot;</span>);</span><br><span class="line">        schoolReposity.save(school1);</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        teacher1.setName(<span class="string">&quot;张分月&quot;</span>);</span><br><span class="line">        teacher1.setSchool(school1);</span><br><span class="line">        teacherReposity.save(teacher1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">School</span> <span class="variable">school1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">School</span>();</span><br><span class="line">        school1 = schoolReposity.findById(Long.valueOf(<span class="number">1</span>)).get();</span><br><span class="line">        List&lt;Teacher&gt; teachers = school1.getTeacherList();</span><br><span class="line">        <span class="keyword">for</span>(Teacher teacher : teachers)&#123;</span><br><span class="line">            System.out.println(teacher.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteSchoolById</span><span class="params">()</span>&#123;</span><br><span class="line">        schoolReposity.deleteById(Long.valueOf(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteTeacherById</span><span class="params">()</span> &#123;</span><br><span class="line">        teacherReposity.deleteById(Long.valueOf(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  控制台打印结果：</p><p>  添加：</p><p>  Hibernate: create table school (id bigint not null auto_increment, name varchar(255), primary key (id)) engine&#x3D;InnoDB<br>  Hibernate: create table teacher (id bigint not null auto_increment, name varchar(255), school_id bigint, primary key (id)) engine&#x3D;InnoDB<br>  Hibernate: alter table teacher add constraint FKrg46bnmgbcccayv14naymqg3r foreign key (school_id) references school (id)</p><p>  Hibernate: insert into school (name) values (?)<br>  Hibernate: insert into teacher (name, school_id) values (?, ?)</p><p>  查找：</p><p>  Hibernate: select school0_.id as id1_2_0_, school0_.name as name2_2_0_ from school school0_ where school0_.id&#x3D;?<br>  Hibernate: select teacherlis0_.school_id as school_i3_4_0_, teacherlis0_.id as id1_4_0_, teacherlis0_.id as id1_4_1_, teacherlis0_.name as name2_4_1_, teacherlis0_.school_id as school_i3_4_1_ from teacher teacherlis0_ where teacherlis0_.school_id&#x3D;?<br>  Hibernate: select school0_.id as id1_2_0_, school0_.name as name2_2_0_ from school school0_ where school0_.id&#x3D;?<br>  张分月</p><p>  删除学校：</p><p>  Hibernate: select school0_.id as id1_2_0_, school0_.name as name2_2_0_ from school school0_ where school0_.id&#x3D;?<br>  Hibernate: update teacher set school_id&#x3D;null where school_id&#x3D;?<br>  Hibernate: delete from school where id&#x3D;?</p><p>  删除教师：</p><p>  Hibernate: select teacher0_.id as id1_4_0_, teacher0_.name as name2_4_0_, teacher0_.school_id as school_i3_4_0_, school1_.id as id1_2_1_, school1_.name as name2_2_1_ from teacher teacher0_ left outer join school school1_ on teacher0_.school_id&#x3D;school1_.id where teacher0_.id&#x3D;?<br>  Hibernate: delete from teacher where id&#x3D;?</p><p>  在双向一对多关系中，注解@OneToMany（mappedBy&#x3D;’发出端实体名称小写）用于关系的发出端（即“One”的一方），同时关系的发出端需要定义一个集合类型的接收篇的字段属性；注解@ManyToOne用于关系的接收端（即“Many”的一方），关系的接收端需定义一个发出端的字段属性。</p><h2 id="实例：实现多对多映射"><a href="#实例：实现多对多映射" class="headerlink" title="实例：实现多对多映射"></a>实例：实现多对多映射</h2><h3 id="（1）创建实体类"><a href="#（1）创建实体类" class="headerlink" title="（1）创建实体类"></a>（1）创建实体类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Table(name = &quot;stdu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Column(columnDefinition = &quot;enum(&#x27;male&#x27;,&#x27;female&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="meta">@ManyToMany(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinTable(name = &quot;teacher_student&quot;,joinColumns = &#123;@JoinColumn(name = &quot;s_id&quot;)&#125;,</span></span><br><span class="line"><span class="meta">            inverseJoinColumns = &#123;@JoinColumn(name = &quot;t_id&quot;)&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Teacher&gt; teachers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ManyToMany(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinTable(name = &quot;teacher_student&quot;,joinColumns = &#123;@JoinColumn(name = &quot;t_id&quot;)&#125;,</span></span><br><span class="line"><span class="meta">            inverseJoinColumns = &#123;@JoinColumn(name = &quot;s_id&quot;)&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Student&gt; students;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在“多对多”关系中需要注意以下几点：</p><ul><li>关系两方都可以作为主控。</li><li>在 joinColumns 的@JoinColumn(name&#x3D;”t_id”)中, t_id 为 JoinTable 中的外键。由于 Student 和 Teacher 的主键都为 id,所以这里省略了 referencedColumnName&#x3D;”id”</li><li>在设计模型之间的级联关系时，要考虑好应该采用何种级联规则。</li><li>如果设置 cascade &#x3D; CascadeType.PERSIST,则在执行 save 时会调用 onPersist（）方 法。这个方法会递归调用外联类(Student或Teacher)的onPersist ()进行级联新增。 但因为值已经添加了，所以会报detached entity passed to persist错误，将级联操作取消 (去掉 “ cascade &#x3D; CascadeType.PERSIST”)即可</li></ul><h3 id="（2）创建测试"><a href="#（2）创建测试" class="headerlink" title="（2）创建测试"></a>（2）创建测试</h3><p>  由于Service和Repository层和上节中的一样，所以这里不再重复写代码，直接进入测试层的代码编写。如果不清楚怎么实现，请具体查看上节的源代码。创建以下测试代码  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Student;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Teacher;</span><br><span class="line"><span class="keyword">import</span> com.itheima.repository.StudentRepository;</span><br><span class="line"><span class="keyword">import</span> com.itheima.repository.TeacherReposity;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManyToManyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentRepository studentRepository;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TeacherReposity teacherReposity;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        Set&lt;Teacher&gt; teachers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Teacher&gt;();</span><br><span class="line">        Set&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Student&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        students.add(student1);</span><br><span class="line">        studentRepository.save(student1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student2.setName(<span class="string">&quot;李刚&quot;</span>);</span><br><span class="line">        students.add(student2);</span><br><span class="line">        studentRepository.save(student2);</span><br><span class="line"></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        teacher1.setName(<span class="string">&quot;罗老师&quot;</span>);</span><br><span class="line">        teacher1.setStudents(students);</span><br><span class="line">        teachers.add(teacher1);</span><br><span class="line">        teacherReposity.save(teacher1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  控制台打印如下：</p><p>  Hibernate: create table teacher (id bigint not null auto_increment, name varchar(255), school_id bigint, primary key (id)) engine&#x3D;InnoDB<br>  Hibernate: create table teacher_student (t_id bigint not null, s_id bigint not null, primary key (s_id, t_id)) engine&#x3D;InnoDB<br>  Hibernate: alter table teacher add constraint FKrg46bnmgbcccayv14naymqg3r foreign key (school_id) references school (id)<br>  Hibernate: alter table teacher_student add constraint FK5p0ij15uyb5oqnk3me34qjofn foreign key (s_id) references stdu (id)<br>  Hibernate: alter table teacher_student add constraint FK92l319wp07ku83lxjk9bglv4u foreign key (t_id) references teacher (id)</p><p>  Hibernate: insert into stdu (name, sex) values (?, ?)<br>  Hibernate: insert into stdu (name, sex) values (?, ?)<br>  Hibernate: insert into teacher (name) values (?)<br>  Hibernate: insert into teacher_student (t_id, s_id) values (?, ?)<br>  Hibernate: insert into teacher_student (t_id, s_id) values (?, ?)</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBCTemplate- SpringBoot（14）</title>
      <link href="/2022/07/20/JDBCTemplate-%20SpringBoot%EF%BC%8814%EF%BC%89/"/>
      <url>/2022/07/20/JDBCTemplate-%20SpringBoot%EF%BC%8814%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-认识-JDBCTemplate"><a href="#1-认识-JDBCTemplate" class="headerlink" title="1.认识 JDBCTemplate"></a>1.认识 JDBCTemplate</h1><h2 id="1-了解-JDBC"><a href="#1-了解-JDBC" class="headerlink" title="1.了解 JDBC"></a>1.了解 JDBC</h2><p>  学习使用 JDBCTempIate 之前，我们先来了解一下 JDBC( Java DataBase Connectivity )。 它是Java用于连接数据库的规范，也就是用于执行数据库SQL语句的Java API。从JDBC的名称上看，它似乎没有指定某种数据库。可以猜想它可以为多种数据库提供统一访问的接口，这更符合程序设计的模式。实际上，它由一组用Java语言编写的类和接口组成，为大部分关系型数据库提供访问接口。</p><p>  JDBC需要每次进行数据库连接，然后处理SQL语句、传值、关闭数据库。如果都由开发人员编写代码，则很容易岀错，可能会出现使用完成之后，数据库连接忘记关闭的情况。这容易导致连接被占用而降低性能，为了减少这种可能的错误，减少开发人员的工作量，JDBCtemplate就被设计岀来了</p><h2 id="2-了解-JDBCTemplate"><a href="#2-了解-JDBCTemplate" class="headerlink" title="2.了解 JDBCTemplate"></a>2.了解 JDBCTemplate</h2><p>  JDBCTemplate&#x3D;JDBC+Template的组合，是对JDBC的封装。它更便于程序实现，替我们完成所有的JDBC底层工作。因此，对于数据库的操作，再不需要每次都进行连接、打开、关闭了。 现在通过JDBCtemplate不需要进行全局修改，就可以轻松地应对开发人员常常要面对的增加、 删除、修改和查询操作。</p><p>  JDBC和JDBCtemplate就像是仓库管理员，负责从仓库（数据库）中存取物品。而后者不需 要”每次进入都开门，取完关门”，因为有电动门自动控制。下面通过具体使用JDBCTemplate的实例来理解它。</p><h2 id="实例-用JDBCTemplate实现数据的增加、删除、修改和查询"><a href="#实例-用JDBCTemplate实现数据的增加、删除、修改和查询" class="headerlink" title="实例: 用JDBCTemplate实现数据的增加、删除、修改和查询"></a>实例: 用JDBCTemplate实现数据的增加、删除、修改和查询</h2><h3 id="（1）配置基础依赖"><a href="#（1）配置基础依赖" class="headerlink" title="（1）配置基础依赖"></a>（1）配置基础依赖</h3><p>使用JDBCTemplate,则需要添加其Starter依赖。因为要操作数据库，所以也需要配置数据库（以MySQL为例）的连接依赖，见以下代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  添加完依赖后，还需要配置数据库的连接信息。这样JDBCTemplate才能正常连接到数据库。 在application.yml配置文件中配置数据库的地址和用户信息，见以下代码：“配置IP地址、编码、时区和SSL”</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="（2）新建实体类"><a href="#（2）新建实体类" class="headerlink" title="（2）新建实体类"></a>（2）新建实体类</h3><p>新建一个测试实体类User,实现RowMapper类，重写mapRow方法，以便实体字段和数据表字段映射(对应)，映射是指把Java中设置的实体字段和MySQL数据库的字段对应起来，因 为实体的id可以对应数据库字段的u_id,也可以对应id、name等。如果不重写，则程序不知道如 何对应。具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">RowMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(rs.getLong(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        user.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        user.setAge(rs.getInt(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）操作数据"><a href="#（3）操作数据" class="headerlink" title="（3）操作数据"></a>（3）操作数据</h3><p>  JDBCTemplate提供了以下操作数据的3个方法。</p><ul><li>execute：表示“执行”，用于直接执行SQL语句</li><li>update：表示“更新”，包括新增、修改、删除操作。</li><li>query；表示查询。</li></ul><p>  下面使用这3个方法来实现数据的增加、删除、修改和查询功能。</p><h4 id="1-创建数据表"><a href="#1-创建数据表" class="headerlink" title="1.创建数据表"></a>1.创建数据表</h4><p>  在使用JDBCTemplate之前，需要在控制器中注入JDBCTemplate,然后就可以通过 “execute”方法执行SQL操作了，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserControllerTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUserTable</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;create table `user` (\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;`id` int(10) not null auto_increment,\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;`name` varchar(100) default null,\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;`age` int(10) default null,\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;primary key (`id`)\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;)engine=InnoDB auto_increment=1 default charset=utf8;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        jdbcTemplate.execute(sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-添加数据。"><a href="#2-添加数据。" class="headerlink" title="2.添加数据。"></a>2.添加数据。</h4><p>  添加数据可以通过“update”方法来执行，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUserTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into user (name,age) values(&#x27;buretuzi&#x27;,&#x27;12&#x27;)&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> jdbcTemplate.update(sql);</span><br><span class="line">    System.out.println(rows);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-查询数据"><a href="#3-查询数据" class="headerlink" title="3.查询数据"></a>3.查询数据</h4><p>以下代码是根据name查询单个记录，执行下面sql字符串里的SQL语句(SELECT * FROM user WHERE USERNAME &#x3D; ? )，这里需要通过“query”方法来执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUserByName</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;buretuzi&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where name = ?&quot;</span>;</span><br><span class="line">    List&lt;User&gt; users = jdbcTemplate.query(sql,<span class="keyword">new</span> <span class="title class_">User</span>(),<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;name&#125;);</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-查询所有记录"><a href="#4-查询所有记录" class="headerlink" title="4.查询所有记录"></a>4.查询所有记录</h4><p>  查询所有记录和查询单个记录一样，也是执行“query”方法。区别是，SQL语句使用了查询通配符见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user&quot;</span>;</span><br><span class="line">    List&lt;User&gt; users = jdbcTemplate.query(sql,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>(User.class));</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-修改数据。"><a href="#5-修改数据。" class="headerlink" title="5.修改数据。"></a>5.修改数据。</h4><p>  要进行数据的修改，可以使用“update”方法来实现，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserPassword</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;12331313&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set name = ? where id = ?&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> jdbcTemplate.update(sql,password,id);</span><br><span class="line">    System.out.println(rows);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-删除数据。"><a href="#6-删除数据。" class="headerlink" title="6.删除数据。"></a>6.删除数据。</h4><p>  这里删除数据并不用DELETE方法，而是通过“update”方法来执行SQL语句中的“DELETE” 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUserById</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from user where id = ?&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> jdbcTemplate.update(sql,<span class="number">1</span>);</span><br><span class="line">    System.out.println(rows);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  至此，已经实现了简单的增加、删除、修改和查询功能。如果读者对关系型数据库的SQL语句不陌生，那么实现起来会非常简单。因为JDBCTemplate实现起来比ORM烦琐，所以大部分开发人员使用的是ORM (JPA和MyBatis)。但是JDBCTemplate依然有市场，因为学习成本低， 会一些SQL语句就能上手使用，操作虽然麻烦，但很容易学会。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元测试- SpringBoot（13）</title>
      <link href="/2022/07/18/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%20SpringBoot%EF%BC%8813%EF%BC%89/"/>
      <url>/2022/07/18/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%20SpringBoot%EF%BC%8813%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1.单元测试"></a>1.单元测试</h1><p>单元测试(unit test)是为了检验程序的正确性。一个单元可能是单个程序、类、对象、方法 等，它是应用程序的最小可测试部件。</p><p>单元测试的必要性如下：</p><ul><li>预防Bug。</li><li>快速定位Bug。</li><li>提高代码质量，减少耦合。</li><li>减少调试时间。</li><li>减少重构的风险。</li></ul><h1 id="2-Spring-Boot的测试库"><a href="#2-Spring-Boot的测试库" class="headerlink" title="2.Spring Boot的测试库"></a>2.Spring Boot的测试库</h1><p>Spring Boot提供了 spring-boot-starter-test启动器。通过它，能引入一些有用的测试库， 如下所示。</p><ul><li>Spring Test&amp;Spring Boot Test： Spring Boot提供的应用程序功能集成化测试支持。</li><li>Junit： Java应用程序单元测试标准类库。</li><li>AssertJ：轻量级的断言类库。</li><li>Hamcrest：对象匹配器类库。</li><li>Mockito: Java Mock 测试框架。</li><li>JsonPath： JSON 操作类库。</li><li>JSONassert：用于JSON的断言库。</li></ul><h2 id="2-1回归测试框架JUnit"><a href="#2-1回归测试框架JUnit" class="headerlink" title="2.1回归测试框架JUnit"></a>2.1回归测试框架JUnit</h2><p>JUnit是对程序代码进行单元测试的Java框架。它用来编写自动化测试工具，降低测试的难度、 减少烦琐性，并有效避免岀现程序错误。</p><p>JUnit测试是白盒测试(因为知道测试如何完成功能和完成什么样的功能)。要使用JUnit,则 只需要继承TestCase类。</p><p>JUnit提供以下注解。</p><ul><li>@BeforeClass：在所有测试单元前执行一次，一般用来初始化整体的代码。</li><li>@AfterClass：在所有测试单元后执行一次，一般用来销毁和释放资源。</li><li>@Before：在每个测试单元前执行，一般用来初始化方法。</li><li>@After：任每个测试单元后执行，一股用来回滚测试数据。</li><li>@Test：辐写测试用例。</li><li>@Test(timeout&#x3D;1000)：对测试单元进行限时。这里的”1000”表示若超过1s则超时， 测试失败。</li><li>@Test(expected&#x3D;Exception.class)：指定测试单元期望得到的异常类。如果执行完成后 没有抛出指定的异常，则测试失败。</li><li>@Ignore：执行测试时将忽略掉此方法。如果用于修饰类，则忽略基个类。</li><li>@RunWith： 再JUnit中有很多Runner,它们负责调用测试代码。毎个Runner都有特殊功能，应根据需要选择不同的Runner来运行测试代码。</li></ul><h2 id="2-2assertThat"><a href="#2-2assertThat" class="headerlink" title="2.2assertThat"></a>2.2assertThat</h2><p>Unit 4.4结合Hamcrest提供了一个新的断言语法 ——— assertThat。使用assertThat的一个断言语句结合Hamcrest提供的匹配符，就可以表达全部的测试思想。</p><h3 id="（1）assertThat的基本语法如下"><a href="#（1）assertThat的基本语法如下" class="headerlink" title="（1）assertThat的基本语法如下"></a>（1）assertThat的基本语法如下</h3><p>  assertThat( [value], [matcher statement] )</p><ul><li>value：要测试的变量值。</li><li>matcher statement：如果value值与matcher statement所表达的朗望值相符，则测试</li></ul><p>  成功，否则失败。简单地说，就是“两个值逬行比较”</p><h3 id="（2）一般匹配符"><a href="#（2）一般匹配符" class="headerlink" title="（2）一般匹配符"></a>（2）一般匹配符</h3><p>  <code>assertThat(testNumber,allof(greaterThan(5),lessThan(8)))</code>：allOf 表示，所有条件必须都成立，测试才能通过</p><p>  <code>assertThat(testNumber,anyOf(greaterThan(5),lessThan(8)))</code>：anyOf 表示，所有 条件只要有一个成立，则测试通过G</p><p>  <code>assertThat(testNumber,anything())</code>：anything表示,无论什么条件，结果永远为“true”</p><h3 id="（3）字符串相关匹配符"><a href="#（3）字符串相关匹配符" class="headerlink" title="（3）字符串相关匹配符"></a>（3）字符串相关匹配符</h3><p>  <code>assertThat(testNumber,is(&quot;buretuzi&quot;))</code>：is 表示，如果前面待测的 testString 等于后面给出的String,则测试通过。</p><p>  <code>assertThat(testNumber,not(&quot;buretuzi&quot;))</code>： not 表示，如果前面待测的 String 不等于后面给出的String,则测试通过。</p><p>  <code>assertThat(testNumber,containsString(&quot;buretuzi&quot;))</code>：containsString 表示，如果测试的字符串teststring 子字符串 “buretuzi”  ,则测试通过</p><p>  <code>assertThat(testNumber,endWith(&quot;zi&quot;))</code>：endsWith 表示，如果测试的字符串 teststring以子字符串 “zi” 结尾，则测试通过。</p><p>  <code>assertThat(testNumber,startWith(&quot;bu&quot;))</code>：starts With 表示，如果测试的字符串 teststring以子字符串“bu”_开始，_则测试通过。</p><p>  <code>assertThat(testNumber,equalTo(&quot;bu&quot;))</code>：equalTo 表示，如果测试的 testValue 等于Value,则测试通过。equalTo可以用来测试数值、字符串和对象。</p><p>  <code>assertThat(testNumber,equalToIgnoreCase(&quot;bu&quot;))</code>：equalToIgnoringCase 表示， 如果测试的字符串teststring在忽略大小写的情况下等于“bu” ,则测试通过。</p><p>  <code>assertThat(testNumber,equalToIgnoreWhiteSpace(&quot;bu&quot;))</code>：equalToIgnoring- WhiteSpace表示，如果测试的字符串teststring在忽略头尾的任意一个空格的情况下等于 “bu”，则测试通过。字符串中的空格不能被忽略。</p><h3 id="（4）数值相关匹配符"><a href="#（4）数值相关匹配符" class="headerlink" title="（4）数值相关匹配符"></a>（4）数值相关匹配符</h3><p>  <code>assertThat(testDouble,closeTo(1.0,8.8))</code>：closeTo 表示，如果测试的浮点型数 testDouble在1.0 ~8.8之间,则测试通过。</p><p>  <code>assertThat(testNumber,greaterThan(2.0))</code>：greaterThan 表示，如果测试的数值 testNumber大于2.0,则测试通过</p><p>  <code>assertThat(testNumber,lessThan(35.0)))</code>：lessThan 表示，如果测试的数值 testNumber小于35.0,则测试通过</p><p>  <code>assertThat(testNumber,greaterThanOrEqualTo(3.0))</code>：greaterThanOrEqualTo表示，如果测试的数值estNumber大于或等于3.0,则测试通过。</p><p>  <code>assertThat(testNumber,lessThanOrEqualTo(3.0))</code>：lessThanOrEqualTo 表示， 如果测试的数值testNumber小于或等于3.0,则测试通过。</p><h3 id="（5）collection相关匹配符"><a href="#（5）collection相关匹配符" class="headerlink" title="（5）collection相关匹配符"></a>（5）collection相关匹配符</h3><p>  <code>assertThat(mObject,hasEntry(&quot;key&quot;,&quot;value&quot;))</code>：hasEntry 表示，如果测试的 Map 对象mObject含有一个键值为“key”对应元素值为“value”的Entry项，则测试通过</p><p>  <code>assertThat(mObject,hasKey(&quot;key&quot;))</code>：hasKey 表示，如果测试的 Map 对象 mObject 含有键值“key”，则测试通过。</p><p>  <code>assertThat(mObject,hasValue(&quot;key&quot;))</code>：hasVafue 表示，如果测试的 Map 对象 mObject含有元素值“value”，则测试通过。</p><p>  <code>assertThat(mObject,hasItem(&quot;bu&quot;))</code>：hasltem 表示,如果测试的迭代对象 iterableObject含有元素“bu”项，则测试通过。</p><h2 id="2-3-了解-Mockito"><a href="#2-3-了解-Mockito" class="headerlink" title="2.3.了解 Mockito"></a>2.3.了解 Mockito</h2><p>  Mockito是GitHub上使用最广泛的Mocking框架。它提供简洁的API用来测试。Mockito简单易学、可读性强、验证语法简洁。</p><p>  与JUnit结合使用，Mockito框架可以创建和配置Mock对象。</p><h2 id="2-4了解-JSONPath"><a href="#2-4了解-JSONPath" class="headerlink" title="2.4了解 JSONPath"></a>2.4了解 JSONPath</h2><p>  JSONPath是xPath在JSON中的应用。它的数据结构通常不一定有根元素，它用一个抽象的名字来表示最外层对象，而且允许使用通配符“*”表示所有的子元素名和数组素引。</p><p>  JSONPath表达式可以使用符号解析JSON,如以下代码：</p><p>  $.person.card[0].num</p><p>或使用符号，如以下代码：</p><p>  $[‘person’][‘card’][0][‘num’]</p><h2 id="2-5测试的回滚"><a href="#2-5测试的回滚" class="headerlink" title="2.5测试的回滚"></a>2.5测试的回滚</h2><p>  在单元测试中可能会产生垃圾数据,可以开启事务功能进行回滚——在方法或类头部添加注解 @Transactional即可。用法见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Book;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.BookService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CardRepositoryTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRollback</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setUsername(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        book.setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        bookService.insert(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上述代码在类上添加了注解@Transactional,测试完成后就会回滚，不会产生垃圾数据。如果要关闭回滚，则只要加上注解@Rollback(false)即可</p><h2 id="2-6快速创建测试单元"><a href="#2-6快速创建测试单元" class="headerlink" title="2.6快速创建测试单元"></a>2.6快速创建测试单元</h2><p>在Spring Boot中进行单元测试很简单，它已经自动添加好了 Test的Starter依赖，见下方依赖元素：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  创建一个测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释如下。</p><ul><li>@SpringBootTest:是Spring Boot用于测试的注解，可指定入口类或测试环境等。</li><li>@RunWith(SpringRunner.class):让测试运行于 Spring 的测试环境。</li><li>@Test：表示为一个测试单元。在要测试的方法上加注解@Test,然后鼠标右击“Run” （或单击其左边的绿色三角箭头）即可进行测试。</li></ul><p>除用这种方式创建测试单元外，还可以通过IDEA的快捷键快速完成创建。</p><p>在IDEA中，快速创建测试单元主要有以下3种方式：</p><ul><li>通过快捷键Ctrl+Shift+T （在Windows系统中）来创建测试。</li><li>单击菜单栏中的”NavigatoLTest”命令。</li><li>在方法处单击鼠标右键，在弹出的菜单中选择“GoTo-Test”命令。</li></ul><h2 id="2-7-Controller层的单元测试"><a href="#2-7-Controller层的单元测试" class="headerlink" title="2.7 Controller层的单元测试"></a>2.7 Controller层的单元测试</h2><h3 id="（1）创建一个用于测试的控制器"><a href="#（1）创建一个用于测试的控制器" class="headerlink" title="（1）创建一个用于测试的控制器"></a>（1）创建一个用于测试的控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JunitController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  代码解释如下：</p><ul><li>@RestController：代表这个类是REST风格的控制器，返回JSON&#x2F;XML类型的数据。</li><li>@RequestMapping：用于配置URL和方法之间的映射。可用在类和方法上。用在方法上， 则其路径会继承用在类上的路径。</li></ul><h3 id="（2）编写测试"><a href="#（2）编写测试" class="headerlink" title="（2）编写测试"></a>（2）编写测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.https.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MvcResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.result.MockMvcResultHandlers;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloControllerTest</span> &#123;</span><br><span class="line">    <span class="comment">//启用web上下文</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext webApplicationContext;</span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//使用上下文构建MockMvc</span></span><br><span class="line">        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//得到MvcResult自定义验证，执行请求</span></span><br><span class="line">        <span class="type">MvcResult</span> <span class="variable">mvcResult</span> <span class="operator">=</span> mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/hello&quot;</span>)</span><br><span class="line">                <span class="comment">//发送post请求</span></span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">                <span class="comment">//传入参数</span></span><br><span class="line">                .param(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;buretuzi&quot;</span>)</span><br><span class="line">                <span class="comment">//接收的类型</span></span><br><span class="line">                .accept(MediaType.APPLICATION_JSON_UTF8))</span><br><span class="line">                <span class="comment">//判断接收到的状态是否是200，等同于Assert.assertEquals(200, status);</span></span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                <span class="comment">//等同于Assert.assertEquals(&quot;hello buretuzi&quot;,content);</span></span><br><span class="line">                .andExpect(MockMvcResultMatchers.content().string(<span class="string">&quot;hello buretuzi&quot;</span>))</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                <span class="comment">//返回MockMvc</span></span><br><span class="line">                .andReturn();</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> mvcResult.getResponse().getStatus();</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> mvcResult.getResponse().getContentAsString();</span><br><span class="line">        Assert.assertEquals(<span class="number">200</span>, status);</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;hello buretuzi&quot;</span>,content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释如下：</p><ul><li>@SpringBootTest：是Spring Boot用于测试的注解，可指定入口类或测试环境等。</li><li>@RunWith(SpringRunner.class):让测试运行于 Spring 的测试环境。</li><li>@Test：表示一个测试单元。</li><li>WebApplicationContext：启用Web上下文，用于获取Bean中的内容。</li><li>@Before：表示在测试单元执行前执行。这里使用上下文构建MockMvc</li><li>get：指定请求方式是GET。一般用浏览器打开网页就是GET方式。</li></ul><p>  运行测试，在控制器中会输出以下结果:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MockhttpsServletRequest:</span><br><span class="line">      <span class="type">https</span> <span class="variable">Method</span> <span class="operator">=</span> GET</span><br><span class="line">      <span class="type">Request</span> <span class="variable">URI</span> <span class="operator">=</span> /<span class="type">hello</span></span><br><span class="line">       <span class="variable">Parameters</span> <span class="operator">=</span> &#123;name=[buretuzi]&#125;</span><br><span class="line">          Headers = [Content-Type:<span class="string">&quot;application/json;charset=UTF-8&quot;</span>, Accept:<span class="string">&quot;application/json;charset=UTF-8&quot;</span>]</span><br><span class="line">             Body = <span class="literal">null</span></span><br><span class="line">    <span class="type">Session</span> <span class="variable">Attrs</span> <span class="operator">=</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">Handler:</span><br><span class="line">             Type = com.itheima.controller.<span class="type">JunitController</span></span><br><span class="line">           <span class="variable">Method</span> <span class="operator">=</span> com.itheima.controller.JunitController#hello(String)</span><br><span class="line"></span><br><span class="line">Async:</span><br><span class="line">    <span class="type">Async</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">     <span class="type">Async</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">Resolved Exception:</span><br><span class="line">             Type = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">ModelAndView:</span><br><span class="line">        <span class="type">View</span> <span class="variable">name</span> <span class="operator">=</span> <span class="type">null</span></span><br><span class="line">             <span class="variable">View</span> <span class="operator">=</span> <span class="type">null</span></span><br><span class="line">            <span class="variable">Model</span> <span class="operator">=</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">FlashMap:</span><br><span class="line">       Attributes = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">MockhttpsServletResponse:</span><br><span class="line">           Status = <span class="number">200</span></span><br><span class="line">    <span class="type">Error</span> <span class="variable">message</span> <span class="operator">=</span> <span class="type">null</span></span><br><span class="line">          <span class="variable">Headers</span> <span class="operator">=</span> [Content-Type:<span class="string">&quot;application/json;charset=UTF-8&quot;</span>, Content-Length:<span class="string">&quot;14&quot;</span>]</span><br><span class="line">     <span class="type">Content</span> <span class="variable">type</span> <span class="operator">=</span> application/json;charset=UTF-<span class="number">8</span></span><br><span class="line">             Body = hello buretuzi</span><br><span class="line">    <span class="type">Forwarded</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="literal">null</span></span><br><span class="line">   <span class="type">Redirected</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="type">null</span></span><br><span class="line">          <span class="variable">Cookies</span> <span class="operator">=</span> []</span><br></pre></td></tr></table></figure><h2 id="2-8-Service层的单元测试"><a href="#2-8-Service层的单元测试" class="headerlink" title="2.8 Service层的单元测试"></a>2.8 Service层的单元测试</h2><h3 id="（1）创建实体类"><a href="#（1）创建实体类" class="headerlink" title="（1）创建实体类"></a>（1）创建实体类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）创建服务类"><a href="#（2）创建服务类" class="headerlink" title="（2）创建服务类"></a>（2）创建服务类</h3><p>这里用@Service来标注服务类，并实例化了一个User对象，见以下代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        user.setAge(<span class="number">13</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;八嘎&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）编写测试"><a href="#（3）编写测试" class="headerlink" title="（3）编写测试"></a>（3）编写测试</h3><p>  编写测试用于比较实例化的实体User和测试预期值是否一样，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.is;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUserinfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getUser();</span><br><span class="line">        Assert.assertEquals(<span class="number">13</span>,user.getAge());</span><br><span class="line">        Assert.assertThat(user.getName(), is(<span class="string">&quot;嘎&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   运行测试，结果显示出错，表示期望的值和实际值不一样，如下所示。</p><p>  java.lang.AssertionError:</p><p>  Expected: is “嘎”</p><p>    but: was “八嘎”</p><p>  <Click to see difference></p><h2 id="2-9-Repository层的单元测试"><a href="#2-9-Repository层的单元测试" class="headerlink" title="2.9 Repository层的单元测试"></a>2.9 Repository层的单元测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Book;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.BookService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookRepositoryTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Book&gt; books = (List&lt;Book&gt;) bookService.findAll();</span><br><span class="line">        <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">            System.out.println(book.getUsername());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRollback</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setUsername(<span class="string">&quot;干净又卫生&quot;</span>);</span><br><span class="line">        bookService.insert(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释如下。</p><ul><li>@Transactional：即回滚的意思。所有方法执行完之后，回滚成原来的样子。</li><li>testRollBank方法：执行添加一条记录。如果开启了@Transactional,则会在添加之后进行回滚，删除刚添加的数据，如果注释掉@Transactional, 则完成添加后不回滚。在测试时可以尝试去掉和添加@Transactional状态下的不同效果。这里的@Transactional 放在类上，也可以加在方法上以作用于方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用控制器通知- SpringBoot（12）</title>
      <link href="/2022/07/17/%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%9A%E7%9F%A5-%20SpringBoot%EF%BC%8812%EF%BC%89/"/>
      <url>/2022/07/17/%E4%BD%BF%E7%94%A8%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%9A%E7%9F%A5-%20SpringBoot%EF%BC%8812%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="控制器通知"><a href="#控制器通知" class="headerlink" title="控制器通知"></a>控制器通知</h1><p>  在编写代码时，需要对异常进行处理。进行异常处理的普通的代码是try-catch结构。但在开发业务时，只想关注业务正常的代码，对于catch语句中的捕获异常，希望交给异常捕获来处理，不单独在每个方法中编写。这样不仅可以减少冗余代码，还可以减少因忘记写catch而岀现错误的概率。Spring正好提供了一个非常方便的异常处理方案——控制器通知@ControllerAdvice或 @RestcontrollerAdvice),它将所有控制器作为一个切面，利用切面技术来实现。通过基于@ControllerAdvice或@RestControllerAdvice的注解可以对异常进行全局统一处理，默认对所有的Controller有效。如果要限定生效范围，则可以使用ContrallerAdvice支持的限定范围方式。</p><ul><li>按注解：@ControllerAdvice(annotations &#x3D; RestController.class) </li><li>按包名：@ControllerAdvice(“org.example.controller”）</li><li>按类型：@ControllerAdvice(assignableTypes &#x3D; {Controllerinterface.class, Abstract- Controller.class})</li></ul><p>这是ControllerAdvice进行统一异常处理的优点，它能够细粒度地控制该异常处理器针对娜些 Controller、包或类型有效。</p><p>可以利用这一特性在一个系统实现多个异常处理器，然后Controller可以有选择地决定使用哪 个，使得异常处理更加灵活，降低侵入性。</p><p>异常处理类会包含以下一个或多个方法。</p><ul><li>@lnitBinder:对表单数据进行绑定，用于定义控制器参数绑定规则。如转换规则、格式化 等。可以通过这个注解的方法得到WebDataBinder对象，它在参数转换之前被执行。</li><li>@ModelAttribute：在控制器方法被执行前，对所有Controller的Model添加属性进行操作。</li><li>@ExceptionHandler：定义控制器发生异常后的操作，可以拦截所有控制器发生的异常。</li><li>@ControllerAdvice:统一异常处理，通过 @ExceptionHandler(value &#x3D; class) 来指定捕获的异常。”@ControllerAdvice + @ExceptionHandle”可以处理除“404” 以外的运行异常。</li></ul><h2 id="实例：自定义错误处理控制器"><a href="#实例：自定义错误处理控制器" class="headerlink" title="实例：自定义错误处理控制器"></a>实例：自定义错误处理控制器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.error.ErrorController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestErrorController</span> <span class="keyword">implements</span> <span class="title class_">ErrorController</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getErrorPath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">handleError</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,<span class="number">404</span>);</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;ok&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">noError</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,<span class="number">200</span>);</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;正常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目，访问一个不存在的网址，则返回下方信息：</p><p>{“msg”:”不存在”，”code”:404}</p><p>访问正确定义的映射”<a href="https://localhost:8080/error/ok&quot;,%E5%88%99%E8%BF%94%E5%9B%9E%E4%B8%8B%E6%96%B9%E6%AD%A3%E7%A1%AE%E4%BF%A1%E6%81%AF%EF%BC%9A">https://localhost:8080/error/ok&quot;,则返回下方正确信息：</a></p><p>{“msg”:”正常”,”code”:200}</p><h2 id="实例：自定义业务异常类"><a href="#实例：自定义业务异常类" class="headerlink" title="实例：自定义业务异常类"></a>实例：自定义业务异常类</h2><h3 id="（1）自定义异常类"><a href="#（1）自定义异常类" class="headerlink" title="（1）自定义异常类"></a>（1）自定义异常类</h3><p>  自定义异常类需要继承Exception (异常)类。这里继承RuntimeException,</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）自定义全局捕获异常"><a href="#（2）自定义全局捕获异常" class="headerlink" title="（2）自定义全局捕获异常"></a>（2）自定义全局捕获异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.exception.BusinessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerBusinessExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">businessExceptionHandler</span><span class="params">(BusinessException e)</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,e.getCode());</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ControllerAdvice："><a href="#ControllerAdvice：" class="headerlink" title="@ControllerAdvice："></a>@ControllerAdvice：</h4><p>   对于@ControllerAdvice，我们比较熟知的用法是结合@ExceptionHandler用于全局异常的处理，但其作用不止于此。ControllerAdvice拆开来就是Controller Advice，关于Advice，在Spring的AOP中，是用来封装一个切面所有属性的，包括切入点和需要织入的切面逻辑。这里ControllerAdvice也可以这么理解，其抽象级别应该是用于对Controller进行切面环绕的，而具体的业务织入方式则是通过结合其他的注解来实现的。@ControllerAdvice是在类上声明的注解，其用法主要有三点：</p><p>1.结合方法型注解@ExceptionHandler，用于捕获Controller中抛出的指定类型的异常，从而达到不同类型的异常区别处理的目的。</p><p>2.结合方法型注解@InitBinder，用于request中自定义参数解析方式进行注册，从而达到自定义指定格式参数的目的。</p><p>3.结合方法型注解@ModelAttribute，表示其注解的方法将会在目标Controller方法执行之前执行。</p><p>   从上面的讲解可以看出，@ControllerAdvice的用法基本是将其声明在某个bean上，然后在该bean的方法上使用其他的注解来指定不同的织入逻辑。不过这里@ControllerAdvice并不是使用AOP的方式来织入业务逻辑的，而是Spring内置对其各个逻辑的织入方式进行了内置支持。</p><p>   @Component用于声明@ExceptionHandler 、 @InitBinder或@ModelAttribute方法的类的特化，以便在多个@Controller类之间共享。<br>   使用@ControllerAdvice注释的类可以显式声明为 Spring bean 或通过类路径扫描自动检测。所有此类 bean 都基于Ordered语义或@Order &#x2F; @Priority声明进行排序， Ordered语义优先于@Order &#x2F; @Priority声明。然后在运行时按该顺序应用@ControllerAdvice bean。但是请注意，实现PriorityOrdered的@ControllerAdvice bean 的优先级不高于实现Ordered的@ControllerAdvice bean。此外， Ordered不适用于作用域@ControllerAdvice bean — 例如，如果此类 bean 已配置为请求作用域或会话作用域 bean。为了处理异常， @ExceptionHandler将在第一个通知中选择一个匹配的异常处理程序方法。对于模型属性和数据绑定初始化，@ @ModelAttribute和@InitBinder方法将遵循@ControllerAdvice顺序。<br>   注意：对于@ExceptionHandler方法，在特定通知 bean 的处理程序方法中，根异常匹配将优于仅匹配当前异常的原因。但是，高优先级通知上的原因匹配仍将优先于低优先级通知 bean 上的任何匹配（无论是根级别还是原因级别）。因此，请在具有相应顺序的优先通知 bean 上声明您的主根异常映射。<br>默认情况下， @ControllerAdvice ControllerAdvice 中的方法全局应用于所有控制器。使用诸如annotations 、 basePackageClasses和basePackages （或其别名value ）之类的选择器来定义目标控制器的更窄子集。如果声明了多个选择器，则应用布尔OR逻辑，这意味着所选控制器应至少匹配一个选择器。请注意，选择器检查是在运行时执行的，因此添加许多选择器可能会对性能产生负面影响并增加复杂性。</p><h4 id="ExceptionHandler："><a href="#ExceptionHandler：" class="headerlink" title="@ExceptionHandler："></a>@ExceptionHandler：</h4><p>   用于处理特定处理程序类和&#x2F;或处理程序方法中的异常的注释。<br>使用此注释注释的处理程序方法可以具有非常灵活的签名。它们可能具有以下类型的参数，按任意顺序：异常参数：声明为一般异常或更具体的异常。如果注释本身没有通过其value()缩小异常类型，这也可用作映射提示。请求和&#x2F;或响应对象（通常来自 Servlet API）。您可以选择任何特定的请求&#x2F;响应类型，例如javax.servlet.ServletRequest &#x2F; javax.servlet.https.httpsServletRequest 。<br>会话对象：通常是javax.servlet.https.httpsSession 。这种类型的参数将强制存在相应的会话。因此，这样的论点永远不会是null 。请注意，会话访问可能不是线程安全的，尤其是在 Servlet 环境中：如果允许多个请求同时访问会话，请考虑将”synchronizeOnSession”标志切换为“true”。<br>   org.springframework.web.context.request.WebRequest或org.springframework.web.context.request.NativeWebRequest 。允许通用请求参数访问以及请求&#x2F;会话属性访问，而不与本机 Servlet API 绑定。<br>java.util.Locale用于当前请求的语言环境（由可用的最具体的语言环境解析器确定，即在 Servlet 环境中配置的org.springframework.web.servlet.LocaleResolver ）。<br>java.io.InputStream &#x2F; java.io.Reader用于访问请求的内容。这将是 Servlet API 公开的原始 InputStream&#x2F;Reader。<br>java.io.OutputStream &#x2F; java.io.Writer用于生成响应的内容。这将是 Servlet API 公开的原始 OutputStream&#x2F;Writer。<br>org.springframework.ui.Model作为从处理程序方法返回模型映射的替代方法。请注意，提供的模型未预先填充常规模型属性，因此始终为空，以便为特定于异常的视图准备模型。<br>处理程序方法支持以下返回类型：<br>一个ModelAndView对象（来自 Servlet MVC）。<br>一个org.springframework.ui.Model对象，视图名称通过org.springframework.web.servlet.RequestToViewNameTranslator隐式确定。<br>用于公开模型的java.util.Map对象，视图名称通过org.springframework.web.servlet.RequestToViewNameTranslator隐式确定。<br>一个org.springframework.web.servlet.View对象。<br>一个String值，它被解释为视图名称。<br>@ResponseBody注释方法（仅限 Servlet）来设置响应内容。返回值将使用消息转换器转换为响应流。<br>用于设置响应标头和内容的httpsEntity<?>或ResponseEntity<?>对象（仅限 Servlet）。 ResponseEntity 正文将使用消息转换器进行转换并写入响应流。<br>void如果方法本身处理响应（通过直接编写响应内容，为此目的声明javax.servlet.ServletResponse &#x2F; javax.servlet.https.httpsServletResponse类型的参数）或者视图名称应该通过隐式确定org.springframework.web.servlet.RequestToViewNameTranslator （不在处理程序方法签名中声明响应参数）。<br>您可以将ExceptionHandler注释与@ResponseStatus结合使用以获取特定的 https 错误状态。</p><h3 id="（3）测试自定义异常类"><a href="#（3）测试自定义异常类" class="headerlink" title="（3）测试自定义异常类"></a>（3）测试自定义异常类</h3><p>  创建控制器，以抛BusinessException的自定义异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.exception.BusinessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;BusinessException&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testBusinessExceptionStatus</span><span class="params">(<span class="meta">@RequestParam(&quot;i&quot;)</span> <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="number">600</span>,<span class="string">&quot;这是自定义异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  启动项目，访问 “<a href="https://localhost:8080/BusinessException?i=0&quot;">https://localhost:8080/BusinessException?i=0&quot;</a> 测试异常处理情况，则抛出下方错误信息：</p><p>  {“code”:600,”message”:”这是自定义异常”}</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常处理- SpringBoot（11）</title>
      <link href="/2022/07/17/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%20SpringBoot%EF%BC%8811%EF%BC%89/"/>
      <url>/2022/07/17/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%20SpringBoot%EF%BC%8811%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-异常处理"><a href="#1-异常处理" class="headerlink" title="1.异常处理"></a>1.异常处理</h1><h2 id="1-1-异常处理的必要性"><a href="#1-1-异常处理的必要性" class="headerlink" title="1.1.异常处理的必要性"></a>1.1.异常处理的必要性</h2><p>  异常处理用于解决一些程序无法掌控，但又必须面对的情况。例如，程序需要读取文件、连接网络、使用数据库等，但可能文件不存在、网络不畅通、数据库无效等情况。为了程序能继续运行， 此时就需要把这些情况进行异常处理。异常处理的方法通常有以下几种：</p><ul><li>将异常通知给开发人员、运维人员或用户。</li><li>使因为异常中断的程序以适当的方式继续运行，或者退岀。</li><li>保存用户的当前操作，或者进行数据回滚。</li><li>释放资源。</li></ul><h2 id="1-2-异常的分类"><a href="#1-2-异常的分类" class="headerlink" title="1.2.异常的分类"></a>1.2.异常的分类</h2><ul><li>Error：代表编译和系统的错误，不允许捕获。</li><li>Exception：标准Java库的方法所激发的异常，包含运行异常Runtime_Exception和非运行异常Non_RuntimeException的子类。</li><li>Runtime Exception：运行时异常。</li><li>Non_RuntimeException：非运行时可检测的异常，Java编译器利用分析方法或构造方法中可能产生的结果来检测程序中是否含有检测异常的处理程序，每个可能的可检测异常、方法或构造方法的throws子句必须列出该异常对应的类。</li><li>Throw：用户自定义异常。</li></ul><h2 id="1-3-如何处理异常"><a href="#1-3-如何处理异常" class="headerlink" title="1.3.如何处理异常"></a>1.3.如何处理异常</h2><h3 id="（1）捕获异常。"><a href="#（1）捕获异常。" class="headerlink" title="（1）捕获异常。"></a>（1）捕获异常。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释如下。</p><ul><li>try：在try语句中编写可能发生异常的代码，即正常的业务功能代码。如果执行完try语句不发生异常，则执行finally语句(如果有的话)和finally后面的代码；如果发生异常，则尝试去匹配catch语句。</li><li>catch：捕捉错误并处理。</li><li>finally： finally语句是可选的，无论异常是否发生、是否匹配、是否被处理，finally都会执行。</li></ul><p>—个try至少要有一个catch语句，或至少要有1个finally语句，finally不是用来处理异常的, 也不会捕获异常，是为了做一些清理工作，如流的关闭、数据库连接的关闭等。</p><h3 id="（2）抛出异常"><a href="#（2）抛出异常" class="headerlink" title="（2）抛出异常"></a>（2）抛出异常</h3><p>除用try语句处理异常外，还可以用throw, throws抛出异常。</p><p>执行throw语句的地方是一个异常抛出点，后面必须是一个异常对象，且必须写在函数中。</p><ul><li><ul><li>throw 语法：</li></ul></li></ul><p>      throw （异常对象）；</p><ul><li><ul><li>throws 语法：</li></ul></li></ul><p>[（修饰符）］（返回值类型）（方法名）（［参数列表］）［throws（异常类）］{……}</p><h3 id="（3）自定义异常"><a href="#（3）自定义异常" class="headerlink" title="（3）自定义异常"></a>（3）自定义异常</h3><p>  在应用程序的开发过程中，经常会自定义异常类，以避免使用try产生重复代码。自定义异常类 —般是通过扩展Exception类来实现的。这样的自定义异常属于检查异常（checked exception ）。如果要自定义非检查异常，则需要继承RuntimeException</p><h2 id="1-4-Spring-Boot默认的异常处理"><a href="#1-4-Spring-Boot默认的异常处理" class="headerlink" title="1.4.Spring Boot默认的异常处理"></a>1.4.Spring Boot默认的异常处理</h2><p> Spring Boot提供了一个默认处理异常的映射。在Spring Boot的Web项目中，尝试访问一 个不存在的 URL （<a href="https://localhost:8080/longzhiran">https://localhost:8080/every</a> ）,会得到 Spring Boot 中内置的异常处理， 如下提示：</p><p>This application has no explicit mapping for &#x2F;error, so you are seeing this as a fallback.</p><p>Sat May 18 22:49:20 CST 2019</p><p>There was an unexpected error （type&#x3D;Not Found, status&#x3D;404）</p><p>No message available</p><p>同样的地址，如果发送的请求带有 Content-Type-&gt;application&#x2F;json;charset&#x3D;UTF-8, 则返回的是JSON格式的错误结果,见以下输岀结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;rimestamp&quot;</span>: <span class="string">&quot;2019-05-18T14:47:46.722+0000&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;status&quot;</span>: <span class="number">404</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;error&quot;</span>: <span class="string">&quot;NotFound&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;No message available&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;path&quot;</span>: <span class="string">&quot;/longzhiran&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从上面结果可以看岀，Spring Boot会根据消费者发送的“Content-Type”来返回相应的异常内容，如果“Content-Type”是“application&#x2F;json”,则返回 JSON 文件；如果“Content-Type” 是”text&#x2F;html”,则返回HTML文件。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元注解与自定义注解- SpringBoot（10）</title>
      <link href="/2022/07/17/%E5%85%83%E6%B3%A8%E8%A7%A3%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3-%20SpringBoot%EF%BC%8810%EF%BC%89/"/>
      <url>/2022/07/17/%E5%85%83%E6%B3%A8%E8%A7%A3%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3-%20SpringBoot%EF%BC%8810%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-元注解"><a href="#1-元注解" class="headerlink" title="1.元注解"></a>1.元注解</h1><p>元注解就是定义注解的注解，是Java提供的用于定义注解的基本注解</p><h2 id="1-Target"><a href="#1-Target" class="headerlink" title="1.@Target"></a>1.@Target</h2><p>  该注解的作用是告诉Java将自定义的注解放在什么地方，比如类、方法、构造器、变量上等。 它的值是一个枚举类型，有如下属性值。</p><ul><li>ElementType.CONSTRUCTOR：用于描述构造器。</li><li>ElementType.FIELD：用于描述成员变量、对象、属性（包括enum实例）。</li><li>ElementType.LOCAL_VARIABLE:用于描述局部变量。</li><li>ElementType.METHOD：用于描述方法。</li><li>ElementType.PACKAGE:用于描述包。</li><li>ElementType.PARAMETER:用于描述参数。</li><li>ElementType.TYPE；用于描述类、接口（包括注解类型）或enum声明。</li></ul><h2 id="2-Retention"><a href="#2-Retention" class="headerlink" title="2.@Retention"></a>2.@Retention</h2><p>该注解用于说明自定义注解的生命周期，在注解中有三个生命周期.</p><ul><li>RetentionPolicy.RUNTIME：始终不会丢弃，运行期也保留该注解，可以使用反射机制读取该注解的信息。自定义的注解通常使用这种方式。</li><li>RetentionPolicy.CLASS：类加载时丢弃，默认使用这种方式。</li><li>RetentionPolicy.SOURCE：编译阶段丢弃，自定义注解在编译结束之后就不再有意义， 所以它们不会写入字节码。@Override @SuppressWarnings都属于这类注解。</li></ul><h2 id="3-Inherited"><a href="#3-Inherited" class="headerlink" title="3.@Inherited"></a>3.@Inherited</h2><p>该注解是一个标记注解，表明被标注的类型是可以被继承的。如果一个使用了@lnherited修饰 的Annotation类型被用于一个Class,则这个Annotation将被用于该Class的子类。</p><h2 id="4-Documented"><a href="#4-Documented" class="headerlink" title="4.@Documented"></a>4.@Documented</h2><p>该注解表示是否将注解信息添加在Java文档中。</p><h2 id="5-interface"><a href="#5-interface" class="headerlink" title="5.@interface"></a>5.@interface</h2><p>  该注解用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型(返回值类型只能是基本类型、Class、String、enum)。 可以通过default来声明参数的默认值。</p><h1 id="2-自定义注解"><a href="#2-自定义注解" class="headerlink" title="2.自定义注解"></a>2.自定义注解</h1><h2 id="1-创建自定义注解类"><a href="#1-创建自定义注解类" class="headerlink" title="1.创建自定义注解类"></a>1.创建自定义注解类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Document;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTestAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用@Target 标注作用范围。</li><li>使用@Retention注解标注生命周期。</li><li>使用@Documented将注解信息添加在Java文档中。</li></ul><h2 id="2-实现业务逻辑"><a href="#2-实现业务逻辑" class="headerlink" title="2.实现业务逻辑"></a>2.实现业务逻辑</h2><p>以AOP的方式实现业务逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.annotation.MyTestAnnotation;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.itheima.annotation.MyTestAnnotation)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myAnnotationPointcut</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before(&quot;myAnnotationPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">sign</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> sign.getMethod();</span><br><span class="line">        <span class="type">MyTestAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getAnnotation(MyTestAnnotation.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;MyTestAnnotation：&quot;</span>+annotation.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-使用自定义注解"><a href="#3-使用自定义注解" class="headerlink" title="3.使用自定义注解"></a>3.使用自定义注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyTestAnnotation(&quot;测试用&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Flux&lt;User&gt; <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面代码，输出如下结果:</p><p><code>MyTestAnnotation：测试用</code></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义Starter- SpringBoot（9）</title>
      <link href="/2022/07/17/%E8%87%AA%E5%AE%9A%E4%B9%89Starter-%20SpringBoot%EF%BC%889%EF%BC%89/"/>
      <url>/2022/07/17/%E8%87%AA%E5%AE%9A%E4%B9%89Starter-%20SpringBoot%EF%BC%889%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义Starter"><a href="#自定义Starter" class="headerlink" title="自定义Starter"></a>自定义Starter</h1><p>如果Spring Boot自带的入口类不能满足要求，则可以自定义Starter。自定义Starter的步骤 如下。</p><h2 id="1-引入必要的依赖"><a href="#1-引入必要的依赖" class="headerlink" title="1.引入必要的依赖"></a>1.引入必要的依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-自定义Properties类"><a href="#2-自定义Properties类" class="headerlink" title="2.自定义Properties类"></a>2.自定义Properties类</h2><p>在使用Spring官方的Starter时，可以在application.properties文件中配置参数，以覆盖默认值。在自定义Starter时，也可以根据需要来配置Properties类，以保存配置信息，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.mystarter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStarterProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String parameter;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getParameter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parameter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParameter</span><span class="params">(String parameter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parameter = parameter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-定义核心服务类"><a href="#3-定义核心服务类" class="headerlink" title="3.定义核心服务类"></a>3.定义核心服务类</h2><p>每个Starter都需要有自己的功能，所以需要定义服务类，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStarter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyStarterProperties myProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStarter</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStarter</span><span class="params">(MyStarterProperties myProperties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myProperties = myProperties;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;参数：&quot;</span>+myProperties.getParameter());</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> myProperties.getParameter();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-定义自动配置类"><a href="#4-定义自动配置类" class="headerlink" title="4.定义自动配置类"></a>4.定义自动配置类</h2><p>每个Starter —般至少有一个自动配置类，命名规则为“名字+AutoConfiguration”，如MyStarterServiceAutoConfiguration， 配置方法见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MyStarterProperties.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(MyStarter.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mystarter&quot;,value = &quot;enabled&quot;,matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStartServiceConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MyStarterProperties</span> <span class="variable">myStarterProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyStarterProperties</span>();</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(MyStarter.class)</span></span><br><span class="line">    <span class="keyword">public</span> MyStarter <span class="title function_">myStarterService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyStarter</span> <span class="variable">myStarter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyStarter</span>(myStarterProperties);</span><br><span class="line">        <span class="keyword">return</span> myStarter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在resources文件夹下新建目录META-INF,在目录中新建spring.factories文件， 并且在spring.factories中配置AutoConfiguration,加入以下代码： </p><p><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</code><br><code>  com.itheima.properties.MyStartServiceConfiguration</code></p><p>注解详解：</p><p>  使用</p><h3 id="ConfigurationProperties："><a href="#ConfigurationProperties：" class="headerlink" title="ConfigurationProperties："></a>ConfigurationProperties：</h3><p>  外部化配置的注释。如果您想绑定和验证一些外部属性（例如，来自 .properties 文件），请将其添加到类定义或@Configuration类中的@Bean方法中。绑定可以通过在带注释的类上调用 setter 来执行，或者，如果正在使用@ConstructorBinding ，则通过绑定到构造函数参数来执行。请注意，与@Value相反，SpEL 表达式不会被评估，因为属性值是外部化的。</p><p>  源码解释：</p><p>表示一个类声明了一个或多个@Bean方法，并且可以被 Spring 容器处理以在运行时为这些 bean 生成 bean 定义和服务请求，例如：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// instantiate, configure and return bean ...  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>引导@Configuration类<br>通过AnnotationConfigApplicationContext<br>@Configuration类通常使用AnnotationConfigApplicationContext或其支持 Web 的变体AnnotationConfigWebApplicationContext进行引导。前者的简单示例如下：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();  </span><br><span class="line">ctx.register(AppConfig.class);  </span><br><span class="line">ctx.refresh();  </span><br><span class="line"><span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> ctx.getBean(MyBean.class);  </span><br><span class="line"><span class="comment">// use myBean ...  </span></span><br></pre></td></tr></table></figure><p>有关详细信息，请参阅AnnotationConfigApplicationContext javadocs，有关Servlet容器中的 Web 配置说明，请参阅AnnotationConfigWebApplicationContext 。<br>通过 Spring <beans> XML<br>作为直接针对AnnotationConfigApplicationContext注册@Configuration类的替代方法， @Configuration类可以在 Spring XML 文件中声明为普通的<bean>定义：<br>   <beans><br>      <a href="context:annotation-config/">context:annotation-config/</a><br>      <bean class="com.acme.AppConfig"/><br>   </beans>  </p><p>在上面的示例中，需要<a href="context:annotation-config/">context:annotation-config/</a>以启用ConfigurationClassPostProcessor和其他有助于处理@Configuration类的注释相关的后处理器。<br>通过组件扫描<br>@Configuration使用@Component进行元注释，因此@Configuration类是组件扫描的候选对象（通常使用 Spring XML 的<a href="context:component-scan/">context:component-scan/</a>元素），因此也可以像任何常规@Component一样利用@Autowired &#x2F; @Inject @Component 。特别是，如果存在单个构造函数，则自动装配语义将透明地应用于该构造函数：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SomeBean someBean;  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AppConfig</span><span class="params">(SomeBean someBean)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.someBean = someBean;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// @Bean definition using &quot;SomeBean&quot;  </span></span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>@Configuration类不仅可以使用组件扫描进行引导，还可以使用@ComponentScan注解配置组件扫描：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.acme.app.services&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;  </span><br><span class="line">    <span class="comment">// various @Bean definitions ...  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>有关详细信息，请参阅@ComponentScan javadocs。<br>使用外化值<br>使用Environment API<br>可以通过将 Spring org.springframework.core.env.Environment注入@Configuration类来查找外部化的值——例如，使用@Autowired注释：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span> Environment env;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();  </span><br><span class="line">        myBean.setName(env.getProperty(<span class="string">&quot;bean.name&quot;</span>));  </span><br><span class="line">        <span class="keyword">return</span> myBean;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>通过Environment解析的属性驻留在一个或多个“属性源”对象中， @Configuration类可以使用@PropertySource注释将属性源贡献给Environment对象：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/com/acme/app.properties&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Inject</span> Environment env;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>(env.getProperty(<span class="string">&quot;bean.name&quot;</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>有关更多详细信息，请参阅Environment和@PropertySource javadocs。<br>使用@Value注释<br>可以使用@Value注释将外部化的值注入到@Configuration类中：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/com/acme/app.properties&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;bean.name&#125;&quot;)</span> String beanName;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>(beanName);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>这种方法通常与 Spring 的PropertySourcesPlaceholderConfigurer结合使用，可以通过<a href="context:property-placeholder/">context:property-placeholder/</a>在 XML 配置中自动启用，或者通过专用的static @Bean方法在@Configuration类中显式启用（参见“关于 BeanFactoryPostProcessor-returning @Bean方法”的@Bean的 javadocs 的详细信息）。但是请注意，通常仅当您需要自定义配置（例如占位符语法等）时才需要通过static @Bean方法显式注册PropertySourcesPlaceholderConfigurer 。特别是，如果没有 bean 后处理器（例如PropertySourcesPlaceholderConfigurer ）已注册作为ApplicationContext的嵌入式值解析器，Spring 将注册一个默认的嵌入式值解析器，它根据在Environment中注册的属性源解析占位符。请参阅下面有关使用@ImportResource使用 Spring XML 组合@Configuration类的部分；参见@Value javadocs；有关使用BeanFactoryPostProcessor类型（例如PropertySourcesPlaceholderConfigurer ）的详细信息，请参阅@Bean javadocs。<br>组合@Configuration类<br>使用@Import注释<br>@Configuration类可以使用@Import注解组成，类似于<import>在 Spring XML 中的工作方式。因为@Configuration对象在容器中作为 Spring bean 进行管理，所以可以注入导入的配置——例如，通过构造函数注入：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConfig</span> &#123;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// instantiate, configure and return DataSource  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@Import(DatabaseConfig.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DatabaseConfig dataConfig;  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AppConfig</span><span class="params">(DatabaseConfig dataConfig)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.dataConfig = dataConfig;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// reference the dataSource() bean method  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>(dataConfig.dataSource());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>现在AppConfig和导入的DatabaseConfig都可以通过仅针对 Spring 上下文注册AppConfig来引导：<br>   new AnnotationConfigApplicationContext(AppConfig.class);<br>使用@Profile注释<br>@Configuration类可以用@Profile注释标记，以表明只有在给定的配置文件或配置文件处于活动状态时才应处理它们：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Profile(&quot;development&quot;)</span>  </span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmbeddedDatabaseConfig</span> &#123;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// instantiate, configure and return embedded DataSource  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span>  </span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductionDatabaseConfig</span> &#123;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// instantiate, configure and return production DataSource  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>或者，您也可以在@Bean方法级别声明配置文件条件 - 例如，对于同一配置类中的替代 bean 变体：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProfileDatabaseConfig</span> &#123;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span>  </span><br><span class="line">    <span class="meta">@Profile(&quot;development&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">embeddedDatabase</span><span class="params">()</span> &#123; ... &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span>  </span><br><span class="line">    <span class="meta">@Profile(&quot;production&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">productionDatabase</span><span class="params">()</span> &#123; ... &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>有关更多详细信息，请参阅@Profile和org.springframework.core.env.Environment javadocs。<br>使用@ImportResource注解的 Spring XML<br>如上所述， @Configuration类可以在 Spring XML 文件中声明为常规 Spring <bean>定义。也可以使用@ImportResource注释将 Spring XML 配置文件导入@Configuration类。可以注入从 XML 导入的 Bean 定义——例如，使用@Inject注解：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@ImportResource(&quot;classpath:/com/acme/database-config.xml&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Inject</span> DataSource dataSource; <span class="comment">// from XML  </span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// inject the XML-defined dataSource bean  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>(<span class="built_in">this</span>.dataSource);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>使用嵌套@Configuration类<br>@Configuration类可以相互嵌套，如下所示：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Inject</span> DataSource dataSource;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>(dataSource);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Configuration</span>  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DatabaseConfig</span> &#123;  </span><br><span class="line">        <span class="meta">@Bean</span>  </span><br><span class="line">        DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>().build();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>当引导这样的安排时，只需要针对应用程序上下文注册AppConfig 。由于是嵌套的@Configuration类， DatabaseConfig将自动注册。当AppConfig和DatabaseConfig之间的关系已经隐式明确时，这避免了使用@Import注释的需要。<br>还要注意，嵌套的@Configuration类可以与@Profile注释一起使用，从而为封闭的@Configuration类提供同一个bean 的两个选项。<br>配置延迟初始化<br>默认情况下， @Bean方法将在容器引导时急切地实例化。为了避免这种情况，@ @Lazy @Configuration一起使用，以指示在类中声明的所有@Bean方法默认情况下都是惰性初始化的。请注意， @Lazy也可以用于单个@Bean方法。<br>测试对@Configuration类的支持<br>spring-test模块中可用的 Spring TestContext 框架提供了@ContextConfiguration注解，它可以接受一组组件类引用——通常是@Configuration或@Component类。  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span>  </span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;AppConfig.class, DatabaseConfig.class&#125;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTests</span> &#123;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span> MyBean myBean;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span> DataSource dataSource;  </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// assertions against myBean ...  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>有关详细信息，请参阅TestContext 框架 参考文档。<br>使用@Enable注解启用内置 Spring 功能<br>Spring 特性，如异步方法执行、计划任务执行、注释驱动的事务管理，甚至 Spring MVC 都可以使用它们各自的“ @Enable ”注释从@Configuration类中启用和配置。有关详细信息，请参阅@EnableAsync 、 @EnableScheduling 、 @EnableTransactionManagement 、 @EnableAspectJAutoProxy和@EnableWebMvc 。<br>创作@Configuration类时的约束<br>配置类必须作为类提供（即不是作为从工厂方法返回的实例），允许通过生成的子类进行运行时增强。<br>配置类必须是非最终的（允许在运行时使用子类），除非proxyBeanMethods标志设置为false ，在这种情况下不需要运行时生成的子类。<br>配置类必须是非本地的（即不能在方法中声明）。<br>任何嵌套的配置类都必须声明为static 。<br>@Bean方法可能不会反过来创建进一步的配置类（任何此类实例都将被视为常规 bean，它们的配置注释仍然未被检测到）。</p><h3 id="EnableConfigurationProperties："><a href="#EnableConfigurationProperties：" class="headerlink" title="EnableConfigurationProperties："></a>EnableConfigurationProperties：</h3><p>  启用对@ConfigurationProperties注释 bean 的支持。 @ConfigurationProperties bean 可以以标准方式注册（例如使用@Bean方法），或者为了方便起见，可以直接在此注释上指定。</p><h3 id="ConditionalOnClass："><a href="#ConditionalOnClass：" class="headerlink" title="ConditionalOnClass："></a>ConditionalOnClass：</h3><p>  @Conditional仅在指定的类在类路径上时匹配。可以在@Configuration类上安全地指定value() ，因为在加载类之前使用 ASM 解析注释元数据。放置在@Bean方法上时需要格外小心，考虑将条件隔离在单独的Configuration类中，特别是如果方法的返回类型与target of the condition匹配。</p><h3 id="ConditionalOnProperty："><a href="#ConditionalOnProperty：" class="headerlink" title="ConditionalOnProperty："></a>ConditionalOnProperty：</h3><p>  @Conditional检查指定属性是否具有特定值。默认情况下，属性必须存在于Environment中并且不等于false 。 havingValue()和matchIfMissing()属性允许进一步自定义。<br>havingValue属性可用于指定属性应具有的值。</p><h2 id="5-打包发布"><a href="#5-打包发布" class="headerlink" title="5.打包发布"></a>5.打包发布</h2><p>在完成上面的配置后，打包生成JAR文件，然后就可以像使用官方Starter那样使用了。如果不发布到Maven中心仓库，则需要用户手动添加依赖。</p><h2 id="6-创建用于测试Starter的项目"><a href="#6-创建用于测试Starter的项目" class="headerlink" title="6.创建用于测试Starter的项目"></a>6.创建用于测试Starter的项目</h2><p>在创建新顼目后，如果要添加自定义的Starter依赖，则不能用添加官Starter的方法，因为 此时还未将Starter发布到Maven中心仓库。只能通过开发工具导入此依赖JAR文件（在IDEA 中，通过单击菜单栏的 FILE—&gt;ProjectStructure—&gt;Modules—&gt;Dependencies，然后单击+号，选择  JARs or directories……选项添加依赖）。然后，配置 application.properties文件，加入以下参数：</p><p>spring.mystarter.parameter&#x3D;buretuzi</p><h2 id="7-使用starter"><a href="#7-使用starter" class="headerlink" title="7.使用starter"></a>7.使用starter</h2><p>在需要使用的地方注入依赖即可，具体使用见以下代码：<br><code>@Autowired</code><br><code>private MyStarter myStarterService;</code><br><code>@Test</code><br><code>public void hello()&#123;</code><br><code>    System.out.println(myStarterService.print());</code><br><code>&#125;</code></p><p>正规的Starter是一个独立的工程，可以在Maven中的新仓库注册发布，以便幵发人员使用。</p><p>自定义Starter包括以下几个方面的内容。</p><ul><li>自动配置文件：根据classpath是否存在指定的类来决定是否要执行该功能的自动配置。</li><li>factories：指导Spring Boot找到指定的自动配置文件。</li><li>endpoint：包含对服务的描述、界面、交互（业务信息的查询）。</li><li>health indicator：该Starter提供的服务的健康指标。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过滤器与监听器- SpringBoot（8）</title>
      <link href="/2022/07/17/%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8-%20SpringBoot%EF%BC%888%EF%BC%89/"/>
      <url>/2022/07/17/%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8-%20SpringBoot%EF%BC%888%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-过滤器"><a href="#1-过滤器" class="headerlink" title="1.过滤器"></a>1.过滤器</h1><h2 id="1-为什么要使用过滤器"><a href="#1-为什么要使用过滤器" class="headerlink" title="1.为什么要使用过滤器"></a>1.为什么要使用过滤器</h2><p>  在Web开发中，常常会有这样的需求：在所有接口中去除用户输入的非法字符，以防止引起业务异常。要实现这个功能，可以有很多方法，如：</p><ul><li>在前端参数传入时进行校验，先过滤掉非法字符，然后，返回用户界面提示用户重新输入。</li><li>后端接收前端没有过滤的数据，然后过滤非法字符。</li><li>利用Filter处理顼目中所有非法字符。</li></ul><p>  很明显，前两种实现方法会存在重复代码，因为每个前端页面或后端都需要处理，这样会导致 代码极难维护。如果用过滤器来实现，则只需要用过滤器利所有接口进行过滤处理。这样非常方便, 同时不会岀现冗余代码。</p><h2 id="2-使用Filter的步骤"><a href="#2-使用Filter的步骤" class="headerlink" title="2.使用Filter的步骤"></a>2.使用Filter的步骤</h2><p>(1)新建类，实现Filter抽象类。</p><p>(2)重写 init、doFilter、destroy 方法。</p><p>(3)在 Spring Boot 入口中添加注解@ServletComponentScan,以注册 Filter</p><p>   详细步骤如下：</p><h3 id="1-编写过滤器类。"><a href="#1-编写过滤器类。" class="headerlink" title="(1)编写过滤器类。"></a>(1)编写过滤器类。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="comment">//定义此过滤器在过滤器链中的位置，序号越小越先被执行</span></span><br><span class="line"><span class="meta">@WebFilter(filterName = &quot;filterdemo&quot;,urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="comment">//URL过滤配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">//init方法，将在服务器启动时被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//request 请求处理逻辑</span></span><br><span class="line">        <span class="comment">//response 请求封装逻辑</span></span><br><span class="line">        <span class="comment">//chain重新写回request和response</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//重写detory逻辑，该逻辑将在服务器关闭时被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）在Spring-Boot入口类中注册Filter"><a href="#（2）在Spring-Boot入口类中注册Filter" class="headerlink" title="（2）在Spring Boot入口类中注册Filter."></a>（2）在Spring Boot入口类中注册Filter.</h3><p>    要在 Spring Boot 入口类中注册 Filter,只需要添加注解@ServletComponentScan </p><h1 id="2-监听器"><a href="#2-监听器" class="headerlink" title="2.监听器"></a>2.监听器</h1><p>  监听器(Listener)用于监听Web应用程序中某些対象或信息的创建、销毁、增加、修改、删除等动作，然后做出相应的响应处理。当対象的状态发生变化时，服务器自动调用监听器的方法，监听器常用于统计在线人数、在线用户、系统加载时的信息初始化等。</p><p>Servlet中的监听器分为以下3种类型。</p><ol><li>监听ServletContext、Requests、Session作用域的创建和销毁</li></ol><ul><li>ServletContextListener:监听 ServeltContext。</li><li>httpsSessionListener：监听新的 Session 创建事件。</li><li>ServletRequestListener：监听 ServletRequest 的初始化和销毁。</li></ul><ol start="2"><li>监听ServletContext、Request、Session作用域中属性的变化(增加、修改、删除)</li></ol><ul><li>ServletContextAttributeListener:监听 Servlet 上下文参数的变化。</li><li>httpsSessionAttributeListener：监听 httpsSession 参数的变化。</li><li>ServletRequestAttnbuteListener:监听 Se「vletRequest 参数的变化。</li></ul><ol start="3"><li>监听httpsSession中对象状态的改变(被绑定、解除绑定、钝化、活化)</li></ol><ul><li>HltpSessionBindingListener:监听 httpsSession,并绑定及解除绑定。</li><li>httpsSessionActivationListener:监听钝化和活动的 httpsSession 状态改变。</li></ul><h2 id="实例：实现监听器"><a href="#实例：实现监听器" class="headerlink" title="实例：实现监听器"></a>实例：实现监听器</h2><h3 id="1-实现监听器"><a href="#1-实现监听器" class="headerlink" title="1.实现监听器"></a>1.实现监听器</h3><p>  通过注解@WebListener标注此类是监听器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListenerDemo</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ServletContextInitialized&quot;</span>);</span><br><span class="line">        System.out.println(sce.getServletContext().getServerInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ServletContextDestroyed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-开启监听器Bean扫描"><a href="#2-开启监听器Bean扫描" class="headerlink" title="2.开启监听器Bean扫描"></a>2.开启监听器Bean扫描</h3><p>  在入口类上，添加注解@ServletComponentScan 启动项目后，在控制台中会输岀以下信息：</p><p><code>    ServletContextInitialized</code><br><code>    Apache Tomcat/9.0.41</code></p><p>  如果不停止，在端口被占用的情况下重新启动，则显示以下信息：</p><p><code>   Stopping service [Tomcat]</code></p><p><code>   ServletContextDestroyed</code></p><h1 id="3-自动配置"><a href="#3-自动配置" class="headerlink" title="3.自动配置"></a>3.自动配置</h1><h2 id="1-自定义入口类"><a href="#1-自定义入口类" class="headerlink" title="1.自定义入口类"></a>1.自定义入口类</h2><p>  入口类默认提供了注解@SpringBootApplication,它用于标注Spring Boot项目的入口。这 个注解被@Configuration、 @EnableAutoConfiguration、@ComponentScan 三个注解所修饰， 即Spring Boot提供了统一的注解来替代这三个注解。</p><p>用这三个注解替代注解©SpringBootApplication也是合法的，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Springboot05MybatisApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Springboot05MybatisApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面的“run”方法实例化了一个“SpringApplication”对象。执行run方法，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Static helper that can be used to run a &#123;<span class="doctag">@link</span> SpringApplication&#125; from the</span></span><br><span class="line"><span class="comment"> * specified source using default settings.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> primarySource the primary source to load</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果把入口类的“run”方法改成下方的代码，则效果也是一样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Springboot05MybatisApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SpringApplication</span> <span class="variable">application</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(SpringBootApplication.class);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  解释：</p><p><code>public SpringApplication(Class&lt;?&gt;... primarySources) &#123;</code><br><code>    this(null, primarySources);</code><br><code>&#125;</code></p><p>   创建一个新的SpringApplication实例。应用程序上下文将从指定的主要来源加载 bean（有关详细信息，请参阅class-level文档。可以在调用run(String…)之前自定义实例。</p><p>   如果需要创建多层次的”Applicationcontext”,则可以使用SpringApplicationBuilder将 多个方法调用串联起来，然后通过“parent()和child()”来创建，见以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.scene.Parent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Springboot05MybatisApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>()</span><br><span class="line">                .sources(Parent.class)</span><br><span class="line">                .child(Springboot05MybatisApplication.class)</span><br><span class="line">                .run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>public SpringApplicationBuilder(Class&lt;?&gt;... sources) &#123;</code><br><code>    this.application = createSpringApplication(sources);</code><br><code>&#125;</code></p><p>SpringApplicationBuilder：</p><p>SpringApplication和ApplicationContext实例的构建器，具有方便的流畅 API 和上下文层次结构支持。上下文层次结构的简单示例：<br>   new SpringApplicationBuilder(ParentConfig.class).child(ChildConfig.class).run(args);  </p><p>另一个常见用例是设置活动配置文件和默认属性以设置应用程序的环境：<br>   new SpringApplicationBuilder(Application.class).profiles(“server”)<br>           .properties(“transport&#x3D;local”).run(args);  </p><p>如果您的需求更简单，请考虑使用 SpringApplication 中的静态便捷方法。</p><h2 id="2-自动配置的原理"><a href="#2-自动配置的原理" class="headerlink" title="2.自动配置的原理"></a>2.自动配置的原理</h2><p>在入口类中，默认使用了注解@EnableAutoConfiguration，Spring Boot也正是通过它来完成自动配置的。</p><p>注解@EnableAutoConfiguration借助注解@Import,将所有符合自动配置条件的Bean都加载到loC容器中，其关键代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Environment property that can be used to override when auto-configuration is</span></span><br><span class="line"><span class="comment"> * enabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment"> * applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可以看到，在 EnableAutoConfiguration 类中导入了 “AutoConfigurationlmport- Selector.class\ Spring Boot借助它将所有符合条件的©Configuration配置都加载到loC容 器中。EnableAutoConfiguration 类还会导入 Sp「ingFacto「iesLoader 类。进入 SpringFactories- Loader类中可以看到，其关键代码如下：</p><p>public final class SpringFactoriesLoader {</p><p>  public static final String FACTORIES_RESOURCE_LOCATION &#x3D; “META-INF&#x2F;spring.factories”;</p><p>  private static final Log logger &#x3D; LogFactory.getLog(SpringFactoriesLoader.class);</p><p>}&#x2F;&#x2F;省略</p><p>从上述代码可以看到，SpringFactoriesLoader从classpath中寻找所有的META-INF&#x2F;spring.factories 配置文件。</p><p><img src="https://image.buretuzi.online/blog/article/springboot/%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8-%20SpringBoot%EF%BC%888%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><p>  通过上面的SpringFactoriesLoader代码和原理图可以看出Spring Boot自动配置原理 （EnableAutoConfiguration 类）的工作原理：它借助 AutoConfiguralionlmportSelector,调用 SpringFactoriesLoader 的 loadFactoryNames 方法，从 classpath 中寻找所有的 META-INF&#x2F;spring.factories配置文件（spring.factories配置了自动装配的类）；然后，再借助 AutoConfigurationlmportSelector,将所有符合条件的@Configuration 配置都加载到loC容器中。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识Ioc容器和Servlet容器-SpringBoot（7）</title>
      <link href="/2022/07/16/%E8%AE%A4%E8%AF%86Ioc%E5%AE%B9%E5%99%A8%E5%92%8CServlet%E5%AE%B9%E5%99%A8-SpringBoot%EF%BC%887%EF%BC%89/"/>
      <url>/2022/07/16/%E8%AE%A4%E8%AF%86Ioc%E5%AE%B9%E5%99%A8%E5%92%8CServlet%E5%AE%B9%E5%99%A8-SpringBoot%EF%BC%887%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="认识Ioc容器和Servlet容器"><a href="#认识Ioc容器和Servlet容器" class="headerlink" title="认识Ioc容器和Servlet容器"></a>认识Ioc容器和Servlet容器</h1><h2 id="1-介绍loC容器"><a href="#1-介绍loC容器" class="headerlink" title="1.介绍loC容器"></a>1.介绍loC容器</h2><p>loC (Inversion of Control)容器，是面向对象编程中的一种设计原则，意为控制反转(也被 称为’控制反向”或”控制倒置”)。它将程序中创建对象的控制权交给Spring框架来管理，以便降低计算机代码之间的耦合度。</p><p>控制反转的实质是获得依赖对象的过程被反转了。这个过程由自身管理变为由loC容器主动注入。这正是loC实现的方式之一：依赖注入(dependency injection, DI),由loC容器在运行期间动态地将某种依赖关系注入对象之中。</p><p>在传统编程方式中，要实现某种功能一般都需要几个对象相互作用。在主对象中要保存其他类型对象的引用，以便在主对象中实例化对象，然后通过调用这些引用的方法来完成任务，其运行方式如图</p><p><img src="https://image.buretuzi.online/blog/article/springboot/%E8%AE%A4%E8%AF%86Ioc%E5%AE%B9%E5%99%A8%E5%92%8CServlet%E5%AE%B9%E5%99%A8-SpringBoot%EF%BC%887%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><p>而IoC容器是在主对象中设置Setter方法，通过调用Setter方法或构造方法传入所需引用(即 依赖注入)，如图所示。</p><p><img src="https://image.buretuzi.online/blog/article/springboot/%E8%AE%A4%E8%AF%86Ioc%E5%AE%B9%E5%99%A8%E5%92%8CServlet%E5%AE%B9%E5%99%A8-SpringBoot%EF%BC%887%EF%BC%89%EF%BC%882%EF%BC%89.png"></p><p>要使用某个对象，只需要从loC容器中获取需要使用的对象，不需要关心对象的创建过程，即 把创建对象的控制权反转给了 Spring框架。</p><h2 id="2-loC的实现方法"><a href="#2-loC的实现方法" class="headerlink" title="2.loC的实现方法"></a>2.loC的实现方法</h2><p>IoC的实现方法主要有两种——依赖注入与依赖查找。</p><h3 id="1-依赖注入。"><a href="#1-依赖注入。" class="headerlink" title="(1 )依赖注入。"></a>(1 )依赖注入。</h3><p>loC容器通过类型或名称等信息将不同对象注入不同属性中。组件不做定位查询，只提供普通 的Java方法让容器去决定依赖关系。这是最流行的loC方法。依赖注入主要有以下几种方式-</p><ul><li>设值注入(setter injection ):让loC容器调用注入所依赖类型的对象。</li><li>接口注入(interface injection)：实现特定接口，以供loC容器注入所依赖类型的对象。</li><li>构造注入(constructor injection )：实现特定参数的构造函数，在创建对象时让loC容器 注入所依赖类型的对象。</li><li>基于注解：通过Java的注解机制让loC容器注入所依赖类型的对象，例如，使用 @Autowired</li></ul><p>loC是通过第三方容器来管理并维护这些祓依赖对象的，应用程序只需要接收并使用loC容器 注入的对象。</p><h3 id="2）依赖查找。"><a href="#2）依赖查找。" class="headerlink" title="(2）依赖查找。"></a>(2）依赖查找。</h3><p>在传统实现中，需要用户使用API来管理依赖的创建、查找资源和组装对象。这会对程序有侵 入性。</p><p>依赖查找则通过调用容器提供的回调接口和上下文环境来获取对象，在获取时需要提供相关的 配置文件路径、key等信息来确定获取对象的状态。依赖查找通常有两个方法 —— 依赖拖拽（DP ） 和上下文化依赖查找（CDL ）。</p><h2 id="3-认识Servlet容器"><a href="#3-认识Servlet容器" class="headerlink" title="3.认识Servlet容器"></a>3.认识Servlet容器</h2><p>Servlet是在javax.serlvet包中定义的一个接口。在开发Spring Boot应用程序时，使用 Controller基本能解决大部分的功能需求。但有时也需要使用Servlet,比如实现拦截和监听功能。</p><p>Spring Boot的核心控制器DispatcherServlet会处理所有的请求。如果自定义Servlet,则需 要进行注册，以便DispatcherServlet核心控制器知道它的作用，以及处理请求url-pattern。</p><h3 id="实例14：用loC管理Bean"><a href="#实例14：用loC管理Bean" class="headerlink" title="实例14：用loC管理Bean"></a>实例14：用loC管理Bean</h3><h4 id="1-创建一个Bean"><a href="#1-创建一个Bean" class="headerlink" title="1.创建一个Bean"></a>1.创建一个Bean</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-编写User的配置类"><a href="#2-编写User的配置类" class="headerlink" title="2.编写User的配置类"></a>2.编写User的配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;user1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">55</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;Joe&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">65</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Configuration：用于标注配置类，让Spring来加载该类配置作为Bean的载体。在运行 时，将为这些Bean生成BeanDefinition和服务请求。</li><li>@Bean：产生一个Bean,并交给Spring管理。目的是封装用户、数据库中的数据，一般 有 Setter、Getter 方法</li></ul><h4 id="3-编写测试类"><a href="#3-编写测试类" class="headerlink" title="3.编写测试类"></a>3.编写测试类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IocTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testIoc</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) applicationContext.getBean(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@SpringBootTest： Spring Boot用于测试的注解，可指定入口类或测试环境等。</li><li>@RunWith(SpringRunner.class):让测试运行于 Spring 测试环境。</li><li>@Test：一个测试方法。</li><li>Applicationcontext：获取Spring容器中己初始化的Bean,这里是运行testloC方法，在控制台输出以下结果：</li></ul><p>  User(id&#x3D;55, name&#x3D;Joe, age&#x3D;65)</p><h3 id="实例：用Servlet处理请求"><a href="#实例：用Servlet处理请求" class="headerlink" title="实例：用Servlet处理请求"></a>实例：用Servlet处理请求</h3><p>  用Servlet处理请求，可以直接通过注解@WebServlet(urlPattem, descript)注册Servlet, 然后在入口类中添加注解@ServletComponentScan,以扫描该注解指定包下的所有Servlet。</p><h4 id="1-注册Servlet类"><a href="#1-注册Servlet类" class="headerlink" title="1.注册Servlet类"></a>1.注册Servlet类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.https.httpsServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.https.httpsServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.https.httpsServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/servlet/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo</span> <span class="keyword">extends</span> <span class="title class_">httpsServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(httpsServletRequest req, httpsServletResponse resp)</span><span class="keyword">throws</span> ServletException, IOException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DoGet&quot;</span>);</span><br><span class="line">        resp.getWriter().print(<span class="string">&quot;ServletTest&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@WebServlet(urlPatterns &#x3D; “&#x2F;servlet&#x2F;*“)：属性 urlPatterns 指定 WebServlet 的作用范围，这里代表servlet下的所有子路径。</p><p>doGet：父类httpsServlet的doGet方法是空的，没有实现任何代码，子类需要重写此方法。</p><h4 id="2-开启Servlet支持"><a href="#2-开启Servlet支持" class="headerlink" title="2.开启Servlet支持"></a>2.开启Servlet支持</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Springboot05MybatisApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Springboot05MybatisApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ComponentScan:组件扫描、可自动发现和装配一些Bean,并根据定义的扫描路径把 符合扫描规则的类装配到Spring容器中。</p><p>@SpringBootAppfication:入口类 Application 的启动注解。</p><p>在运行程序后，使用GET方法访问<a href="https://localhost:8080/ServletDemo02/*,,1%e4%bc%9a%e8%bf%94%e5%9b%9e%e9%87%8d%e4%b8%8e">https://localhost:8080/servlet/aoptest</a> 会返回重写doGET方法的值：</p><p>ServletTest</p><p>同时，控制台会输出doGet里定义的值：</p><p>DoGet</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向切面编程-SpringBoot（6）</title>
      <link href="/2022/07/16/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-SpringBoot%EF%BC%886%EF%BC%89/"/>
      <url>/2022/07/16/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-SpringBoot%EF%BC%886%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="面向切面编程"><a href="#面向切面编程" class="headerlink" title="面向切面编程"></a>面向切面编程</h1><h2 id="1-什么是AOP"><a href="#1-什么是AOP" class="headerlink" title="1.什么是AOP"></a>1.什么是AOP</h2><p>AOP (Aspect Oriented Program,面向切面编程)把业务功能分为核心、非核心两部分。</p><ul><li>核心业务功能：用户登录、增加数据、删除数据。</li><li>非核心业务功能：性能统计、日志、事务管理。</li></ul><p>在Spring的面向切面编程(AOP)思想里，非核心业务功能被定义为切面。核心业务功能和切面功能先被分别进行独立开发，然后把切面功能和核心业务功能“编织”在一起，这就是AOP</p><p>  AOP将那 些与业务无关，却为业务模块所共同调用的逻辑封装起来，以便减少系统的重复代码，降低模块间的耦合度，利于未来的拓展和维护。这正是AOP的目的，它是Spring最为重要的功能之一，被广泛使用。</p><h2 id="2-AOP中的概念"><a href="#2-AOP中的概念" class="headerlink" title="2.AOP中的概念"></a>2.AOP中的概念</h2><ul><li>切入点(pointcut):在哪些类、哪些方法上切入</li><li>通知(advice)：在方法前、方法后、方法前后做什么</li><li>切面（aspect）：切面&#x3D;切入点+通知。即在什么时机、什么地方、做什么</li><li>织入（weaving）：把切面加入对象，并创建出代理对象的过程</li><li>环绕通知：AOP中最强大、灵活的通知，它集成了前置和后置通知，保留了连接点原有的方法</li></ul><h3 id="实例：用AOP方式管理日志"><a href="#实例：用AOP方式管理日志" class="headerlink" title="实例：用AOP方式管理日志"></a>实例：用AOP方式管理日志</h3><h4 id="1-编写AOP注解日志类"><a href="#1-编写AOP注解日志类" class="headerlink" title="1.编写AOP注解日志类"></a>1.编写AOP注解日志类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.https.httpsServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="comment">//使之成为切面类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//把切面类加入Ioc容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopLog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line">    ThreadLocal&lt;Long&gt; startTime = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Long&gt;();</span><br><span class="line">    <span class="comment">//线程局部变量，用于解决多线程中相同变量的访问冲突问题</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * com.itheima.controller.AopLogController.avoid())&quot;)</span></span><br><span class="line">    <span class="comment">//定义切点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aopWebLog</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;切点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before(&quot;aopWebLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        startTime.set(System.currentTimeMillis());</span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="comment">//接收到请求，记录请求内容</span></span><br><span class="line">        <span class="type">httpsServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line">        logger.info(<span class="string">&quot;URL: &quot;</span> + request.getRequestURI().toString());</span><br><span class="line">        logger.info(<span class="string">&quot;https方法：&quot;</span>+request.getMethod());</span><br><span class="line">        logger.info(<span class="string">&quot;IP方法：&quot;</span>+request.getRemoteAddr());</span><br><span class="line">        logger.info(<span class="string">&quot;类的方法：&quot;</span>+joinPoint.getSignature().getDeclaringTypeName()+<span class="string">&quot;.&quot;</span>+joinPoint.getSignature().getName());</span><br><span class="line">        logger.info(<span class="string">&quot;参数：&quot;</span>+request.getQueryString());</span><br><span class="line">        <span class="comment">//记录下请求内容</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;aopWebLog()&quot;,returning = &quot;retObject&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterReturning</span><span class="params">(Object retObject)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;应答值：&quot;</span>+retObject);</span><br><span class="line">        logger.info(<span class="string">&quot;费时：&quot;</span>+(System.currentTimeMillis()-startTime.get()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing(pointcut = &quot;aopWebLog()&quot;,throwing = &quot;ex&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAfterThrowingLogger</span><span class="params">(JoinPoint joinPoint,Exception ex)</span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;执行：&quot;</span>+<span class="string">&quot;异常：&quot;</span>,ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解读：</p><h5 id="Pointcut注解："><a href="#Pointcut注解：" class="headerlink" title="@Pointcut注解："></a>@Pointcut注解：</h5><ol><li><strong>execution：一般用于指定方法的执行，用的最多。</strong></li><li>within：指定某些类型的全部方法执行，也可用来指定一个包。</li><li>this：Spring Aop是基于动态代理的，生成的bean也是一个代理对象，this就是这个代理对象，当这个对象可以转换为指定的类型时，对应的切入点就是它了，Spring Aop将生效。</li><li>target：当被代理的对象可以转换为指定的类型时，对应的切入点就是它了，Spring Aop将生效。</li><li>args：当执行的方法的参数是指定类型时生效。</li><li>@target：当代理的目标对象上拥有指定的注解时生效。</li><li>@args：当执行的方法参数类型上拥有指定的注解时生效。</li><li>@within：与@target类似，看官方文档和网上的说法都是@within只需要目标对象的类或者父类上有指定的注解，则@within会生效，而@target则是必须是目标对象的类上有指定的注解。而根据笔者的测试这两者都是只要目标类或父类上有指定的注解即可。</li><li>@annotation：当执行的方法上拥有指定的注解时生效。</li><li>reference pointcut：(经常使用)表示引用其他命名切入点，只有@ApectJ风格支持，Schema风格不支持</li><li>bean：当调用的方法是指定的bean的方法时生效。(Spring AOP自己扩展支持的)</li></ol><p>  Pointcut定义时，还可以使用&amp;&amp;、||、! 这三个运算。进行逻辑运算。可以把各种条件组合起来使用</p><h5 id="ThreadLocal类："><a href="#ThreadLocal类：" class="headerlink" title="ThreadLocal类："></a>ThreadLocal类：</h5><p>  此类提供线程局部变量。这些变量不同于它们的正常对应变量，因为每个访问一个（通过它的get或set方法）的线程都有它自己的、独立初始化的变量副本。 ThreadLocal实例通常是希望将状态与线程相关联的类中的私有静态字段（例如，用户 ID 或事务 ID）。<br>  例如，下面的类生成每个线程本地的唯一标识符。线程的 id 在第一次调用ThreadId.get()时被分配，并且在后续调用中保持不变。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadId</span> &#123;</span><br><span class="line">      <span class="comment">// Atomic integer containing the next thread ID to be assigned</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">nextId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Thread local variable containing each thread&#x27;s ID</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadId =</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span> <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> nextId.getAndIncrement();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Returns the current thread&#x27;s unique ID, assigning it if necessary</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> threadId.get();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            local.set(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,local:&quot;</span> + local.get());</span><br><span class="line">        &#125;).start());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">线程：Thread-<span class="number">0</span>,local:Thread-<span class="number">0</span>:<span class="number">0</span></span><br><span class="line">线程：Thread-<span class="number">1</span>,local:Thread-<span class="number">1</span>:<span class="number">1</span></span><br><span class="line">线程：Thread-<span class="number">2</span>,local:Thread-<span class="number">2</span>:<span class="number">2</span></span><br><span class="line">线程：Thread-<span class="number">3</span>,local:Thread-<span class="number">3</span>:<span class="number">3</span></span><br><span class="line">线程：Thread-<span class="number">4</span>,local:Thread-<span class="number">4</span>:<span class="number">4</span></span><br><span class="line">线程：Thread-<span class="number">5</span>,local:Thread-<span class="number">5</span>:<span class="number">5</span></span><br><span class="line">线程：Thread-<span class="number">6</span>,local:Thread-<span class="number">6</span>:<span class="number">6</span></span><br><span class="line">线程：Thread-<span class="number">7</span>,local:Thread-<span class="number">7</span>:<span class="number">7</span></span><br><span class="line">线程：Thread-<span class="number">8</span>,local:Thread-<span class="number">8</span>:<span class="number">8</span></span><br><span class="line">线程：Thread-<span class="number">9</span>,local:Thread-<span class="number">9</span>:<span class="number">9</span></span><br></pre></td></tr></table></figure><p>  从结果可以看到，每一个线程都有自己的local 值，这就是TheadLocal的基本使用 。</p><p>  只要线程处于活动状态并且ThreadLocal实例可访问，每个线程都持有对其线程局部变量副本的隐式引用；在线程消失后，它的所有线程本地实例副本都将受到垃圾回收（除非存在对这些副本的其他引用）</p><ul><li>1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</li><li>2、线程间数据隔离</li><li>3、进行事务操作，用于存储线程事务信息。</li><li>4、数据库连接，<code>Session</code>会话管理。</li></ul><h5 id="JoinPoint类："><a href="#JoinPoint类：" class="headerlink" title="JoinPoint类："></a>JoinPoint类：</h5><p>  提供对连接点可用状态和有关它的静态信息的反射访问。此信息可使用特殊形式thisJoinPoint从建议正文中获得。此反射信息的主要用途是跟踪和记录应用程序。</p><p>  joinPoint.getSignature()：获取当前切点方法，其值为String com.itheima.controller.AopLogController.avoid()</p><p>  joinPoint.getSignature().getDeclaringTypeName()：获取切点方法所在类的类型，这相当于调用 getDeclaringType().getName()，但会缓存结果以提高效率。其值为：com.itheima.controller.AopLogController</p><p>  joinPoint.getSignature().getName()：此签名的标识符部分。对于方法，这将返回方法名称，其值为：avoid()</p><h5 id="ServletRequestAttributes："><a href="#ServletRequestAttributes：" class="headerlink" title="ServletRequestAttributes："></a>ServletRequestAttributes：</h5><p>  RequestAttributes：用于访问与请求关联的属性对象的抽象。支持访问请求范围的属性以及会话范围的属性，具有“全局会话”的可选概念。可以为任何类型的请求&#x2F;会话机制实现，特别是 servlet 请求。</p><p>  ServletRequestAttributes为RequestAttributes接口的基于 Servlet 的实现。从 servlet 请求和 https 会话范围访问对象，“会话”和“全局会话”之间没有区别。</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-SpringBoot%EF%BC%886%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><p>  ServletRequest：定义一个对象以向 servlet 提供客户端请求信息。 servlet 容器创建一个ServletRequest对象并将其作为参数传递给 servlet 的service方法。ServletRequest对象提供的数据包括参数名称和值、属性和输入流。扩展ServletRequest的接口可以提供额外的特定于协议的数据（例如，https 数据由javax.servlet.https.httpsServletRequest提供。</p><p>  httpsServletRequest：扩展ServletRequest接口以提供 https servlet 的请求信息。servlet 容器创建一个httpsServletRequest对象并将其作为参数传递给 servlet 的服务方法（ doGet 、 doPost等）。</p><h5 id="Before和-AfterReturning注解"><a href="#Before和-AfterReturning注解" class="headerlink" title="@Before和@AfterReturning注解"></a>@Before和@AfterReturning注解</h5><p>类似于使用@Before注解可以修饰Before增强处理，使用@AfterReturning可修饰AfterReturning增强处理，AfterReturning增强处理将在目标方法正常完成后被织入。</p><p>使用@AfterReturning注解可指定如下两个常用属性。</p><ol><li><pre><code>   pointcut/value:这两个属性的作用是一样的，它们都属于指定切入点对应的切入[表达式](httpss://so.csdn.net/so/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;spm=1001.2101.3001.7020)。一样既可以是已有的切入点，也可直接定义切入点表达式。当指定了pointcut属性值后，value属性值将会被覆盖。</code></pre></li><li><pre><code>   returning:该属性指定一个形参名，用于表示Advice方法中可定义与此同名的形参，该形参可用于访问目标方法的返回值。除此之外，在Advice方法中定义该形参（代表目标方法的返回值）时指定的类型，会限制目标方法必须返回指定类型的值或没有返回值。</code></pre></li></ol><h5 id="AfterThrowing注解"><a href="#AfterThrowing注解" class="headerlink" title="@AfterThrowing注解"></a>@AfterThrowing注解</h5><p>使用@AfterThrowing注解可以修饰AfterThrowing增强处理，AfterThrowing增强处理主要用于处理程序中未处理的异常。使用@AfterThrowing注解时可指定如下的常用属性：</p><ol><li><pre><code>   pointcut/value:这两个属性的作用是一样的，它们都用于指定该切入点对应的切入[表达式](httpss://so.csdn.net/so/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;spm=1001.2101.3001.7020)。一样既可是一个已有的切入点，也可以直接定义切入点表达式。当指定了pointcut属性后，value属性值将会被覆盖。</code></pre></li><li><pre><code>   throwing:该属性指定一个形参名，用于表示Advice方法中可定义与此同名的形参，该形参可用于访问目标方法抛出的异常。除此之外，在Advice方法中定义该参数时，指定的类型，会限制方法必须抛出指定类型的异常。</code></pre></li></ol><ul><li><p>@Before:在切入点开始处切入内容。</p></li><li><p>@After：在切入点结尾处切入内容。</p></li><li><p>@AfterReturn：在切入点返回(return)内容之后切入内容，可以用来对处理返回值做 一些加工处理。</p></li><li><p>@Around：在切入点前后切入内容，并控制何时执行切入点自身的内容。</p></li><li><p>@AfterThrowing：用来处理当切入内容部分抛出异常之后的处理逻辑。</p></li><li><p>@Aspect：标记为切面类。</p></li><li><p>@Component：把切面类加入loC容器中，让Spring进行管理。</p></li></ul><h3 id="2-编写控制器用于测试"><a href="#2-编写控制器用于测试" class="headerlink" title="2.编写控制器用于测试"></a>2.编写控制器用于测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopLogController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/aoptest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">avoid</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line">        logger.info(<span class="string">&quot;切点&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello aop&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 看下访问后控制台打印信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.785</span>  INFO <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet <span class="string">&#x27;dispatcherServlet&#x27;</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.785</span>  INFO <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] o.s.web.servlet.DispatcherServlet        : Initializing Servlet <span class="string">&#x27;dispatcherServlet&#x27;</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.786</span> TRACE <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] o.s.web.servlet.DispatcherServlet        : Detected org.springframework.web.multipart.support.StandardServletMultipartResolver@<span class="number">4886333</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.786</span> TRACE <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] o.s.web.servlet.DispatcherServlet        : Detected org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver@7451a4c0</span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.786</span> TRACE <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] o.s.web.servlet.DispatcherServlet        : Detected org.springframework.web.servlet.theme.FixedThemeResolver@4f5dd299</span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.787</span> TRACE <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] o.s.web.servlet.DispatcherServlet        : Detected DefaultRequestToViewNameTranslator</span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.787</span> TRACE <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] o.s.web.servlet.DispatcherServlet        : Detected SessionFlashMapManager</span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.787</span> DEBUG <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] o.s.web.servlet.DispatcherServlet        : enableLoggingRequestDetails=<span class="string">&#x27;false&#x27;</span>: request parameters and headers will be masked to prevent unsafe logging of potentially sensitive data</span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.787</span>  INFO <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] o.s.web.servlet.DispatcherServlet        : Completed initialization in <span class="number">2</span> ms</span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.805</span> TRACE <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] o.s.web.servlet.DispatcherServlet        : GET <span class="string">&quot;/aoptest&quot;</span>, parameters=&#123;&#125;, headers=&#123;masked&#125; in DispatcherServlet <span class="string">&#x27;dispatcherServlet&#x27;</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.807</span> TRACE <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped to com.itheima.controller.AopLogController#avoid()</span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.813</span> TRACE <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] o.s.web.method.HandlerMethod             : Arguments: []</span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.815</span>  INFO <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.itheima.domain.AopLog                : URL: /aoptest</span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.815</span>  INFO <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.itheima.domain.AopLog                : https方法：GET</span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.815</span>  INFO <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.itheima.domain.AopLog                : IP方法：<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">1</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.817</span>  INFO <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.itheima.domain.AopLog                : 类的方法：com.itheima.controller.AopLogController.avoid</span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.817</span>  INFO <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.itheima.domain.AopLog                : 参数：<span class="literal">null</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.824</span>  INFO <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.itheima.controller.AopLogController  : 切点</span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.824</span>  INFO <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.itheima.domain.AopLog                : 应答值：hello aop</span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.824</span>  INFO <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.itheima.domain.AopLog                : 费时：<span class="number">9</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">07</span>-<span class="number">16</span> <span class="number">17</span>:<span class="number">21</span>:<span class="number">49.833</span> DEBUG <span class="number">1412</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] m.m.a.RequestResponseBodyMethodProcessor : Using <span class="string">&#x27;text/html&#x27;</span>, given [text/html, application/xhtml+xml, image/avif, image/webp, application/xml;q=<span class="number">0.9</span>, *<span class="comment">/*;q=0.8] and supported [text/plain, */</span>*, text/plain, *<span class="comment">/*, application/json, application/*+json, application/json, application/*+json]</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.834 TRACE 1412 --- [nio-8080-exec-1] m.m.a.RequestResponseBodyMethodProcessor : Writing [&quot;hello aop&quot;]</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.841 TRACE 1412 --- [nio-8080-exec-1] s.w.s.m.m.a.RequestMappingHandlerAdapter : Applying default cacheSeconds=-1</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.841 TRACE 1412 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : No view rendering, null ModelAndView returned.</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.841 DEBUG 1412 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed 200 OK, headers=&#123;masked&#125;</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.907 TRACE 1412 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : GET &quot;/favicon.ico&quot;, parameters=&#123;&#125;, headers=&#123;masked&#125; in DispatcherServlet &#x27;dispatcherServlet&#x27;</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.909 TRACE 1412 --- [nio-8080-exec-2] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped to HandlerExecutionChain with [ResourcehttpsRequestHandler [&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;, &quot;/&quot;]] and 3 interceptors</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.911 DEBUG 1412 --- [nio-8080-exec-2] o.s.w.s.r.ResourcehttpsRequestHandler     : Resource not found</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.911 TRACE 1412 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : No view rendering, null ModelAndView returned.</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.911 DEBUG 1412 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : Completed 404 NOT_FOUND, headers=&#123;masked&#125;</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.913 TRACE 1412 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : &quot;ERROR&quot; dispatch for GET &quot;/error&quot;, parameters=&#123;&#125;, headers=&#123;masked&#125; in DispatcherServlet &#x27;dispatcherServlet&#x27;</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.914 TRACE 1412 --- [nio-8080-exec-2] s.w.s.m.m.a.RequestMappingHandlerMapping : 2 matching mappings: [&#123; [/error]&#125;, &#123; [/error], produces [text/html]&#125;]</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.914 TRACE 1412 --- [nio-8080-exec-2] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped to org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController#error(httpsServletRequest)</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.916 TRACE 1412 --- [nio-8080-exec-2] o.s.web.method.HandlerMethod             : Arguments: [org.apache.catalina.core.ApplicationhttpsRequest@349cdda4]</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.925 DEBUG 1412 --- [nio-8080-exec-2] o.s.w.s.m.m.a.httpsEntityMethodProcessor  : Using &#x27;application/json&#x27;, given [image/avif, image/webp, */</span>*] and supported [application/json, application<span class="comment">/*+json, application/json, application/*+json]</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.925 TRACE 1412 --- [nio-8080-exec-2] o.s.w.s.m.m.a.httpsEntityMethodProcessor  : Writing [&#123;timestamp=Sat Jul 16 17:21:49 CST 2022, status=404, error=Not Found, message=No message available, path=/favicon.ico&#125;]</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.958 TRACE 1412 --- [nio-8080-exec-2] s.w.s.m.m.a.RequestMappingHandlerAdapter : Applying default cacheSeconds=-1</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.958 TRACE 1412 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : No view rendering, null ModelAndView returned.</span></span><br><span class="line"><span class="comment">2022-07-16 17:21:49.958 DEBUG 1412 --- [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : Exiting from &quot;ERROR&quot; dispatch, status 404, headers=&#123;masked&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式编程WebFlux-SpringBoot（5）</title>
      <link href="/2022/07/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8BWebFlux-SpringBoot%EF%BC%885%EF%BC%89/"/>
      <url>/2022/07/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8BWebFlux-SpringBoot%EF%BC%885%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-响应式编程"><a href="#1-响应式编程" class="headerlink" title="1.响应式编程"></a>1.响应式编程</h1><p>  WebFlux是从Spring Framework 5.0开始引入响应式Web框架的。与Spring MVC不同, WebFlux不需要Servlet API,在完全异步且无阻塞，并通过Reactor项目实现Reactive Streams 规范。</p><p>  WebFlux可以在资源有限的情况下提高系统的吞吐量和伸缩性（不是提高性能）。这意味着， 在资源相同的情况下，WebFlux可以处理更多的请求（不是业务）。</p><p>  WebFlux除支持RESTful Web服务外，还可以用于提供动态HTML内容。</p><p><code>   MVC:</code></p><p>  MVC的工作流程是：主线程接收到请求（request）-准备数据-返回数据。整个过程是单线程咀塞的，用户会感觉等待时间长是因为，在结果处理好之后才返回数据给浏 览器。因此，如果请求很多，则吞吐量就上不去。</p><p><code>  WebFlux:</code></p><p>  WebFlux的工作流程是：主线程接收到请求—立刻返回数据与函数的组合（Mon或Flux, 不是结果），开启一个新Work线程去做实际的数据准备工作，进行真正的业务操作，Work 线程完成工作，返给用户真实数据（结果）。</p><p>  这种方式给人的感売是响应时间很短，因为返回的是不变的常数，它不随用户数量的增加而变化。</p><p>两者对比：</p><p><img src="https://image.buretuzi.online/blog/article/springboot/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8BWebFlux-SpringBoot%EF%BC%885%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><h1 id="2-Mono和Flux"><a href="#2-Mono和Flux" class="headerlink" title="2.Mono和Flux"></a>2.Mono和Flux</h1><p>Mono和Flux是Reactor中的两个基本概念。</p><ul><li>Mono和Flux属于事件发布者，为消费者提供订阅接口。当有事件发生时，Mono或Flux 会回调消费者的相应方法，然后通知消费者相应的事件。这也是晌应式编程模型。</li><li>Mono和Flux用于处理异步数据流，它不像MVC中那样直接返回String&#x2F;List,而是将异步数据流包装成Mono或Flux对象</li></ul><h2 id="Mono和Flux的区别"><a href="#Mono和Flux的区别" class="headerlink" title="Mono和Flux的区别"></a>Mono和Flux的区别</h2><ol><li><p>Flux可以发送很多item,并且这些item可以经过若干算子(operators )后才被订阅。 Mono只能发送一个itemo</p></li><li><p>Mono主要用于返回单个数据。Flux用于返回多个数据。如果要根据id查询某个User对象，则返回的肯定是单个User，那么需要将其包装成Mono<User>，若需要获取所有User (这是一个集合)，则需要将这个集合包装成Flux<User>，这里的单个数据并不是指一个数据，而是指封装好的一个对象。多个数据就是多个对象。</p></li><li><p>Mono表示包含0或1个元素的异步序列。在该序列中可以包含3种不同类型的消息通知: 正常的包含元素的消息、序列结束的消息、序列岀错的消息。当消息通知(正常的包含元素的消息、 序列结束的消息、序列出错的消息)产生时，订阅者中有对应的方法onNext( )、onComplete( ). onError( )被调用</p></li><li><p>Flux表示的是包含0到N个元素的异步序列，在该序列中可以包含与Mono相同的3种类型的消息通知。</p></li><li><p>Flux和Mono之间可以进行转换。对一个Flux序列进行计数操作时，得到的结果是一个 Mono<Long>对象。把多个Mon。序列合并在一起，得到的是一个Flux对象</p></li></ol><h2 id="开发WebFlux的流程"><a href="#开发WebFlux的流程" class="headerlink" title="开发WebFlux的流程"></a>开发WebFlux的流程</h2><ol><li>注解式开发流程</li></ol><p>  WebFlux是响应式框架，其中使用的注解式开发方式只是Spring团队为了更好地迁移而提供的。和MVC开发模式一样，地址映射也是通过@RequestMapping提供的，用@Controller或 @RestController 来代替 Handler 类。</p><p>  2.响应式开发流程  </p><p>    （1）创建 Handler 类</p><p>    这里的Handler类相当于Spring MVC的Controller层中的方法体。在响应式编程中，请求和响应不再是 httpsServletRequest 和 httpsServletResponse,而是变成了 ServerRequest 和 ServerResponse</p><p>    （2）配置 RouterFunction</p><p>    RouterFunction 和注解@RequestMapping 相似，都用于提供 URL 路径。RouterFunction 的格式也是固定的，第1个参数代表路径，第2个参数代表方法，合起来代表将URL映射到方法。</p><h2 id="实例：Hello-world"><a href="#实例：Hello-world" class="headerlink" title="实例：Hello world"></a>实例：Hello world</h2><p>配置WebFlux依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>     编写控制器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/helloworld&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">helloworld</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.just(<span class="string">&quot;这是响应式编程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例：用注解式开发实现数据的增加、删除、修改和查询"><a href="#实例：用注解式开发实现数据的增加、删除、修改和查询" class="headerlink" title="实例：用注解式开发实现数据的增加、删除、修改和查询"></a>实例：用注解式开发实现数据的增加、删除、修改和查询</h2><h3 id="创建实体类："><a href="#创建实体类：" class="headerlink" title="创建实体类："></a>创建实体类：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写控制器："><a href="#编写控制器：" class="headerlink" title="编写控制器："></a>编写控制器：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.https.httpsStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.https.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    Map&lt;Long, User&gt; users = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Long, User&gt;();</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        users.put(Long.valueOf(<span class="number">1</span>),<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;John&quot;</span>,<span class="number">28</span>));</span><br><span class="line">        users.put(Long.valueOf(<span class="number">2</span>),<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>,<span class="string">&quot;ane&quot;</span>,<span class="number">29</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;User&gt; <span class="title function_">getAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> Flux.fromIterable(users.entrySet().stream()</span><br><span class="line">                .map(entry -&gt; entry.getValue())</span><br><span class="line">                .collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.justOrEmpty(users.get(id));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ResponseEntity&lt;String&gt;&gt; <span class="title function_">addUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        users.put(user.getId(), user);</span><br><span class="line">        <span class="keyword">return</span> Mono.just(<span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(<span class="string">&quot;添加成功&quot;</span>, httpsStatus.CREATED));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ResponseEntity&lt;User&gt;&gt; <span class="title function_">updateUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id,User user)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        user.setId(id);</span><br><span class="line">        users.put(id, user);</span><br><span class="line">        <span class="keyword">return</span> Mono.just(<span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(user,httpsStatus.CREATED));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ResponseEntity&lt;String&gt;&gt; <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">        users.remove(id);</span><br><span class="line">        <span class="keyword">return</span> Mono.just(<span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(<span class="string">&quot;删除成功&quot;</span>,httpsStatus.ACCEPTED));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下数据转换过程：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Long, User&gt; users：&#123;<span class="number">1</span>=User(id=<span class="number">1</span>, name=John, age=<span class="number">28</span>), <span class="number">2</span>=User(id=<span class="number">2</span>, name=ane, age=<span class="number">29</span>)&#125;</span><br><span class="line">users.entrySet()：[<span class="number">1</span>=User(id=<span class="number">1</span>, name=John, age=<span class="number">28</span>), <span class="number">2</span>=User(id=<span class="number">2</span>, name=ane, age=<span class="number">29</span>)]</span><br><span class="line">users.entrySet().stream().toString()：java.util.stream.ReferencePipeline$Head@785a5991</span><br><span class="line">users.entrySet().stream()</span><br><span class="line">                .map(entry -&gt; entry.getValue()).toString()：java.util.stream.ReferencePipeline$<span class="number">3</span>@<span class="number">748631e4</span></span><br><span class="line">users.entrySet().stream()</span><br><span class="line">                .map(entry -&gt; entry.getValue())</span><br><span class="line">                .collect(Collectors.toList())：[User(id=<span class="number">1</span>, name=John, age=<span class="number">28</span>), User(id=<span class="number">2</span>, name=ane, age=<span class="number">29</span>)]</span><br><span class="line">可以看出entrySet()将map转为了set集合，entrySet() 方法返回映射中包含的映射的 Set 视图。</span><br></pre></td></tr></table></figure><p>对应数据类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Long, User&gt; users：type：<span class="keyword">class</span> <span class="title class_">java</span>.util.HashMap</span><br><span class="line">users.entrySet()：type：<span class="keyword">class</span> <span class="title class_">java</span>.util.HashMap$EntrySet</span><br><span class="line">users.entrySet().stream()：type：<span class="keyword">class</span> <span class="title class_">java</span>.util.stream.ReferencePipeline$Head</span><br><span class="line">users.entrySet().stream()</span><br><span class="line">                .map(entry -&gt; entry.getValue())：type：<span class="keyword">class</span> <span class="title class_">java</span>.util.stream.ReferencePipeline$<span class="number">3</span></span><br><span class="line">users.entrySet().stream()</span><br><span class="line">                .map(entry -&gt; entry.getValue())</span><br><span class="line">                .collect(Collectors.toList())：type：<span class="keyword">class</span> <span class="title class_">java</span>.util.ArrayList</span><br></pre></td></tr></table></figure><p>users.entrySet().stream()<br>    返回支持顺序和并行聚合操作的元素序列。以下示例说明了使用Stream和IntStream的聚合操作：<br>     int sum &#x3D; widgets.stream()<br>                      .filter(w -&gt; w.getColor() &#x3D;&#x3D; RED)<br>                      .mapToInt(w -&gt; w.getWeight())<br>                      .sum();  </p><p>  在此示例中， widgets是Collection<Widget> 。我们通过Collection.stream()创建一个Widget对象流，对其进行过滤以生成仅包含红色小部件的流，然后将其转换为表示每个红色小部件重量的int值流。然后将该流相加以产生总重量。除了作为对象引用流的Stream之外，还有IntStream 、 LongStream和DoubleStream的原始特化，所有这些都被称为“流”，并符合此处描述的特征和限制。为了执行计算，流操作被组合成一个流管道。流管道由源（可能是数组、集合、生成器函数、I&#x2F;O 通道等）、零个或多个中间操作（将流转换为另一个流，例如filter(Predicate) ) 和终端操作（产生结果或副作用，例如count()或forEach(Consumer) ）。流是懒惰的；仅在发起终端操作时才对源数据进行计算，并且仅在需要时消耗源元素。<br>  集合和流虽然有一些表面上的相似之处，但有不同的目标。馆藏主要关注其元素的有效管理和访问。相比之下，流不提供直接访问或操作其元素的方法，而是关注以声明方式描述其源以及将在该源上聚合执行的计算操作。但是，如果提供的流操作不提供所需的功能，则可以使用iterator()和spliterator()操作来执行受控遍历。<br>流管道，如上面的“小部件”示例，可以被视为对流源的查询。除非源明确设计用于并发修改（例如ConcurrentHashMap ），否则在查询流源时修改流源可能会导致不可预测或错误的行为。<br>大多数流操作接受描述用户指定行为的参数，例如上面示例中传递给mapToInt的 lambda 表达式w -&gt; w.getWeight() 。</p><p>  为了保持正确的行为，这些行为参数：必须是无干扰的（它们不会修改流源）；和在大多数情况下必须是无状态的（它们的结果不应依赖于在流管道执行期间可能更改的任何状态）。此类参数始终是函数接口的实例，例如Function ，并且通常是 lambda 表达式或方法引用。除非另有说明，否则这些参数必须为非 null 。一个流应该只被操作一次（调用一个中间或终端流操作）。例如，这排除了“分叉”流，其中相同的源提供两个或多个管道，或同一流的多次遍历。如果流实现检测到流正在被重用，它可能会抛出IllegalStateException 。但是，由于某些流操作可能返回其接收者而不是新的流对象，因此可能无法在所有情况下检测重用。流有一个close()方法并实现了AutoCloseable ，但几乎所有的流实例在使用后实际上并不需要关闭。通常，只有源为 IO 通道的流（例如由Files.lines(Path, Charset)返回的流）才需要关闭。大多数流由集合、数组或生成函数支持，不需要特殊的资源管理。 （如果流确实需要关闭，可以在try -with-resources 语句中将其声明为资源。）流管道可以按顺序或并行执行。这种执行模式是流的属性。流是通过初始选择顺序或并行执行来创建的。 （例如， Collection.stream()创建一个顺序流， Collection.parallelStream()创建一个并行流。）这种执行模式的选择可以通过sequential()或parallel()方法进行修改，并且可以通过以下方式查询isParallel()方法。</p><p>    users.entrySet().stream()<br>                .map(entry -&gt; entry.getValue())<br>                .collect(Collectors.toList())：</p><p>  例如上方代码将返回map中包含的映射的set视图（即set集合），然后创建一个set引用流，将引用流中的数据取出，然后使用Collector对此流的元素执行可变归约操作，最后效果为将数据取出，并去掉了键，保留了值，转为了List数组。</p><p>   Collector封装了用作collect(Supplier, BiConsumer, BiConsumer)参数的函数，允许重用收集策略和组合收集操作，例如多级分组或分区。<br>  如果流是并行的，并且Collector是concurrent的，并且流是无序的或收集器是unordered的，则将执行并发归约（有关并发归约的详细信息，请参阅Collector 。）<br>这是终端操作。<br>  当并行执行时，可以实例化、填充和合并多个中间结果，以保持可变数据结构的隔离。因此，即使与非线程安全的数据结构（例如ArrayList ）并行执行，也不需要额外的同步来进行并行归约。</p><p>  最后返回collect</p><h3 id="测试API功能"><a href="#测试API功能" class="headerlink" title="测试API功能"></a>测试API功能</h3><p>（1）获取数据</p><p>  启动项目后访问URL：<a href="https://localhost:8080/user/list">https://localhost:8080/user/list</a> ,会得到两个初始化的数据，输岀结果：[{“id”:1,”name”:”John”,”age”:28},{“id”:2,”name”:”ane”,”age”:29}]</p><p>  访问URL：<a href="https://localhost:8080/user/1,%E5%BE%97%E5%88%B0%E7%9A%84%E6%98%AFid%E4%B8%BA1%E7%9A%84%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%A7%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%EF%BC%9A%7B&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:28%7D">https://localhost:8080/user/1,得到的是id为1的单个对象，见输出结果：{&quot;id&quot;:1,&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:28}</a></p><p>（2）修改数据</p><p>  修改数据的方法是通过PUT方式访问”<a href="https://localhost:8080/user/1&quot;,%E6%8F%90%E4%BA%A4%E7%9B%B8%E5%BA%94%E7%9A%84name%E5%92%8Cage%E5%AD%97%E6%AE%B5%E6%9D%A5%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9">https://localhost:8080/user/1&quot;,提交相应的name和age字段来修改内容</a>(使用的是测试工具Postman ),如下所示。稍后会提示修改成功。</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8BWebFlux-SpringBoot%EF%BC%885%EF%BC%89%EF%BC%882%EF%BC%89.png"></p><p>（3）添加数据</p><p>  可以通过POST方式提_交_User对象来添加数据。</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8BWebFlux-SpringBoot%EF%BC%885%EF%BC%89%EF%BC%883%EF%BC%89.png"></p><p>（4）删除数据</p><p>  <img src="https://image.buretuzi.online/blog/article/springboot/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8BWebFlux-SpringBoot%EF%BC%885%EF%BC%89%EF%BC%884%EF%BC%89.png"></p><h2 id="实例：用晌应式开发方式开发WebFlux"><a href="#实例：用晌应式开发方式开发WebFlux" class="headerlink" title="实例：用晌应式开发方式开发WebFlux"></a>实例：用晌应式开发方式开发WebFlux</h2><h3 id="（1）编写处理器类Handler"><a href="#（1）编写处理器类Handler" class="headerlink" title="（1）编写处理器类Handler"></a>（1）编写处理器类Handler</h3><p>Handler相当于MVC中的Controller，用于提供实现功能的方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.handler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.https.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ServerResponse&gt;sayHello(ServerRequest serverRequest)&#123;</span><br><span class="line">        <span class="keyword">return</span> ServerResponse.ok().contentType(MediaType.TEXT_PLAIN).body(Mono.just(<span class="string">&quot;你好&quot;</span>),String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）编写路由器类Router"><a href="#（2）编写路由器类Router" class="headerlink" title="（2）编写路由器类Router"></a>（2）编写路由器类Router</h3><p>Router的主要功能是提供路由映射，相当于MVC模式中的注解@RequestMapping</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.router;</span><br><span class="line"><span class="keyword">import</span> com.itheima.handler.HelloWorldHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunction;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RequestPredicates.GET;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RouterFunctions.route;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Router</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloWorldHandler helloWorldHandler;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title function_">getString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> route(GET(<span class="string">&quot;/helloWorld&quot;</span>),req-&gt;helloWorldHandler.sayHello(req));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，通过<code>return route(GET(&quot;/helloWorld&quot;),req-&gt;helloWorldHandler.sayHello(req));</code>  来指定路由，包含https方法和对应的功能方法。</p><h2 id="实例：用WebFlux模式操作MongoDB数据库，实现数据的增加、删除、修改和查询的功能"><a href="#实例：用WebFlux模式操作MongoDB数据库，实现数据的增加、删除、修改和查询的功能" class="headerlink" title="实例：用WebFlux模式操作MongoDB数据库，实现数据的增加、删除、修改和查询的功能"></a>实例：用WebFlux模式操作MongoDB数据库，实现数据的增加、删除、修改和查询的功能</h2><h3 id="（1）添加依赖"><a href="#（1）添加依赖" class="headerlink" title="（1）添加依赖"></a>（1）添加依赖</h3><p>    要操作数据库，则需要添加相应的依赖。可以通过Spring Boot集成的MongoDB的Starter 依赖来快速实现配置和操作。具体依赖见以下代码</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在配置文件中配置MongoDB的地址信息(MongoDB 2.4以上版本),见以下代码：</p><p>spring.data.mongodb.uri&#x3D;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;test</p><p>配置Mongo的格式如下:</p><p>spring.data.mongodb.uri&#x3D;mongodb:&#x2F;&#x2F;用户名: 密码@ip 地址:端口号&#x2F;数据库</p><h3 id="（2）创建实体类"><a href="#（2）创建实体类" class="headerlink" title="（2）创建实体类"></a>（2）创建实体类</h3><p>    这里编写实体类并没有特别需要讲解的，只是利用了 Lombok插代码，具体见以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）编写接口"><a href="#（3）编写接口" class="headerlink" title="（3）编写接口"></a>（3）编写接口</h3><p>    Spring Boot 的 Starter 提供了 ReactiveMongoRepository 接口，用于操作 Mongo 数据库, 用法见以下代码：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.dao;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.repository.ReactiveMongoRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">ReactiveMongoRepository</span>&lt;User,String&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）编写API"><a href="#（4）编写API" class="headerlink" title="（4）编写API"></a>（4）编写API</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.UserRepository;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.repository.ReactiveMongoRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.https.httpsStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.https.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.https.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.annotation.Validated;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Valid;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;User&gt; <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/listdelay&quot;,produces = MediaType.APPLICATION_STREAM_JSON_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;User&gt; <span class="title function_">getAllDelay</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findAll().delayElements(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ResponseEntity&lt;User&gt;&gt; <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(id)</span><br><span class="line">                .map(getUser-&gt;ResponseEntity.ok(getUser))</span><br><span class="line">                .defaultIfEmpty(ResponseEntity.notFound().build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@Valid</span> User user)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono <span class="title function_">updateUser</span><span class="params">(<span class="meta">@PathVariable(value = &quot;id&quot;)</span>String id,<span class="meta">@Valid</span> User user)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(id)</span><br><span class="line">                .flatMap(existingUser-&gt;&#123;</span><br><span class="line">                    existingUser.setName(user.getName());</span><br><span class="line">                    <span class="keyword">return</span> userRepository.save(existingUser);</span><br><span class="line">                &#125;)</span><br><span class="line">                .map(updateUser-&gt;<span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(updateUser,httpsStatus.OK))</span><br><span class="line">                .defaultIfEmpty(<span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(httpsStatus.NOT_FOUND));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>produces &#x3D; MediaType.APPLICATION_STREAM_JSON_VALUE：这里媒体类型必须是APPLICATION_STREAM_JSON_VALUE,否则调用端无法滚动得到结果，将一直 阻塞直到数据流结束或超时。</li><li>Duration.ofSeconds(1)：代表一秒一秒地返回数据，而不是一下全部返回。</li><li>ResponseEntity.ok， ResponseEntity继承了 httpsEntity,是 httpsEntity 的子类，且可以添加httpsStatus状态码。</li><li>flatMap：返回的是迭代器中的元素。</li><li>httpsStatus: NOT_FOUND：代表https状态是404,表示没有找到。</li><li>httpsStatus.OK：代表https状态是200,表示处理成功</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视图技术Thymeleaf-SpringBoot（4）</title>
      <link href="/2022/07/12/%E8%A7%86%E5%9B%BE%E6%8A%80%E6%9C%AFThymeleaf-SpringBoot%EF%BC%884%EF%BC%89/"/>
      <url>/2022/07/12/%E8%A7%86%E5%9B%BE%E6%8A%80%E6%9C%AFThymeleaf-SpringBoot%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是Thymeleaf"><a href="#1-什么是Thymeleaf" class="headerlink" title="1.什么是Thymeleaf"></a>1.什么是Thymeleaf</h1><p>  Spring Boot 主要支持Thymeleaf、Freenrtarker、Mustache、Groovy Templates 等模板引擎。</p><p>  Thymeleaf语法并不会破坏文档的结构，所以Thymeleaf模板依然是有效的HTML文档。模 板还可以被用作工作原型，Thymeleaf会在运行期内替换掉静态值。它的模板文件能直接在浏览器 中打开并正确显示页面，而不需要启动整个Web应用程序。</p><h2 id="1-1-为什么需要模板引擎"><a href="#1-1-为什么需要模板引擎" class="headerlink" title="1.1 为什么需要模板引擎"></a>1.1 为什么需要模板引擎</h2><p>  Thymeleaf解决了前端开发人员要和后端开发人员配置一样环境的尴尬和低效。它通过属性进 行模板渲染，不需要引入不能被浏览器识别的新的标签。页面直接作为HTML文件，用浏览器打开页面即可看到最终的效果，可以降低前后端人员的沟通成本。</p><h2 id="1-2-使用Thymeleaf"><a href="#1-2-使用Thymeleaf" class="headerlink" title="1.2 使用Thymeleaf"></a>1.2 使用Thymeleaf</h2><p>要使用Thymeleaf,首先需要引入依赖。直接在pom.xml文件中加入以下依赖即可。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在模板文件中加入解析，在html文件中加入命名空间即可。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;https://www.thymeleaf.org/&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-3-配置视图解析器"><a href="#1-3-配置视图解析器" class="headerlink" title="1.3 配置视图解析器"></a>1.3 配置视图解析器</h2><p>  Spring Boot默认的页面映射路径(即模板文件存放的位置)为 “classpath: &#x2F;templates&#x2F;*.html” 。 静态文件路径为  “classpath:&#x2F;static&#x2F;“，其中可以存放层叠样式表CSS( Cascading Style Sheets )、 JS (JavaScript)等模板共用的静态文件。在application.yml文件中，可以配置Thymeleaf模板解析器属性</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">HTML5</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="attr">servlet:</span></span><br><span class="line">      <span class="attr">content-type:</span> <span class="string">text/html</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>spring.thymeleaf.mode：代表 Thymeleaf 模式。</p><p>spring.thymeleaf.encodmg：代表 Thymeleaf 编码格式。</p><p>thymeleaf.content-type：代表文档类型。</p><p>thymeleaf.cache:代表是否启用 Thymeleaf 的缓存。</p><h1 id="2-基础用法"><a href="#2-基础用法" class="headerlink" title="2.基础用法"></a>2.基础用法</h1><h2 id="2-1-引用命名空间"><a href="#2-1-引用命名空间" class="headerlink" title="2.1 引用命名空间"></a>2.1 引用命名空间</h2><p>  要使用Thymeleaf,则需要先要加入依赖，然后在模板文件中引用命名空间，如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;https://www.thymeleaf.org&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  之后，会进行Thymeleaf模板标签的渲染。如果用Spring Security作为安全认证，且需要显示登录用户的信息，则可以先在视图中加入额外的thymeleaf-extras-springsecurity依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-springsecurity3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  然后 在模板文件中加入thymeleaf-extras-springsecurity命名空间，具体见以下代码:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns</span>=<span class="string">&quot;https://www.w3.org/1999/xhtml&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:th</span>=<span class="string">&quot;https://www.thymeleaf.org&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:sec</span>=<span class="string">&quot;https://www.thymeleaf.org/tyemeleaf-extras-springsecurity5&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authorization</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasRole(&#x27;ROLE_ADMIN&#x27;)&quot;</span>&gt;</span>管理员<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;hasRole(&#x27;ROLE_USER&#x27;)&quot;</span>&gt;</span>普通用户<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 这里特别要注意查看 spring-boot—starter-thymeleaf 依赖和 thymeleaf-extras- springsecurity依赖的版本是否兼容。如果不兼容，则无法调用登录用户的信息。</p><h2 id="2-2-常用th标签"><a href="#2-2-常用th标签" class="headerlink" title="2.2 常用th标签"></a>2.2 常用th标签</h2><p>（1）th:text</p><p><code>&lt;div th:text=&quot;$&#123;name&#125;&quot;&gt;name&lt;/div&gt;</code></p><p>它用于显示控制器传入的name值。</p><p>如果name不存在，要显示默认值，则使用以下代码：</p><p><code>&lt;span th:text=&quot;$&#123;ame&#125; ?:&#39;默认值&#39;&quot;&gt;&lt;/span&gt;</code></p><p>（2）th:object</p><p>它用于接收后台传过来的对象，如以下代码：</p><p><code>th:object=&quot;$&#123;user&#125;&quot;</code></p><p>（3）th:action</p><p>它用来指定表单提交地址。</p><p><code>&lt;form th:action=&quot;@&#123;/article/&#125;+$&#123;article.id&#125;&quot; method=&quot;post&quot;&gt;&lt;/form&gt;</code></p><p>（4）th:value</p><p>它用对象将id的值替换为value的属性。</p><p><code>&lt;input type=&quot;text&quot; th:value=&quot;$&#123;article.id&#125;&quot; name=&quot;id&quot;/&gt;</code></p><p>（5）th:field</p><p>它用来绑定后台对象和表单数据。Thymeleaf里的”th:field”等同于”th:name”和”th: valued”其具体使用方法见以下代码：</p><p><code>&lt;input type=&quot;text&quot; id=&quot;title&quot; name=&quot;title&quot; th:field=&quot;$&#123;book.id&#125;&quot;/&gt;</code><br><code>&lt;input type=&quot;text&quot; name=&quot;title&quot; th:field=&quot;$&#123;fields&#125;&quot;/&gt;</code></p><h2 id="2-3-Thymeleaf-中的-URL-写法"><a href="#2-3-Thymeleaf-中的-URL-写法" class="headerlink" title="2.3 Thymeleaf 中的 URL 写法"></a>2.3 Thymeleaf 中的 URL 写法</h2><p>Thymeleaf是通过语法@{…}来处理URL的，需要使用”th:href”和”th:src”等属性，如以下代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;https://www.thymeleaf.org&#125;&quot;</span>&gt;</span>绝对路径<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/&#125;&quot;</span>&gt;</span>相对路径<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;css/bootstrap.min.css&#125;&quot;</span>&gt;</span>默认访问static下的css文件夹<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-4用Thymeleaf进行条件求值"><a href="#2-4用Thymeleaf进行条件求值" class="headerlink" title="2.4用Thymeleaf进行条件求值"></a>2.4用Thymeleaf进行条件求值</h2><p>Thymeleaf通过 “th:if” 和 “th:unless” 属性迸行条件判断。在下面的例子中，<a>标签只有 在 “th:if” 中的条件成立时才显示。</p><p><code>&lt;a th:href=&quot;@&#123;/login&#125;&quot; th:if=&quot;$&#123;session.user == null&#125;&quot;&gt;Login&lt;/a&gt;</code></p><p>“th:unless” 与 “th:if” 恰好相反，只有当表达式中的条件不成立时才显示其内容。在下方代码中，如果用户session为空，则不显示登录(login )链接。</p><p><code>&lt;a th:href=&quot;@&#123;/login&#125;&quot; th:unless=&quot;$&#123;session.user == null&#125;&quot;&gt;Login&lt;/a&gt;</code></p><h2 id="2-5-Switch"><a href="#2-5-Switch" class="headerlink" title="2.5 Switch"></a>2.5 Switch</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:switch</span>=<span class="string">&quot;$&#123;book.getId()&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;ADMIN&quot;</span>&gt;</span>管理员<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;VIP&quot;</span>&gt;</span>vip会员<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;*&quot;</span>&gt;</span>普通会员<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码的意思是：如果用户角色(role)是admin,则显示“管理员”；如果用户角色是vip, 则显示”vip会员”；如果都不是，则显示“普通会员”，即使用“*”表示默认情况。</p><h2 id="2-6-Thymeleaf中的字符串替换"><a href="#2-6-Thymeleaf中的字符串替换" class="headerlink" title="2.6 Thymeleaf中的字符串替换"></a>2.6 Thymeleaf中的字符串替换</h2><p>有时需要对文字中的某一处地方进行替换，可以通过字符串拼接操作完成，如以下代码：</p><p><code>&lt;span th:text=&quot;&#39;欢迎,&#39;+$&#123;book.getUsername()&#125;+&#39;!&#39;&quot;&gt;&lt;/span&gt;</code></p><p>或者：</p><p><code>&lt;span th:text=&quot;|欢迎,$&#123;book.getUsername()&#125;!|&quot;&gt;&lt;/span&gt;</code></p><p>上面的第2种形式限制比较多，|…|中只能包含变量表达式${…},不能包含其他常量、条件表达式等。</p><h2 id="2-7-Thymeleaf的运算符"><a href="#2-7-Thymeleaf的运算符" class="headerlink" title="2.7 Thymeleaf的运算符"></a>2.7 Thymeleaf的运算符</h2><p>1.算数运算符。</p><p>    如果要在模板中进行算数运算，则可以用下面的写法。以下代码表示求加和取余运算。</p><p><code>  &lt;span th:text=&quot;1+3&quot;&gt;&lt;/span&gt;</code><br><code>  &lt;span th:text=&quot;9*3&quot;&gt;&lt;/span&gt;</code></p><p>2.条件运算符</p><p>    下方代码演示了 if判断，表示：如果从控制器传来的role值等于“admin”，则显示 “欢迎您, 管理员”；如果role值等于 “vip”，则显示 “欢迎您，vip会员”</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;book.getUsername()&#125; eq admin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>欢迎您，管理员<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;book.getUsername()&#125; eq vip&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>欢迎您，vip<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>eq是判断表达式，代表等于。其他的判断表达式如下。</p><p>gt：大于。</p><p>ge：大于或等于。</p><p>eq：等于。</p><p>It：小于。</p><p>     le：小于或等于。</p><p>ne：不等于。</p><p>3.判断空值</p><p>可以使用if来判断值是否为空，如以下代码：</p><p><code>&lt;span th:if=&quot;$&#123;book.getUsername()&#125;==null&quot;&gt;不为空&lt;/span&gt;    &lt;span th:if=&quot;$&#123;book.getUsername()&#125;!=null&quot;&gt;为空&lt;/span&gt;</code></p><h2 id="2-8-Thymeleaf公用对象"><a href="#2-8-Thymeleaf公用对象" class="headerlink" title="2.8 Thymeleaf公用对象"></a>2.8 Thymeleaf公用对象</h2><p>Thymeleaf还提供了一系列公用(utility)对象，可以通过”#”直接访问，如以下用法</p><p>格式化时间：</p><p>&#96;&lt;td th:text&#x3D;”$</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用程序分层开发模式—MVC-SpringBoot（3）</title>
      <link href="/2022/07/12/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%86%E5%B1%82%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E2%80%94MVC-SpringBoot%EF%BC%883%EF%BC%89/"/>
      <url>/2022/07/12/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%86%E5%B1%82%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E2%80%94MVC-SpringBoot%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MVC设计模式"><a href="#1-MVC设计模式" class="headerlink" title="1.MVC设计模式"></a>1.MVC设计模式</h1><p>Spring Boot开发Web应用程序主要使用MVC模式。MVC是Model （模型）、View（视图）、 Controller （控制器）的简写。</p><ul><li>Model：是Java的实体Bean,代表存取数据的对象或POJO （Plain Ordinary Java Objects,简单的Java对象），也可以带有逻辑。其作用是在内存中暂时存储数据，并在 数据变化时更新控制器（如果要持久化，则需要把它写入数据库或者磁盘文中）。</li><li>View：主要用来解析、处理、显示内容，并进行模板的渲染。</li><li>Controller：主要用来处理视图中的响应。它决定如何调用Model （模型）的实体Bean、 如何调用业务层的数据增加、删除、修改和查询等业务操作，以及如何将结果返给视图进行 渲染。建议在控制器中尽量不放业务逻辑代码。</li></ul><p>这样分层的好处是：将应用程序的用户界面和业务逻辑分离，度得代码具备良好的可扩展性、 可复用性、可维护性和灵活性。</p><p>如果不想使用MVC开发模式也是可以的，MVC只是一个非常合理的规范。MVC的关系如图所示</p><p><img src="https://image.buretuzi.online/blog/article/springboot/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%86%E5%B1%82%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E2%80%94MVC-SpringBoot%EF%BC%883%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><p>在整个Spring MVC框架中，DispatcherServlet处于核心位置，继承自httpsServlet。它负责协调和组织不同组件，以完成请求处理并返回响应工作。</p><p>整个工程流程如下：</p><p>（1 ）客户端（用户）发出的请求由Tomcat （服务器）接收，然后Tomcat将请求转交给 DispatcherServlet 处理。</p><p>（2）DispatcherServlet匹配控制器中配置的映射路径，进行下一步处理。</p><p>（3）ViewResolver 将 ModelAndView 或 Exception 解析成 View。然后 View 会调用 render（）方法，并根据ModelAndView中的数据渲染出页面。</p><p>在MVC开发模式中，容易混淆的还有Model,它往往会被认为是业务逻辑或DAO层。这 种理解并不能说是错误的，但并不是严格意义上的MVC模式。</p><h1 id="2-MVC和三层架构的关系"><a href="#2-MVC和三层架构的关系" class="headerlink" title="2.MVC和三层架构的关系"></a>2.MVC和三层架构的关系</h1><p>三层架构，就是将整个应用程序划分为表现层（UI）、业务逻辑层（Service ）、数据访问层 （DAO&#x2F;Repository ）。</p><ol><li>表现层：用于展示界面。主要对用户的请求进行接收，以及进行数据的返回。它为客户端（用 户）提供应用程序的访问接口（界面）。</li><li>业务逻辑层：是三层架构的服务层，负责业务逻辑处理，主要是调用DAO层对数据逬行增 加、删除’ 修改和查询等操作。</li><li>数据访问层：与数据库逬行交互的持久层，被Service调用。在Spring Data J PA中由 Hibernate 来实现°</li></ol><table style="border-collapse: collapse; width: 100.016%;" border="1"><tbody><tr><td style="width: 98.812%;"><p>Repository和DAO层一样，都可以进行数据的增加、删除、修改和查询-它们相当 于仓库管理员，执行进/出货操作。</p><p>DAO层的工作是存取对象。Repository层的工作是存取和管理对象</p><p>简单理解就是：Repository= 管理时象(对象缓存和在 Repository的状态) + DAO。丿</p></td></tr></tbody></table><p>严格地说，MVC是三层架构中的Ul层。通过MVC把三层架构中的UI层又进行了分层。</p><p>由此可见，三层架构是基于业务逻辑或功能来划分的，而MVC是基于页面或功能来划分的。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot在方法中使用参数-SpringBoot（2）</title>
      <link href="/2022/07/12/SpringBoot%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-SpringBoot%EF%BC%882%EF%BC%89/"/>
      <url>/2022/07/12/SpringBoot%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-SpringBoot%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-获取路径中的值"><a href="#1-获取路径中的值" class="headerlink" title="1.获取路径中的值"></a>1.获取路径中的值</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/put/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">put</span><span class="params">(<span class="meta">@PathVariable</span> String name)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在访问 ‘’<a href="https://localhost:8080/put/%E6%8B%89%E5%98%8E%E8%8A%82%E7%9B%AE&quot;">https://localhost:8080/put/拉嘎节目&quot;</a> 时，程序会自动将 URL 中的模板变量 {name} 绑定到通过@PathVariable 注解的同名参数上，即”程序获取路径中的值”</p><p><img src="https://image.buretuzi.online/blog/article/springboot/SpringBoot%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-SpringBoot%EF%BC%882%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><h1 id="2-获取路径中的参数"><a href="#2-获取路径中的参数" class="headerlink" title="2.获取路径中的参数"></a>2.获取路径中的参数</h1><p>对于路径中的参数获取 ，可以写入方法的形参中。下面代码是获取参数 username 的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/put&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">put</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://image.buretuzi.online/blog/article/springboot/SpringBoot%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-SpringBoot%EF%BC%882%EF%BC%89%EF%BC%882%EF%BC%89.png"></h2><h1 id="3-通过-Bean-接收-https-提交的对象"><a href="#3-通过-Bean-接收-https-提交的对象" class="headerlink" title="3.通过 Bean 接收 https 提交的对象"></a>3.通过 Bean 接收 https 提交的对象</h1><p>可以通过 Bean获取 https 提交的对象，如以下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/put&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">put</span><span class="params">(Book book)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> book.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title="."></a><img src="https://image.buretuzi.online/blog/article/springboot/SpringBoot%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-SpringBoot%EF%BC%882%EF%BC%89%EF%BC%883%EF%BC%89.png">.</h2><h1 id="4-用注解-ModelAttribute获取参数"><a href="#4-用注解-ModelAttribute获取参数" class="headerlink" title="4.用注解@ModelAttribute获取参数"></a>4.用注解@ModelAttribute获取参数</h1><p>用于从 Model、Form、URL 请求参数中获取属性值， 如以下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/put&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">put</span><span class="params">(<span class="meta">@ModelAttribute(&quot;book&quot;)</span> Book book)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> book.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数在路径URL中：</p><p><img src="https://image.buretuzi.online/blog/article/springboot/SpringBoot%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-SpringBoot%EF%BC%882%EF%BC%89%EF%BC%884%EF%BC%89.png"></p><p>参数在Form中：</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://image.buretuzi.online/blog/article/springboot/SpringBoot%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-SpringBoot%EF%BC%882%EF%BC%89%EF%BC%885%EF%BC%89.png"></h2><h1 id="5-通过httpsServletRequest接收参数"><a href="#5-通过httpsServletRequest接收参数" class="headerlink" title="5.通过httpsServletRequest接收参数"></a>5.通过httpsServletRequest接收参数</h1><p>可以通过httpsServletRequest接收参数 如以下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/put&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">put</span><span class="params">(httpsServletRequest request)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.buretuzi.online/blog/article/springboot/SpringBoot%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-SpringBoot%EF%BC%882%EF%BC%89%EF%BC%886%EF%BC%89.png"></p><h1 id="6-RequestParam绑定入参"><a href="#6-RequestParam绑定入参" class="headerlink" title="6.@RequestParam绑定入参"></a>6.@RequestParam绑定入参</h1><p>当请求参数不存在时会有异常发生，可以通过设置属性 “required&#x3D;false” 来解决。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/put&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, Comparable&gt; <span class="title function_">put</span><span class="params">(<span class="meta">@RequestParam(value = &quot;id&quot;,required = false)</span> Integer id, <span class="meta">@RequestParam(value = &quot;username&quot;,required = false)</span> String username)</span>&#123;</span><br><span class="line">    Map&lt;String, Comparable&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Comparable&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">    map.put(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.buretuzi.online/blog/article/springboot/SpringBoot%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-SpringBoot%EF%BC%882%EF%BC%89%EF%BC%887%EF%BC%89.png"></p><p>7.用@RequsetBody 接收 JSON 数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/put&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">put</span><span class="params">(<span class="meta">@RequestBody</span> Map&lt;String, String&gt; book)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.buretuzi.online/blog/article/springboot/SpringBoot%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-SpringBoot%EF%BC%882%EF%BC%89%EF%BC%888%EF%BC%89.png"></p><h1 id="8-上传文件MultipartFile"><a href="#8-上传文件MultipartFile" class="headerlink" title="8.上传文件MultipartFile"></a>8.上传文件MultipartFile</h1><p>通过@RequestParam 获取文件，如下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/put&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">put</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span>MultipartFile file, RedirectAttributes redirectAttributes)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (file.isEmpty())&#123;</span><br><span class="line">        redirectAttributes.addFlashAttribute(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;请选择文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;no&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = file.getBytes();</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;./&quot;</span>+file.getOriginalFilename());</span><br><span class="line">        Files.write(path, bytes);</span><br><span class="line">        redirectAttributes.addFlashAttribute(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;成功上传&quot;</span>+file.getOriginalFilename());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="https://image.buretuzi.online/blog/article/springboot/SpringBoot%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-SpringBoot%EF%BC%882%EF%BC%89%EF%BC%889%EF%BC%89.png"></h2><h1 id="9-上传图片"><a href="#9-上传图片" class="headerlink" title="9. 上传图片"></a>9. 上传图片</h1><p>  很多人在整合富文本编辑器时不容易成功，特别是在不同版本要求返回的数据类型不一样时，而网络上的资料很多是不带版本号或是过时的<br>  这里以常用的富文本编辑器 CKEditor为例，实现上传图片功能 。Spring Boot 4.0后的版本只有返回的是 JSON 恪式的数据才能成功，如 [{“uploaded”:1, “fileName”:”fileName”, “url”&#x3D; “message”:”上传成功”}] 上传图片的代码如下，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/put&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">put</span><span class="params">(<span class="meta">@RequestParam(&quot;upload&quot;)</span>MultipartFile file, RedirectAttributes redirectAttributes)</span>&#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">nyr</span> <span class="operator">=</span> dateFormat.format(date);</span><br><span class="line">    <span class="keyword">if</span> (file.getOriginalFilename().endsWith(<span class="string">&quot;.jpg&quot;</span>)||file.getOriginalFilename().endsWith(<span class="string">&quot;.png&quot;</span>)||</span><br><span class="line">        file.getOriginalFilename().endsWith(<span class="string">&quot;.git&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = file.getBytes();</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> nyr+Math.random()+file.getOriginalFilename();</span><br><span class="line">            <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;./&quot;</span>+s);</span><br><span class="line">            Files.write(path, bytes);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;格式不支持&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image.buretuzi.online/blog/article/springboot/SpringBoot%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-SpringBoot%EF%BC%882%EF%BC%89%EF%BC%8810%EF%BC%89.png"></p><p><img src="https://image.buretuzi.online/blog/article/springboot/SpringBoot%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-SpringBoot%EF%BC%882%EF%BC%89%EF%BC%8811%EF%BC%89.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https中媒体类型-SpringBoot（1）</title>
      <link href="/2022/07/12/HTTP%E4%B8%AD%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B-SpringBoot%EF%BC%881%EF%BC%89/"/>
      <url>/2022/07/12/HTTP%E4%B8%AD%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B-SpringBoot%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-常见媒体类型"><a href="#1-常见媒体类型" class="headerlink" title="1.常见媒体类型"></a>1.常见媒体类型</h1><p>在https协议中,使用，用 Content- Type 来表示具体请求中的媒体类型信息。 PC 端网页常用的是 “text&#x2F;html” 格式，手机 APP 常用的是 JSON 格式。</p><p>(1)常见的媒体格式如下<br>• text&#x2F;html : HTML 格式。<br>• text&#x2F;plain 纯文本格式。<br>• text&#x2F;xml: XML 格式。<br>• image&#x2F;gif: GIF 图片格式。<br>• image&#x2F;jpeg : JPG 图片格式<br>• image&#x2F;png: PNG 图片格式</p><p>( 2 )以 application开头的媒体格式如下。<br>• application&#x2F;xhtml+xml: XHTML + XML 格式。<br>• application&#x2F;xm : XML 数据格式。<br>• application&#x2F;atom+xml: Atom XML 聚合格式。<br>• application&#x2F;json: JSON 数据格式<br>• application&#x2F;pdf: PDF 格式<br>• application&#x2F;msword: Word 文档格式。<br>• application&#x2F;octe -stream: 二进制流数据(常用于文件下载)。<br>• application&#x2F;x-www-form-urlencoded 表单数据编码方式， <form encType=" " >中默认的 encType，Form (表单)数据被默认编码为 key&#x2F;value 格式发送给服务器。<br>• multipart&#x2F;form-data: 如果在表单中进行文件上传，则需要使用该格式。</p><h1 id="2-举例"><a href="#2-举例" class="headerlink" title="2.举例"></a>2.举例</h1><p>下面是一个返回 JSON 格式的数据的例子。代码中可以省略 Produces 属性，因为已经使用了注解@RestController ，它的返回值就是 JSON 格式的数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/get&quot;,method = RequestMethod.GET,produces = &quot;application/json&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setUsername(<span class="string">&quot;拉行啊&quot;</span>);</span><br><span class="line">        book.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问结果如下：</p><p><img src="https://image.buretuzi.online/blog/article/springboot/https%E4%B8%AD%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B-SpringBoot%EF%BC%881%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><p>在以下例子中， Consumes 是消费者，用于指定获取消费者的数据类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/put&quot;,method = RequestMethod.POST,consumes = &quot;application/json&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">put</span><span class="params">(<span class="meta">@RequestBody</span> String name)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="https://image.buretuzi.online/blog/article/springboot/https%E4%B8%AD%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B-SpringBoot%EF%BC%881%EF%BC%89%EF%BC%882%EF%BC%89.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
