<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>java垃圾收集器与内存分配策略(2) | 清河水温龙井茶</title><meta name="author" content="李文若"><meta name="copyright" content="李文若"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="好吧就这样吧"><meta property="og:type" content="article"><meta property="og:title" content="java垃圾收集器与内存分配策略(2)"><meta property="og:url" content="http://blog.buretuzi.online/2022/08/18/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)/index.html"><meta property="og:site_name" content="清河水温龙井茶"><meta property="og:description" content="好吧就这样吧"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://blog.buretuzi.online/img/1.webp"><meta property="article:published_time" content="2022-08-18T00:09:00.000Z"><meta property="article:modified_time" content="2025-05-13T09:14:30.696Z"><meta property="article:author" content="李文若"><meta property="article:tag" content="JVM"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://blog.buretuzi.online/img/1.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.buretuzi.online/2022/08/18/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"top-right"},source:{justifiedGallery:{js:"/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js",css:"/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"java垃圾收集器与内存分配策略(2)",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-05-13 09:14:30"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/mouseMove.css"><link rel="stylesheet" href="/css/navigation.css"><link rel="stylesheet" href="/css/Scrollbar.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/rightmenu.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/Progressbar.css"><link rel="stylesheet" href="/css/footer.css"><link rel="stylesheet" href="/css/footerIcon/iconfont.css"><script rel="stylesheet" href="/css/footerIcon/iconfont.js"></script><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/doublecolumn.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/player/aplayer.css"><link rel="stylesheet" href="/css/leftMenu.css"><link rel="stylesheet" href="/css/twikoo_beautify.css"><link rel="stylesheet" href="/css/about.css"><script defer charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script defer src="https://sdk.51.la/perf/js-sdk-perf.min.js" crossorigin="anonymous"></script><script defer src="/js/51La.js"></script><link rel="stylesheet" href="/css/categorybar.css"><link rel="stylesheet" href="https://image.buretuzi.online/blog/article/document/clock.min.css"><link rel="stylesheet" href="https://image.buretuzi.online/blog/article/document/runtime.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/css/swiper/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/css/swiper/swiperstyle.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",(()=>{preloader.endLoading()})),document.addEventListener("pjax:send",(()=>{preloader.initLoading()})),document.addEventListener("pjax:complete",(()=>{preloader.endLoading()}))</script><link rel="stylesheet" href="/css/Progressbar.css"><script src="/pluginsSrc/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i> <span>日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i> <span>菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i> <span>关于</span></a></li><li><a class="site-page child" href="/myself/"><i class="fa-fw fa fa-id-card"></i> <span>关于我</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/luaby"><i class="fa-fw fa fa-heart"></i> <span>butterfly</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><div class="back-home-button" tabindex="-1"><i class="back-home-button-icon fas fa-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.cnblogs.com/liwenruo/" title="前往博客主页" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src="data:image/png;base64,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"><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" href="http://buretuzi.online" rel="external nofollow" title="前往云盘主页" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src="data:image/png;base64,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"><span class="back-menu-item-text">我的社区</span></a></div></div></div></div><a id="site-name" href="/"><div class="title">清河水温龙井茶</div><i class="fa-solid fa-house"></i></a></span><div class="mask-name-container"><center id="name-container"><a id="page-name" href="javascript:rmf.scrollToTop()">PAGE_NAME</a></center></div><div id="menus"><div class="nav-button" id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" type="button" title="切换背景" onclick="toggleWinbox()"><i class="fas fa-image"></i></a></div><div class="nav-button" id="darkmode_navswitch"><a class="darkmode_switchbutton" type="button" title="浅色和深色模式转换" onclick="rmf.switchDarkMode()"><i class="fas fa-adjust"></i></a></div><div class="nav-button" id="nav-totop"><a class="totopbtn"><i class="fas fa-arrow-up"></i><span id="percent" onclick="btf.scrollToDest(0,500)">0</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i> <span>日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i> <span>菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i> <span>关于</span></a></li><li><a class="site-page child" href="/myself/"><i class="fa-fw fa fa-id-card"></i> <span>关于我</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/luaby"><i class="fa-fw fa fa-heart"></i> <span>butterfly</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">java垃圾收集器与内存分配策略(2)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-18T00:09:00.000Z" title="发表于 2022-08-18 00:09:00">2022-08-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-13T09:14:30.696Z" title="更新于 2025-05-13 09:14:30">2025-05-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>49分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="java垃圾收集器与内存分配策略(2)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>说起垃圾收集(Garbage Collection, GC),大部分人都把这项技术当做Java语言的伴生产物。事实上，GC的历史远远比Java久远，1960年诞生于MIT的Lisp是第一门 真正使用内存动态分配和垃圾收集技术的语言。当Lisp还在胚胎时期时，人们就在思考 GC需要完成的三件事情：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p>  经过半个世纪的发展，内存的动态分配与内存回收技术已经相当成熟，一切看起来 都进入了 ‘‘自动化”时代，那为什么我们还要去了解GC和内存分配呢？答案很简单： 当需要排査各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶 颈时，我们就需要对这些’‘自动化”的技术实施必要的监控和调节。</p><p>  把时间从半个世纪以前拨回到现在，回到我们熟悉的Java语言。第2章介绍了 Java 内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈 操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的(尽管在运行期会由JIT编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是 编译期可知的)，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。而 Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存，后续讨论中的”内存”分配与回收也仅指这一部分内存。</p><h1 id="2-对象巳死？"><a href="#2-对象巳死？" class="headerlink" title="2. 对象巳死？"></a>2. 对象巳死？</h1><p>堆中几乎存放着Java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一 件事情就是要确定这些对象有哪些还”存活”着，哪些已经“死去”(即不可能再被任何途径使用的对象)。</p><h2 id="2-1-引用计数算法"><a href="#2-1-引用计数算法" class="headerlink" title="2.1 引用计数算法"></a>2.1 引用计数算法</h2><p>  很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1 ；当引用失效时，计数器值就减1 ；任何时刻计数器都为0的对象就是不可能再被使用的。笔者面试过很多的应届生和一些有多年工 作经验的开发人员，他们对于这个问题给予的都是这个答案。</p><p>  客观地说，引用计数算法(Reference Counting)的实现简单，判定效率也很高， 在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软的 COM (Component Object Model)技术、使用 ActionScript 3 的 FlashPlayer、Python 语 言以及在游戏脚本领域中被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。 但是，Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决 对象之间的相互循环引用的问题。</p><p>  举个简单的例子，请看代码清单3-1中的testGCO方法：对象objA和objB都有字段 instance,赋值令 objA.instance &#x3D; objB 及 objB.instance &#x3D; objA,除此之外,这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0,于是引用计数算法无法通知GC收集器回收它们。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGC</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="literal">null</span>;</span><br><span class="line">        objB = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  程序正常退出，虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。</p><h2 id="2-2-根搜索算法"><a href="#2-2-根搜索算法" class="headerlink" title="2.2 根搜索算法"></a>2.2 根搜索算法</h2><p>在主流的商用程序语言中（Java和C#,甚至包括前面提到的古老的Lisp）,都是使用根搜索算法（GC Roots Tracing）判定对象是否存活的。这个算法的基本思路就是查 过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明此对象是不可用 的。如图3-1所示,对象。bject5、object 6. object 7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p><p>  在Java语言里，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li><li>方法区中的类静态属性引用的对象。</li><li>方法区中的常量引用的对象。</li><li>本地方法栈中JNI （即一般说的Native方法）的引用的对象。</li></ul><h2 id="2-3-再谈引用"><a href="#2-3-再谈引用" class="headerlink" title="2.3 再谈引用"></a>2.3 再谈引用</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引 用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2之前，Java中的引用 的定义很传统:如果reference类型的数据中存储的数值代表的是另外一块内存的起始 地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这 种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。 很多系统的缓存功能都符合这样的应用场景。</p><p>  在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference),软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)四种，这四种引用强度依次逐渐减弱。</p><ul><li>强引用就是指在程序代码之中普遍存在的，类似“Object obj &#x3D; new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li><li>软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在 系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二 次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了 SoftReference类来实现软引用。</li><li>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用 关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当 前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了 WeakReference类来实现弱引用。</li><li>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否 有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收 集器回收时收到一个系统通知。在JDK 1.2之后，提供了 PhantomReference类来 实现虚引用。</li></ul><h2 id="2-4-生存还是死亡？"><a href="#2-4-生存还是死亡？" class="headerlink" title="2.4 生存还是死亡？"></a>2.4 生存还是死亡？</h2><p>在根捜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于 “缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程:如果对象在进行 根捜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次 筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize（）方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为’‘没有必要 执行”。</p><p>  如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个 名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer 线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环(更极端的情况)，将很可能会导致F-Queue队列中的其他对象永久处于等待状态， 甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会， 稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this 关键字)赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。从代码清单3-2 中我们可以看到一个对象的finalize()被执行，但是它仍然可以存活。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">FinalizeEscapeGC</span> <span class="variable">SAVE_HOOK</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isAlive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am still alive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;Finalized method execution&quot;</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> <span class="title class_">FinalizeEscapeGC</span>();</span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为 finalize 方法优先级低，暂停等他0.5秒</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am dead!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为 finalize 方法优先级低，暂停等他0.5秒</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am dead!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行结果：</p><p>  Finalized method execution<br>  I am still alive<br>  I am dead!</p><p>  从代码清单3-2的运行结果可以看到，SAVE_HOOK对象的finalize()方法确实被 GC收集器触发过，并且在被收集前成功逃脱了。</p><p>  另外一个值得注意的地方就是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败，这是因为任何一个对象的finalize。方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行,因此第二段代码的自救行动失败了。</p><p>  需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用 它，因为它不是C&#x2F;C++中的析构函数，而是Java刚诞生时为了使C&#x2F;C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中提到它适合做“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize。能做的所有工作，使用try-finally或其他方式都可以做得更好、更及时,大家完全可以忘掉Java语言中还有这个方法的存在。</p><h2 id="2-5-回收方法区"><a href="#2-5-回收方法区" class="headerlink" title="2.5 回收方法区"></a>2.5 回收方法区</h2><p>  很多人认为方法区(或者HotSpot虚拟机中的永久代)是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收 集一般可以回收70%〜95%的空间，而永久代的垃圾收集效率远低于此。</p><p>  永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串 “abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc” 的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量 就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也 与此类似。</p><p>  判定一个常量是否是”废弃常量”比较简单，而要判定一个类是否是”无用的类” 的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供 了 -Xnoclassgc 参数进行控制，还可以使用-verbose:class 及-XX: +TraceClassLoading、 -XX:+TraceClassUnLoading 査看类的加载和卸载信息。-verbose: class 和-XX: +TraceClassLoading 可以在 Product 版的虚拟机中使用，但-XX:+TraceClassUnLoading 参数需要fastdebug版的虚拟机支持。</p><p>  在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和 OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能,以保证永久代不会溢出。</p><h1 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3. 垃圾收集算法"></a>3. 垃圾收集算法</h1><p>由于垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的 方法又各不相同，因此本节不打算过多地讨论算法的实现，只是介绍几种算法的思想及 其发展过程。</p><h2 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h2><p>  最基础的收集算法是“标记-清除”(Mark-Sweep)算法，如它的名字一样，算法分 _为_“标记“和“清除“两个阶段:首先标记出所有需要回收的对象，在标记完成后统一回 收掉所有被标记的对象,它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过 了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺 点进行改进而得到的。它的主要缺点有两个：一个是效率问题,标记和清除过程的效率都 不高：另外一个是空间问题,标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记-清除算法的执行过程如图3-2所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%881%EF%BC%89.png"></p><h2 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h2><p>为了解决效率问题，一种称为”复制”(Copying)的收集算法出现了，它将可用内存 按容量划分为大小相等的两块,毎次只使用其中的一块。当这一块的内存用完了，就将还 存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得 每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只 要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。复制算法的执行过程如图3-3所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%882%EF%BC%89.png"></p><p>  现在的商业虚拟机都采用这种收集算法来回收新生代,IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1 ： 1的比例来划分内存空间，而是 将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的 一块Survivor_”__。_当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外 一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟 机默认Eden和Survivor的大小比例是8 ： 1,也就是每次新生代中可用内存空间为整个 新生代容量的90% (80%+10%),只有10%的内存是会被“浪费”的。当然，98%的 对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对 象存活，当Survivor空间不够用时，需要依赖其他内存(这里指老年代)进行分配担保 (Handle Promotion)。</p><p>  内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能 按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担 保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保也一样，如果另外一块Survivor空间没有足够的空间存放上一次新生代收集 下来的存活对象，这些对象将直接通过分配担保机制进入老年代。关于对新生代进行分 配担保的内容，本章稍后在讲解垃圾收集器执行规则时还会再详细讲解。</p><h2 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a>3.3 标记-整理算法</h2><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>  根据老年代的特点，有人提出了另外一种“标记-整理”(Mark-Compact)算法， 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清 理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存,“标记-整理”算法的示意图如图3-4所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%883%EF%BC%89.png"></p><h2 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h2><p>当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，这 种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算 法。在新生代中,每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复 制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存 活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整 理”算法来进行回收。</p><h1 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4.垃圾收集器"></a>4.垃圾收集器</h1><p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。Java 虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本 的虚拟机所提供的垃圾收集器都可能会有很大的差别，并且一般都会提供参数供用户根 据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于Sun HotSpot虚拟机1.6版Update _22,_这个虚拟机包含的所有收集器如图3-5所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%884%EF%BC%89.png"></p><p>  图3-5展示了 7种作用于不同分代的收集器（包括JDK 1.6_Update14后引入的 Early Access版G1收集器），如果两个收集器之间存在连线，就说明它们可以搭配使用。</p><p>  在介绍这些收集器各自的特性之前，我们先来明确一个观点：虽然我们是在对各个 收集器进行比较，但并非为了挑选一个最好的收集器出来。因为直到现在为止还没有最 好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收 集器。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的 完美收集器存在，那HotSpot虚拟机就没必要实现那么多不同的收集器了。</p><h2 id="4-1-Serial-收集器"><a href="#4-1-Serial-收集器" class="headerlink" title="4.1 Serial 收集器"></a>4.1 Serial 收集器</h2><p>Serial收集器是最基本、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机 新生代收集的唯一选择。大家看名字就知道，这个收集器是一个单线程的收集器,但它 的’‘单线程”的意义并不仅仅是说明它只会使用一个CPU或一条收集线程去完成垃圾收 集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程（Sun将这件 事情称之为“Stop The World”）,直到它收集结束。“Stop The World”这个名字也许听 起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见 的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是难以接受的。你想 想，要是你的电脑每运行一个小时就会暂停响应5分钟，你会有什么样的心情？图3-6 示意了 Serial &#x2F; Serial Old收集器的运行过程。</p><p>  对于“Stop The World”带给用户的恶劣体验，虚拟机的设计者们表示完全理解，但也表示非常委屈：“你妈妈在给你打扫房间的时候，肯定也会让你老老实实地在椅子上 或房间外待着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完吗？ ”这确实是 一个合情合理的矛盾，虽然垃圾收集这项工作听起来和打扫房间属于一个性质的，但实际上肯定还要比打扫房间复杂得多啊！</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%885%EF%BC%89.png"></p><p>  从JDK 1.3开始，一直到现在还没正式发布的JDK 1.7，HotSpot虚拟机开发团队 为消除或减少工作线程因内存回收而导致停顿的努力一直在进行着，从Serial收集器 到Parallel收集器，再到Concurrent Mark Sweep （CMS）现在还未正式发布的Garbage First （G1）收集器，我们看到了一个个越来越优秀（也越来越复杂）的收集器的出现， 用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除（这里暂不包括RTSJ中 的收集器）。寻找更优秀的垃圾收集器的工作仍在继续！</p><p>  写到这里，笔者似乎已经把Serial收集器描述成一个老而无用，食之无味弃之可惜 的鸡肋了，但实际上到现在为止，它依然是虚拟机运行在Client模式下的默认新生代收 集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比）,对 于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收 集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理 的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的 内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫 秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial收集器对于运行在 Client模式下的虚拟机来说是一个很好的选择。</p><h2 id="4-2-ParNew-收集器"><a href="#4-2-ParNew-收集器" class="headerlink" title="4.2 ParNew 收集器"></a>4.2 ParNew 收集器</h2><p>ParNew收集器其实就是Serial收集器的多线程版本,除了使用多条线程进行垃圾 收集之外,其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure 等）、收集算法、Stop The World,对象分配规则、回收策略等都与Serial收集器完全一样，实现上这两种收集器也 共用了相当多的代码。ParNew收集器的工作过程如图3-7所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%886%EF%BC%89.png"></p><p>  ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之 处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器,其中有一个与 性能无关但很重要的原因是，除了 Serial收集器外，目前只有它能与CMS收集器配合工作。在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可称为有划时代意义 的垃圾收集器——CMS收集器（Concurrent Mark Sweep,本节稍后将详细介绍这款收集 器），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器， 它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，用前面那个例子的话 来说，就是做到了在你妈妈打扫房间的时候你还能同时往地上扔纸屑。</p><p>  不幸的是，它作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收 集器Parallel Scavenge配合工作。所以在JDK 1.5中使用CMS来收集老年代的时 候，新生代只能选择ParNew或Serial收集器中的一个。ParNew收集器也是使用-XX: WseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC 选项来强制指定它。</p><p>  ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之 百地保证能超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时 系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU 非常多（譬如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况 越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p><p>  注意从ParNew收集器开始，后面还将会接触到几款并发和并行的收集器。在大家可能 产生疑惑之前，有必要先解释两个名词：并发和并行。这两个名词都是并发编程中的概 念，在谈论垃圾收集器的上下文语境中，他们可以解释为：</p><ul><li>并行（Parallel）:指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续运行，而垃圾收集程序运行于另一个CPU上。</li></ul><h2 id="4-3-Parallel-Scavenge-收集器"><a href="#4-3-Parallel-Scavenge-收集器" class="headerlink" title="4.3 Parallel Scavenge 收集器"></a>4.3 Parallel Scavenge 收集器</h2><p>Parallel Scavenge收集器也是一个新生代收集器,它也是使用复制算法的收集器, 又是并行的多线程收集器……看上去和ParNew都一样，那它有什么特别之处呢？</p><p>  Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的 关注点尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目 标则是达到一个可控制的吞吐量(Throughput)。所谓吞吐量就是CPU用于运行用户代 码的时间与CPU总消耗时间的比值，即吞吐量&#x3D;运行用户代码时间&#x2F; (运行用户代码时 间+垃圾收集时间)，虚拟机总共运行了 100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><p>  停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体 验;而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适 合在后台运算而不需要太多交互的任务。</p><p>  Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制 最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数及直接设置吞吐量大小的 -XX:GCTimeRatio 参数。</p><p>  MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回 收花费的时间不超过设定值。不过大家不要异想天开地认为如果把这个参数的值设置得 稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和 新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB 快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100 毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也 降下来了。</p><p>  GCTimeRatio参数的值应当是一个大于0小于100的整数，也就是垃圾收集时间占 总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19,那允许的最大GC时 间就占总时间的5% (即1&#x2F; (1 + 19)),默认值为99,就是允许最大1% (即1 &#x2F; (1+99)) 的垃圾收集时间。</p><p>  由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称为“吞吐量 优先”收集器。除上述两个参数之外，Parallel Scavenge收集器还有一个参<br>_数_-XX：+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就 不需要手工指定新生代的大小（-Xmn）, Eden与Survivor E的比例（-XX:SurvivorRatio）、 晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当 前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或 最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics） 如果 读者对于收集器运作原理不太了解，手工优化存在困难的时候，使用Parallel Scavenge 收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个很 不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用 MaxGCPauseMillis参数（更关注最大停顿时间）或GCTimeRatio参数（更关注吞吐量） 给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调 节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p><h2 id="4-4-Serial-Old-收集器"><a href="#4-4-Serial-Old-收集器" class="headerlink" title="4.4 Serial Old 收集器"></a>4.4 Serial Old 收集器</h2><p>Serial Old是Serial 收集器的老年代版本,它同样是一个单线程收集器，使用“标 记-整理”算法。这个收集器的主要意义也是被Client模式下的虚拟机使用。如果 在Server模式下，它主要还有两大用途：一个是在JDK 1.5及之前的版本中与Parallel Scavenge收集器搭配使用气 另外一个就是作为CMS收集器的后备预案，在并发收集发 生Concurrent Mode Failure的时候使用。这两点都将在后面的内容中详细讲解。Serial Old收集器的工作过程如图3-8所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%887%EF%BC%89.png"></p><h2 id="4-5-Parallel-Old-收集器"><a href="#4-5-Parallel-Old-收集器" class="headerlink" title="4.5 Parallel Old 收集器"></a>4.5 Parallel Old 收集器</h2><p>Parallel Old_是_Parallel Scavenge收集器的老年代版本,使用多线程和“标记-整理” 算法。这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge 收集器一直处于比较尴尬的状态。原因是，如果新生代选择了 Parallel Scavenge收集器， 老年代除了 Serial Old (PS MarkSweep)收集器外别无选择(还记得上面说过Parallel Scavenge收集器无法与CMS收集器配合工作吗？)。由于单线程的老年代Serial Old收 集器在服务端应用性能上的’‘拖累”，即便使用了 Parallel Scavenge收集器也未必能在整 体应用上获得吞吐量最大化的效果,又因为老年代收集中无法充分利用服务器多CPU的 处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不…定 有ParNew加CMS的组合“给力”。</p><p>  直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应 用组合，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加 Parallel Old收集器。Parallel Old收集器的工作过程如图3-9所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%888%EF%BC%89.png"></p><h2 id="4-6-CMS收集器"><a href="#4-6-CMS收集器" class="headerlink" title="4.6 CMS收集器"></a>4.6 CMS收集器</h2><p>  CMS (Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收 集器。目前很大一部分的Java应用都集中在互联网站或B&#x2F;S系统的服务端上，这类应用 尤其重视服务的响应速度,希望系统停顿时间最短，以给用户帯来较好的体验。CMS收 集器就非常符合这类应用的需求。</p><p>  从名字(包含“Mark Sweep”)上就可以看出CMS收集器是基于“标记-清除”算法实现的,它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p><ul><li>初始标记(CMS initial mark)</li><li>并发标记(CMS concurrent mark)</li><li>重新标记(CMS remark)</li><li>并发清除（CMS concurrent sweep）</li></ul><p>  其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅 只是标记一下GC Roots能直接关联到的对象，速度很快,并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运 作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始 标记阶段稍长一些，但远比并发标记的时间短。</p><p>  由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。通过图3-10可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间。</p><p>  <img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%889%EF%BC%89.png"></p><p>  CMS是一款优秀的收集器，它的最主要优点在名字上已经体现出来了 :并发收集、 低停顿，Sun的一些官方文档里面也称之为并发低停顿收集器（Concurrent Low Pause Collector）。但是CMS还远达不到完美的程度，它有以下三个显著的缺点：</p><ul><li><p>CMS收集器对CPU资源非常敏感。其实，面向并发设计的程序都对CPU资源比 较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启 动的回收线程数是（CPU数量+3）&#x2F;4,也就是当CPU在4个以上时，并发回收 时垃圾收集线程最多占用不超过25%的CPU资源。但是当CPU不足4个时（譬 如2个），那么CMS对用户程序的影响就可能变得很大，如果CPU负载本来就 比较大的时候，还分出一半的运算能力去执行收集器线程，就可能导致用户程序 的执行速度忽然降低了 50%,这也很让人受不了。为了解决这种情况，虚拟机提 供了一种称为“增量式并发收集器”(Incremental Concurrent Mark Sweep &#x2F; i-CMS) 的CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模 拟多任务机制的思想一样，就是在并发标记和并发清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些,速度下降也就没有那么明显，但是目前版本中，i-CMS已经被声明为“deprecated”，即不再提倡用户使用。</p></li><li><p>CMS收集器无法处理浮动垃圾(Floating Garbage),可能出现”Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在 标记过程之后，CMS无法在本次收集中处理掉它们，只好留待下一次GC时再将 其清理掉。这一部分垃圾就称为“浮动垃圾”，也是由于在垃圾收集阶段用户线 程还需要运行，即还需要预留足够的内存空间给用户线程使用，因此CMS收集 器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一 部分空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代 使用了 68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代 增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来 提高触发百分比，以便降低内存回收次数以获取更好的性能。要是CMS运行期 间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败,这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置得太高将会很容易导致大最Concurrent Mode Failure”失败，性能反而降低。</p></li><li><p>还有最后一个缺点，在本节在开头说过，CMS是款基于“标记-清除”算法实 现的收集器，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着 收集结束时会产生大量空间碎片。空间碎片过多时，将会给大对象分配带来很大 的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空 间来分配当前对象，不得不提前触发一次Full GC.为了解决这个问题，CMS收 集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享 受”完Full GC服务之后额外免费附送一个碎片整理过程，内存整理的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者们还 提供了另外一个参数-XX: CMSFullGCsBeforeCompaction,这个参数用于设置在 执行多少次不压缩的Full GC后，跟着来一次带压缩的。</p></li></ul><h2 id="4-7-G1收集器"><a href="#4-7-G1收集器" class="headerlink" title="4.7 G1收集器"></a>4.7 G1收集器</h2><p>G1 (Garbage First)收集器是当前收集器技术发展的最前沿成果，在JDK 1.6_ Update”中提供了 Early Access版本的G1收集器以供试用。在将来JDK 1.7正式发布 的时候，G1收集器很可能会有一个成熟的商用版本随之发布。这里只对G1收集器进行 简单介绍。</p><p>  G1收集器是垃圾收集器理论进一步发展的产物，它与前面的CMS收集器相比有两 个显著的改进:一是G1收集器是基于“标记-整理”算法实现的收集器，也就是说它 不会产生空间碎片，这对于长时间运行的应用系统来说非常重要。二是它可以非常精确 地控制停顿，既能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收 集上的时间不得超过N毫秒,这几乎已经是实时Java (RTSJ)的垃圾收集器的特征了。</p><p>  G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收，这是由于 它能够极力地避免全区域的垃圾收集，之前的收集器进行收集的范围都是整个新生代或 老年代，而G1将整个Java堆(包括新生代、老年代)划分为多个大小固定的独立区域 (Region),并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根 据允许的收集时间，优先回收垃圾最多的区域(这就是Garbage First名称的来由)。区 域划分及有优先级的区域回收，保证了 G1收集器在有限的时间内可以获得最高的收集 效率。</p><h2 id="4-8-垃圾收集器参数总结"><a href="#4-8-垃圾收集器参数总结" class="headerlink" title="4.8 垃圾收集器参数总结"></a>4.8 垃圾收集器参数总结</h2><p>JDK 1.6中的各种垃圾收集器到此已全部介绍完毕，在描述过程中提到了很多虚拟机非稳定的运行参数，表3-1整理了这些参数以供读者实践时参考。</p><p><img src="https://image.buretuzi.online/blog/article/jvm/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)%EF%BC%8810%EF%BC%89.png"></p><h1 id="5-内存分配与回收策略"><a href="#5-内存分配与回收策略" class="headerlink" title="5. 内存分配与回收策略"></a>5. 内存分配与回收策略</h1><p>Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题： 给对象分配内存以及回收分配给对象的内存。关于回收内存这一点，我们已经使用了大量的篇幅去介绍虚拟机中的垃圾收集器体系及其运作原理，现在我们再一起来探讨一下 给对象分配内存的那点事儿。</p><p>  对象的内存分配，往大方向上讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配。），对象主要分配在新生代的Eden区上，如果启动 了本地线程分配缓冲，将按线程优先在TLAB±分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p><p>  接下来我们将会讲解几条最普遍的内存分配规则，并通过代码去验证这些规则。本节中的代码在测试时使用Client模式虚拟机运行，没有手工指定收集器组合，换句话 说，验证的是使用Serial &#x2F; Serial Old收集器下（ParNew &#x2F; Serial Old收集器组合的规则 也基本一致）的内存分配和回收的策略。读者不妨根据自己项目中使用的收集器写一些 程序去验证一下使用其他几种收集器的内存分配策略。</p><h2 id="5-1-对象优先在Eden分配"><a href="#5-1-对象优先在Eden分配" class="headerlink" title="5.1 对象优先在Eden分配"></a>5.1 对象优先在Eden分配</h2><p>  大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配 时，虚拟机将发起一次Minor GC</p><p>  虚拟机提供了 -XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前内存各区域的分配情况。在实际应用中，内存回收日志一般是打印到文件后通过日志工具进行分析，不过本实验的日志并不多，直接阅读就能看得很清楚。</p><p>  代码清单3-3的testAllocation。方法中，尝试分配3个2MB大小和1个4MB 大小的对象，在运行时通过-Xms20M、-Xmx20M和-Xmn10M这3个参数限制Java 堆大小为20MB,且不可扩展，其中10MB分配给新生代，剩下的10MB分配给老 年代。-XX:SurvivorRatio&#x3D;8决定了新生代中Eden区与一个Survivor区的空间比例 是8比1,从输出的结果也能清晰地看到“eden space 8192K、from space 1024K、to space 1024K”的信息，新生代总可用空间为9216KB （Eden区+1个Survivor g的总 容量）。</p><p>  执行testAllocation()中分配allocation4对象的语句时会发生一次Minor GC,这次GC的结果是新生代6945KB变为1021KB,而总内存占用量则几乎没有减少（因为 allocations 2、3三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。这次GC 发生的原因是给allocation4分配内存的时候，发现Eden已经被占用了 6MB,剩余空间 已不足以分配allocation4所需的4MB内存，因此发生Minor GC。 GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（Survivor空间只有1MB大小），所以只好通过分配担保机制提前转移到老年代去。</p><p>  这次GC结束后，4MB的allocation，对象被顺利分配在Eden中。因此程序执行完 的结果是Eden占用4MB （被allocation4占用），Survivor空闲，老年代被占用6MB （被 allocation Is 2、3占用）。通过GC日志可以证实这一点。</p><ul><li>新生代GC （Minor GC）:指发生在新生代的垃圾收集动作，因为Java对象大多都具 备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li><li>老年代GC （Major GC &#x2F; Full GC）:指发生在老年代的GC,出现了 Major GC,经常 会伴随至少一次的Minor GC （但非绝对的，在ParallelScavenge收集器的收集策略里 就有直接进行Major GC的策略选择过程）。MajorGC的速度一般会比Minor GC慢10 倍以上。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"><span class="comment">// vm参数 -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        FinalizeEscapeGC.testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行结果:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 6945K-&gt;1021K(9216K)] 6945K-&gt;3674K(19456K), 0.0019542 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 5440K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 8192K, 53% used [0x00000000ff600000,0x00000000ffa50ed8,0x00000000ffe00000)</span><br><span class="line">  from space 1024K, 99% used [0x00000000ffe00000,0x00000000ffeff520,0x00000000fff00000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 10240K, used 6748K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  object space 10240K, 65% used [0x00000000fec00000,0x00000000ff297348,0x00000000ff600000)</span><br><span class="line"> Metaspace       used 3332K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 358K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><h2 id="5-2-大对象直接进入老年代"><a href="#5-2-大对象直接进入老年代" class="headerlink" title="5.2 大对象直接进入老年代"></a>5.2 大对象直接进入老年代</h2><p>所谓大对象就是指，需要大量连续内存空间的Java对象,最典型的大对象就是那种很 长的字符串及数组（笔者例子中的byte[]数组就是典型的大对象）。大对象对虚拟机的内存 分配来说就是一个坏消息（替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是 遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），经常出现大对象容易 导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来”安置”它们。</p><p>  虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接 在老年代中分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内 存拷贝（复习一下:新生代采用复制算法收集内存）。</p><p>  执行代码清单3-4中的testPretenureSizeThreshold（）方法后，我们看到老年代10MB的空间被使用了 40%,也就是4MB的allocation 对象直接就分配在老年代中，这是因为PretenureSizeThreshold被设置为3MB （就是 3145728B,这个参数不能与-Xmx之类的参数一样直接写3MB）,因此超过3MB的对 象都会直接在老年代中进行分配。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"><span class="comment">//vm参数： -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPretenured</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation;</span><br><span class="line">        allocation = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        FinalizeEscapeGC.testPretenured();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 4893K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 8192K, <span class="number">59</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffac76b8</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line"> ParOldGen       total 10240K, used 4096K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  object space 10240K, <span class="number">40</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff000010</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"> Metaspace       used 3189K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 343K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="5-3-长期存活的对象将进入老年代"><a href="#5-3-长期存活的对象将进入老年代" class="headerlink" title="5.3 长期存活的对象将进入老年代"></a>5.3 长期存活的对象将进入老年代</h2><p>  虚拟机既然采用了分代收集的思想来管理内存，那内存回收时就必须能识别哪些对 象应当放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义 了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然 存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。 对象在Survivor区中每熬过一次Minor GC,年龄就增加1岁，当它的年龄增加到一定 程度（默认为15岁）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过MaxTenuringThreshold&#x3D; 15的参数设置。</p><p>  可以试试分别以MaxTenuringThreshold&#x3D; 1 和MaxTenuringThreshold&#x3D; 15，此方法中对象需要256KB的内存空间，Survivor空间可以容纳。当MaxTenuringThreshold&#x3D;1 时，allocationl对象在第二次GC发生时进入老年代，新生代已使用的内存GC后 会非常干净地变成0KB。而MaxTenuringThreshold&#x3D;15时，第二次GC发生后， allocationl对象则还留在新生代Survivor空间，这时候新生代仍然有404KB的空间被占用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line"><span class="comment">//vm配置 -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:MaxTenuringThreshold=1</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="literal">null</span>;</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        FinalizeEscapeGC.testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以MaxTenuringThreshold&#x3D; 1 的参数设置来运行的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 5153K-&gt;1021K(9216K)] 13345K-&gt;10054K(19456K), <span class="number">0.0016619</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 1021K-&gt;0K(9216K)] [ParOldGen: 9032K-&gt;5879K(10240K)] 10054K-&gt;5879K(19456K), [Metaspace: 3309K-&gt;3309K(1056768K)], <span class="number">0.0058565</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 4262K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 8192K, <span class="number">52</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffa29b48</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 10240K, used 5879K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  object space 10240K, <span class="number">57</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff1bdf00</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"> Metaspace       used 3333K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 358K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>以MaxTenuringThreshold&#x3D; 15的参数设置来运行的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 5153K-&gt;1021K(9216K)] 13345K-&gt;10036K(19456K), <span class="number">0.0019170</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 1021K-&gt;0K(9216K)] [ParOldGen: 9015K-&gt;5879K(10240K)] 10036K-&gt;5879K(19456K), [Metaspace: 3310K-&gt;3310K(1056768K)], <span class="number">0.0058862</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 4178K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 8192K, <span class="number">51</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffa14930</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 10240K, used 5879K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  object space 10240K, <span class="number">57</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff1bdf00</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"> Metaspace       used 3317K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 356K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><h2 id="5-4-动态对象年龄判定"><a href="#5-4-动态对象年龄判定" class="headerlink" title="5.4 动态对象年龄判定"></a>5.4 动态对象年龄判定</h2><p>  为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到 MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小 的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><p>  执行代码清单3-6中的testTenuringThreshold2()方法，并设置参数-XX: MaxTenuringThreshold&#x3D;15,会发现运行结果中Survivor的空间占用仍然为0%,而老年 代比预期增加了 6%,也就是说allocation1, allocation2对象都直接进入了老年代，而没 有等到15岁的临界年龄。因为这两个对象加起来已经达到了 512KB,并且它们是同年 的，满足同年对象达到Survivor空间的一半规则。我们只要注释掉其中一个对象的new 操作，就会发现另外一个不会晋升到老年代中去了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="literal">null</span>;</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        FinalizeEscapeGC.testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 5409K-&gt;992K(9216K)] 13601K-&gt;10298K(19456K), <span class="number">0.0023467</span> secs] [Times: user=<span class="number">0.06</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 992K-&gt;0K(9216K)] [ParOldGen: 9306K-&gt;6159K(10240K)] 10298K-&gt;6159K(19456K), [Metaspace: 3322K-&gt;3322K(1056768K)], <span class="number">0.0068674</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 4178K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 8192K, <span class="number">51</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffa14930</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 10240K, used 6159K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  object space 10240K, <span class="number">60</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff203f80</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"> Metaspace       used 3331K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 358K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="5-5-空间分配担保"><a href="#5-5-空间分配担保" class="headerlink" title="5.5 空间分配担保"></a>5.5 空间分配担保</h2><p>  在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于 老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则査看 HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC ；如果不允许，则也要改为进行一次Full GC。</p><p>  前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个 Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况时 (最极端就是内存回收后新生代中所有对象都存活)，就需要老年代进行分配担保，让 Survivor无法容纳的对象直接进入老年代。与生活中的贷款担保类似，老年代要进行这 样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下 来，在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老 年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行 Full GC来让老年代腾出更多空间。</p><p>  取平均值进行比较其实仍然是一种动态概率的手段，也就是说如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败(Handle Promotion Failure)»如果出现了 HandlePromotionFailure失败，那就只好在失败后 重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还 是会将HandlePromotionFailure开关打开，避免Full GC过于频繁</p><p>  HandlePromotionFailure &#x3D; false参数和MaxTenuringThreshold&#x3D; true在JDK8及以后不再支持</p><h2 id="5-6-本章小结"><a href="#5-6-本章小结" class="headerlink" title="5.6 本章小结"></a>5.6 本章小结</h2><p>  本章介绍了垃圾收集的算法、几款JDK 1.6中提供的垃圾收集器特点及其运作原理。 通过代码实例验证了 Java虚拟机中自动内存分配及回收的主要规则。</p><p>  内存回收与垃圾收集器在很多时候都是影响系统性能、并发能力的主要因素之 一，虚拟机之所以提供多种不同的收集器及大量的调节参数，是因为只有根据实际应 用需求、实现方式选择最优的收集方式才能获取最好的性能。没有固定收集器、参数组合，也没有最优的调优方法，虚拟机也没有什么必然的内存回收行为。因此学习虚拟机内存知识，如果要到实践调优阶段，必须了解每个具体收集器的行为、优势和劣势、调节参数。在接下来的两章中，作者将会介绍内存分析的工具和调优的一些具体案例。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="http://blog.buretuzi.online">李文若</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="http://blog.buretuzi.online/2022/08/18/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)/">http://blog.buretuzi.online/2022/08/18/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5(2)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.buretuzi.online" target="_blank">清河水温龙井茶</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="addtoany"><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_wechat"></a><a class="a2a_button_sina_weibo"></a><a class="a2a_button_facebook_messenger"></a><a class="a2a_button_email"></a><a class="a2a_button_copy_link"></a><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a></div></div><script async src="https://static.addtoany.com/menu/page.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)/"><img class="prev-cover" src="https://image.buretuzi.online/blog/article/article-background/wallhaven-x61vml.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM虚拟机性能监控与故障处理工具(3)</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/17/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8(1)/"><img class="next-cover" src="https://image.buretuzi.online/blog/article/article-background/wallhaven-zyxrkv.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM内存区域与内存溢出异常(1)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/08/17/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8(1)/" title="JVM内存区域与内存溢出异常(1)"><img class="cover" src="https://image.buretuzi.online/blog/article/article-background/wallhaven-zyxrkv.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-17</div><div class="title">JVM内存区域与内存溢出异常(1)</div></div></a></div><div><a href="/2022/08/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7(3)/" title="JVM虚拟机性能监控与故障处理工具(3)"><img class="cover" src="https://image.buretuzi.online/blog/article/article-background/wallhaven-x61vml.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-18</div><div class="title">JVM虚拟机性能监控与故障处理工具(3)</div></div></a></div><div><a href="/2022/08/18/JVM%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90(4)/" title="JVM调优案例分析(4)"><img class="cover" src="https://image.buretuzi.online/blog/article/article-background/wallhaven-zyxe8j.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-18</div><div class="title">JVM调优案例分析(4)</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">李文若</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/luaby"><i class="fab fa-github"></i><span>My GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/luaby" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:liwenruo87@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Doro喜欢吃 欧润吉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E5%B7%B3%E6%AD%BB%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2. 对象巳死？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 引用计数算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 根搜索算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 再谈引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 生存还是死亡？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 回收方法区</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">3. 垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 标记-清除算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 复制算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 标记-整理算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">4.垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 Serial 收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 ParNew 收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 Parallel Scavenge 收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 Serial Old 收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 Parallel Old 收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 CMS收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 G1收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93"><span class="toc-number">4.8.</span> <span class="toc-text">4.8 垃圾收集器参数总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">5.</span> <span class="toc-text">5. 内存分配与回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8Eden%E5%88%86%E9%85%8D"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 对象优先在Eden分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 大对象直接进入老年代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 长期存活的对象将进入老年代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 动态对象年龄判定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 空间分配担保</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 本章小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/13/exe%E6%B3%A8%E5%86%8C%E4%B8%BAwindows%E6%9C%8D%E5%8A%A1/" title="exe注册为windows服务"><img src="https://image.buretuzi.online/blog/article/article-background/wallhaven-2yed86.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="exe注册为windows服务"></a><div class="content"><a class="title" href="/2025/05/13/exe%E6%B3%A8%E5%86%8C%E4%B8%BAwindows%E6%9C%8D%E5%8A%A1/" title="exe注册为windows服务">exe注册为windows服务</a><time datetime="2025-05-13T17:06:18.000Z" title="发表于 2025-05-13 17:06:18">2025-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/13/UE4_2_operation/" title="2.UE4物体移动"><img src="https://image.buretuzi.online/ue4/095223-6245095744c07.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="2.UE4物体移动"></a><div class="content"><a class="title" href="/2025/04/13/UE4_2_operation/" title="2.UE4物体移动">2.UE4物体移动</a><time datetime="2025-04-13T10:16:00.000Z" title="发表于 2025-04-13 10:16:00">2025-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/11/UE4_1_operation/" title="1.UE4基础操作"><img src="https://image.buretuzi.online/ue4/095223-6245095744c07.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="1.UE4基础操作"></a><div class="content"><a class="title" href="/2025/04/11/UE4_1_operation/" title="1.UE4基础操作">1.UE4基础操作</a><time datetime="2025-04-11T22:16:00.000Z" title="发表于 2025-04-11 22:16:00">2025-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/10/Linux%20%E6%90%AD%E5%BB%BAKMS/" title="Linux 搭建KMS"><img src="https://image.buretuzi.online/blog/article/article-background/wallhaven-x61vml.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Linux 搭建KMS"></a><div class="content"><a class="title" href="/2023/11/10/Linux%20%E6%90%AD%E5%BB%BAKMS/" title="Linux 搭建KMS">Linux 搭建KMS</a><time datetime="2023-11-10T10:43:12.000Z" title="发表于 2023-11-10 10:43:12">2023-11-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/10/Linux%20%E6%90%AD%E5%BB%BAOpenVPN/" title="Linux 搭建OpenVPN"><img src="https://image.buretuzi.online/blog/article/article-background/wallhaven-x61vml.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Linux 搭建OpenVPN"></a><div class="content"><a class="title" href="/2023/11/10/Linux%20%E6%90%AD%E5%BB%BAOpenVPN/" title="Linux 搭建OpenVPN">Linux 搭建OpenVPN</a><time datetime="2023-11-10T10:43:12.000Z" title="发表于 2023-11-10 10:43:12">2023-11-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer_deal"><a class="deal_link" href="" title="mail"><i class="iconfont icon-17"></i></a><a class="deal_link" href="" title="qq" target="_blank"><i class="iconfont icon-qq"></i></a><a class="deal_link" href="" title="CSDN" target="_blank"><i class="iconfont icon-csdn"></i></a><a class="deal_link" href="https://github.com/luaby" title="github" target="_blank"><i class="iconfont icon-github"></i></a><img class="footer_mini_logo entered loading" style="border-radius:50%" src="/img/彩虹.png" onclick="btf.scrollToDest(0,500)" title="返回顶部"><a class="deal_link" href="" title="QQ空间"><i class="iconfont icon-qzone"></i></a><a class="deal_link" href="" title="微信" target="_blank"><i class="iconfont icon-wechat"></i></a><a class="deal_link" href="" title="Twitter" target="_blank"><i class="iconfont icon-twitter"></i></a><a class="deal_link" href="" title="Telegram" target="_blank"><i class="iconfont icon-fasong"></i></a></div><div id="Jay-footer"><div class="footer-group"><h3 class="footer-title">直达</h3><div class="footer-links"><a class="footer-item" href="" target="_blank">我的主页</a><a class="footer-item" href="">音乐欣赏</a><a class="footer-item" href="">心灵港湾</a><a class="footer-item" href="">随机文章</a></div></div><div class="footer-group"><h3 class="footer-title">分类</h3><div class="footer-links"><a class="footer-item" href="">学习笔记</a><a class="footer-item" href="">魔改教程</a><a class="footer-item" href="">算法笔记</a><a class="footer-item" href="">语法教程</a></div></div><div class="footer-group"><h3 class="footer-title">关于</h3><div class="footer-links"><a class="footer-item" href="/about/">关于我</a><a class="footer-item" href="">博客统计</a><a class="footer-item" href="/archives/">文章归档</a><a class="footer-item" href="">更新记录</a></div></div><div class="footer-group"><h3 class="footer-title">友链</h3><div class="footer-links" id="friend-links-in-footer"><a class="footer-item" target="_blank" rel="noopener" href="https://anzhiy.cn/">安知鱼</a><a class="footer-item" target="_blank" rel="noopener" href="https://www.chuckle.top">轻笑Chuckle</a><a class="footer-item" target="_blank" rel="noopener" href="https://akilar.top/">Akilarの糖果屋</a><a class="footer-item" target="_blank" rel="noopener" href="https://yisous.xyz">Ariasaka</a></div></div><div class="footer-group"><h3 class="footer-title">协议</h3><div class="footer-links"><a class="footer-item" href="">隐私协议</a><a class="footer-item" href="">Cookie</a><a class="footer-item" href="">版权协议</a></div></div></div><!--#footer-banner--><!--        #footer-banner-tips--><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()">播放音乐</div><meting-js id="8703296584" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="iconfont icon-baidu"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-music"><a class="rightMenu-item" id="menu-music-play" href="javascript:anzhiyu.musicToggle()"><i class="fas fa-play"></i><span>播放音乐</span></a><a class="rightMenu-item" id="menu-music-pause" href="javascript:anzhiyu.musicToggle()"><i class="fa-solid fa-pause"></i><span>暂停音乐</span></a><a class="rightMenu-item" href="javascript:anzhiyu.musicSkipBack()"><i class="fas fa-backward"></i><span>切换到上一首</span></a><a class="rightMenu-item" href="javascript:anzhiyu.musicSkipForward()"><i class="fas fa-forward"></i><span>切换到下一首</span></a><a class="rightMenu-item" target="_blank" rel="noopener" href="https://y.qq.com/n/ryqq/playlist/8703296584"><i class="fas fa-radio"></i><span>查看歌单</span></a><a class="rightMenu-item" href="javascript:anzhiyu.musicGetSingName()"><i class="fas fa-copy"></i><span>复制歌名</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="./#post-comment"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line" id="common"><a class="rightMenu-item" href="javascript:toRandomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.translate();"><i class="iconfont icon-fanti"></i><span>繁简转换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="javascript:window.location.href=&quot;/about/&quot;;"><i class="fa fa-info-circle"></i><span>版权声明</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/pluginsSrc/instant.page/instantpage.js" type="module"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.buretuzi.online/",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null))},t=()=>{"object"!=typeof twikoo?getScript("/pluginsSrc/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script><script>function loadValine(){function n(){new Valine(Object.assign({el:"#vcomment",appId:"0onZJ2E9cHeXWot3kJWDdrfM-gzGzoHsz",appKey:"ghd4PqqDJfdNbcH3JZEGwl4A",avatar:"mp",serverURLs:"",emojiMaps:"",path:window.location.pathname,visitor:!0}))}"function"==typeof Valine?n():getScript("/pluginsSrc/valine/dist/Valine.min.js").then(n)}{function loadOtherComment(){loadValine()}setTimeout(loadValine,0)}</script></div><div class="aplayer no-destroy" data-id="1708664797" data-server="tencent" data-type="playlist" data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true"></div><script src="/js/cursor.js"></script><script src="/js/sakura.js"></script><script src="/js/Progressbar.js"></script><script async data-pjax src="/js/navigation.js"></script><script src="/js/jquery.min.js"></script><script src="/js/rightmenu.js"></script><script src="/js/title.js"></script><script src="/js/player/anzhiyu.js"></script><script src="/js/player/anzhiyufunction.js"></script><script src="/js/winbox.bundle.min.js"></script><canvas class="fireworks" mobile="true"></canvas><script src="/pluginsSrc/butterfly-extsrc/dist/fireworks.min.js"></script><script defer id="fluttering_ribbon" mobile="true" src="/pluginsSrc/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="/pluginsSrc/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="/css/player/APlayer.min.css" media="print" onload='this.media="all"'><script src="/js/player/APlayer.min.js"></script><script src="/js/player/Meting2.min.js"></script><script src="/pluginsSrc/pjax/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script></div><div class="contact-info"><div class="option"><i class="fas fa-heart"></i><div class="bloktop"></div><div class="text">或许不该心动<div class="strip"></div></div></div><div class="option"><i class="fas fa-commenting"></i><div class="blok"></div><div class="text">要和我说悄悄话吗？<div class="strip"></div></div></div><div class="option"><i class="fas fa-hourglass-2"></i><div class="blokbottom"></div><div class="text">人生匆匆，何必拘泥过往<div class="strip"></div></div></div></div><script data-pjax>function butterfly_categories_card_injector_config(){var a=document.getElementById("recent-posts");console.log("已挂载butterfly_categories_card"),a.insertAdjacentHTML("afterbegin",'<style>li.categoryBar-list-item{width:24%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(/img/1.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/java/&quot;);" href="javascript:void(0);">java</a><span class="categoryBar-list-count">41</span><span class="categoryBar-list-descr">技术</span></li><li class="categoryBar-list-item" style="background:url(/img/2.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/windows/&quot;);" href="javascript:void(0);">windows</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(/img/3.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Linux/&quot;);" href="javascript:void(0);">Linux</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(/img/4.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/UE4/&quot;);" href="javascript:void(0);">UE4</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li></ul></div></div>')}document.getElementById("recent-posts")&&"/"===location.pathname&&butterfly_categories_card_injector_config()</script><script data-pjax>function butterfly_clock_anzhiyu_injector_config(){var e=document.getElementById("card-widget");console.log("已挂载butterfly_clock_anzhiyu"),e&&e.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="/img/clock.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",qweather_key="077e8d0195484e3a81fdbc5082aab008",gaud_map_key="af81a9f393f79a52e1deb75a2109d705",baidu_ak_key="undefined",flag=0,clock_rectangle="112.982279,28.19409",clock_default_rectangle_enable="false",i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_clock_anzhiyu_injector_config()</script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="/js/clock.min.js"></script><script data-pjax>function butterfly_footer_beautify_injector_config(){var t=document.getElementById("footer-wrap");console.log("已挂载butterfly_footer_beautify"),t.insertAdjacentHTML("beforeend",'<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="/img/footer/frame.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src="/img/footer/theme.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com" style="margin-inline:5px" data-title="本站使用Vercel作为静态托管平台" title=""><img src="/img/footer/host.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20229936" style="margin-inline:5px" data-title="本站已在萌进行备案" title=""><img src="/img/footer/萌备案.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn" style="margin-inline:5px" data-title="本站已在豫进行备案" title=""><img src="/img/footer/豫备案.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.upyun.com/" style="margin-inline:5px" data-title="本站使用又拍云为静态资源提供CDN加速" title=""><img src="/img/footer/cdn.svg" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="/img/footer/copyright.svg" alt=""/></a></p>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_footer_beautify_injector_config()</script><script data-pjax>function butterfly_swiper_injector_config(){var i=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),i.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/07/17/异常处理- SpringBoot（11）/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://image.buretuzi.online/blog/article/article-background/wallhaven-3zj6l9.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-07-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/07/17/异常处理- SpringBoot（11）/&quot;);" href="javascript:void(0);" alt="">异常处理- SpringBoot（11）</a><div class="blog-slider__text">你会爱我吗？</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/07/17/异常处理- SpringBoot（11）/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/08/18/java垃圾收集器与内存分配策略(2)/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/img/1.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/08/18/java垃圾收集器与内存分配策略(2)/&quot;);" href="javascript:void(0);" alt="">java垃圾收集器与内存分配策略(2)</a><div class="blog-slider__text">好吧就这样吧</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/08/18/java垃圾收集器与内存分配策略(2)/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="/js/swiper/swiper.min.js"></script><script defer data-pjax src="/js/swiper/swiper_init.js"></script></body></html>