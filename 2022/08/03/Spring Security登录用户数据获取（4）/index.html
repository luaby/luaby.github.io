<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Spring Security登录用户数据获取（4） | 清河水温龙井茶</title><meta name="author" content="李文若"><meta name="copyright" content="李文若"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 登录用户数据获取  登录成功之后，在后续的业务逻辑中，开发者可能还需要获取登录成功的用户对象，如果不使用任何安全管理框架，那么可以将用户信息保存在httpsSession中，以后需要的时候直接从httpsSession中获取数据。在Spring Security中，用户登录信息本质上还是保存在 httpsSession中，但是为了方便使用，Spring Security对httpsSessi"><meta property="og:type" content="article"><meta property="og:title" content="Spring Security登录用户数据获取（4）"><meta property="og:url" content="http://blog.buretuzi.online/2022/08/03/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89/index.html"><meta property="og:site_name" content="清河水温龙井茶"><meta property="og:description" content="1. 登录用户数据获取  登录成功之后，在后续的业务逻辑中，开发者可能还需要获取登录成功的用户对象，如果不使用任何安全管理框架，那么可以将用户信息保存在httpsSession中，以后需要的时候直接从httpsSession中获取数据。在Spring Security中，用户登录信息本质上还是保存在 httpsSession中，但是为了方便使用，Spring Security对httpsSessi"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://image.buretuzi.online/blog/article/article-background/wallhaven-j8qjpq.jpg"><meta property="article:published_time" content="2022-08-03T00:07:00.000Z"><meta property="article:modified_time" content="2025-05-13T09:14:30.668Z"><meta property="article:author" content="李文若"><meta property="article:tag" content="Spring Security"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://image.buretuzi.online/blog/article/article-background/wallhaven-j8qjpq.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.buretuzi.online/2022/08/03/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"top-right"},source:{justifiedGallery:{js:"/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js",css:"/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Spring Security登录用户数据获取（4）",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-05-13 09:14:30"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/mouseMove.css"><link rel="stylesheet" href="/css/navigation.css"><link rel="stylesheet" href="/css/Scrollbar.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/rightmenu.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/Progressbar.css"><link rel="stylesheet" href="/css/footer.css"><link rel="stylesheet" href="/css/footerIcon/iconfont.css"><script rel="stylesheet" href="/css/footerIcon/iconfont.js"></script><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/doublecolumn.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/player/aplayer.css"><link rel="stylesheet" href="/css/leftMenu.css"><link rel="stylesheet" href="/css/twikoo_beautify.css"><link rel="stylesheet" href="/css/about.css"><script defer charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script defer src="https://sdk.51.la/perf/js-sdk-perf.min.js" crossorigin="anonymous"></script><script defer src="/js/51La.js"></script><link rel="stylesheet" href="/css/categorybar.css"><link rel="stylesheet" href="https://image.buretuzi.online/blog/article/document/clock.min.css"><link rel="stylesheet" href="https://image.buretuzi.online/blog/article/document/runtime.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/css/swiper/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/css/swiper/swiperstyle.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",(()=>{preloader.endLoading()})),document.addEventListener("pjax:send",(()=>{preloader.initLoading()})),document.addEventListener("pjax:complete",(()=>{preloader.endLoading()}))</script><link rel="stylesheet" href="/css/Progressbar.css"><script src="/pluginsSrc/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i> <span>日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i> <span>菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i> <span>关于</span></a></li><li><a class="site-page child" href="/myself/"><i class="fa-fw fa fa-id-card"></i> <span>关于我</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/luaby"><i class="fa-fw fa fa-heart"></i> <span>butterfly</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><div class="back-home-button" tabindex="-1"><i class="back-home-button-icon fas fa-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.cnblogs.com/liwenruo/" title="前往博客主页" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src="data:image/png;base64,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"><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" href="http://buretuzi.online" rel="external nofollow" title="前往云盘主页" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src="data:image/png;base64,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"><span class="back-menu-item-text">我的社区</span></a></div></div></div></div><a id="site-name" href="/"><div class="title">清河水温龙井茶</div><i class="fa-solid fa-house"></i></a></span><div class="mask-name-container"><center id="name-container"><a id="page-name" href="javascript:rmf.scrollToTop()">PAGE_NAME</a></center></div><div id="menus"><div class="nav-button" id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" type="button" title="切换背景" onclick="toggleWinbox()"><i class="fas fa-image"></i></a></div><div class="nav-button" id="darkmode_navswitch"><a class="darkmode_switchbutton" type="button" title="浅色和深色模式转换" onclick="rmf.switchDarkMode()"><i class="fas fa-adjust"></i></a></div><div class="nav-button" id="nav-totop"><a class="totopbtn"><i class="fas fa-arrow-up"></i><span id="percent" onclick="btf.scrollToDest(0,500)">0</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i> <span>日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i> <span>菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i> <span>关于</span></a></li><li><a class="site-page child" href="/myself/"><i class="fa-fw fa fa-id-card"></i> <span>关于我</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/luaby"><i class="fa-fw fa fa-heart"></i> <span>butterfly</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Spring Security登录用户数据获取（4）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-03T00:07:00.000Z" title="发表于 2022-08-03 00:07:00">2022-08-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-13T09:14:30.668Z" title="更新于 2025-05-13 09:14:30">2025-05-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title="Spring Security登录用户数据获取（4）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="1-登录用户数据获取"><a href="#1-登录用户数据获取" class="headerlink" title="1. 登录用户数据获取"></a>1. 登录用户数据获取</h1><p>  登录成功之后，在后续的业务逻辑中，开发者可能还需要获取登录成功的用户对象，如果不使用任何安全管理框架，那么可以将用户信息保存在httpsSession中，以后需要的时候直接从httpsSession中获取数据。在Spring Security中，用户登录信息本质上还是保存在 httpsSession中，但是为了方便使用，Spring Security对httpsSession中的用户信息进行了封装， 封装之后，开发者若再想获取用户登录数据就会有两种不同的思路：</p><ul><li>从 SecurityContextHolder 中获取</li><li>从当前请求对象中获取。</li></ul><p>这里列出来的两种方式是主流的做法，开发者也可以使用一些非主流的方式获取登录成功后的用户信息，例如直接从httpsSession中获取用户登录数据，</p><p>无论是哪种获取方式，都离不开一个重要的对象：Authentication。在Spring Security中， Authentication对象主要有两方面的功能：</p><ul><li>作为AuthenticationManager的输入参数，提供用户身份认证的凭证，当它作为一个 输入参数时，它的isAuthenticated方法返回false,表示用户还未认证。</li><li>代表已经经过身份认证的用户，此时的Authentication可以从SecurityContext中获取。</li></ul><p>一个Authentication对象主要包含三个方面的信息:</p><ul><li>principal: 定义认证的用户。如果用户使用用户名&#x2F;密码的方式登录，principal通常就是一个UserDetails对象。</li><li>credentials：登录凭证，一般就是指密码。当用户登录成功之后，登录凭证会被自动擦除，以防止泄漏。</li><li>authorities：用户被授予的权限信息。</li></ul><p>  Java中本身提供了 Principal接口用来描述认证主体，Principal可以代表一个公司、个人或者登录ID，Spring Security中定义了 Authentication接口用来规范登录用户信息， Authentication 继承自 Principal：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Authentication</span> <span class="keyword">extends</span> <span class="title class_">Principal</span>, Serializable &#123;</span><br><span class="line">	Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line">	Object <span class="title function_">getCredentials</span><span class="params">()</span>;</span><br><span class="line">	Object <span class="title function_">getDetails</span><span class="params">()</span>;</span><br><span class="line">	Object <span class="title function_">getPrincipal</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">isAuthenticated</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">setAuthenticated</span><span class="params">(<span class="type">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里接口中定义的方法都很好理解：</p><ul><li>getAuthorities方法：用来获取用户权限。</li><li>getCredentials方法：用来获取用户凭证,一般来说就是密码。</li><li>getDetails方法：用来获取用户的详细信息，可能是当前的请求之类。</li><li>getPrincipal方法：用来获取当前用户信息，可能是一个用户名，也可能是一个用户对象。</li><li>isAuthenticated方法：当前用户是否认证成功。</li></ul><p>可以看到，在Spring Security中，只要获取到Authentication对象，就可以获取到登录用户的详细信息，</p><p>不同的认证方式对应不同的Authentication实例,Spring Security中的Authentication实现类如图2-11所示，</p><p>这些实现类现看起来可能会觉得陌生，不过没关系，在后续中，这些实现类基本上都会涉及，现在我们先对每个类的功能做一个大概介绍：</p><ul><li><p>AbstractAuthenticationToken：该类实现了 Authentication 和 CredentialsContainer 两个接口，在AbstractAuthenticationToken中对Authentication接口定义的各个数据获取方法进行了 实现，CredentialsContainer则提供了登录凭证擦除方法。一般在登录成功后，为了防止用户信 息泄漏，可以将登录凭证(例如密码)擦除。</p></li><li><p>RememberMeAuthenticationToken:如果用户使用 RememberMe 的方式登录，登录信息将封装在 RememberMeAuthenticationToken中。</p></li><li><p>TestingAuthenticationToken:单元测试时封装的用户对象口</p></li><li><p>AnonymousAuthenticationToken：匿名登录时封装的用户对象。</p></li><li><p>RunAsUserToken：替换验证身份时封装的用户对象。</p></li><li><p>UsernamePasswordAuthenticationToken：表单登录时封装的用户对象。</p></li><li><p>JaasAuthenticationToken: JAAS 认证时封装的用户对象。</p></li><li><p>PreAuthenticatedAuthenticationToken： Pre-Authentication 场景下封装的用户对象。</p></li></ul><p>  在这些 Authentication 的实例中，最常用的有两个：UsernamePasswordAuthenticationToken 和RememberMeAuthenticationToken。在2中的案例对应的用户认证对象就是UsernamePasswordAuthenticationToken。</p><p>  了解了 Authentication对象之后，接下来我们来看一下如何在登录成功后获取用户登录信 息，即 Authentication 对象。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%881%EF%BC%89.png"></p><center>图 2-11</center><h2 id="1-1-从-SecurityContextHolder-中获取"><a href="#1-1-从-SecurityContextHolder-中获取" class="headerlink" title="1.1 从 SecurityContextHolder 中获取"></a>1.1 从 SecurityContextHolder 中获取</h2><p>  添加一个UserController,内容如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userinfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">        Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = authentication.getAuthorities();</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;authorities = &quot;</span>+authorities);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  配置完成后，启动项目，登录成功后，访问&#x2F;user接口，控制台就会打印出登录用户信息, 当然，由于我们目前没有给用户配置角色，所以默认的用户角色为空数组，如图2-12所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%882%EF%BC%89.png"></p><center>图 2-12</center><p>  这里为了演示方便，我们在Controller中获取登录用户信息，可以发现，SecurityContextHolder.getContext()是一个静态方法，也就意味着我们随时随地都可以获取到登录用户信息，在service层也可以获取到登录用户信息(在实际项目中，大部分情况下也都是在service层获取登录用户信息)。</p><p>  获取登录用户信息的代码很简单，那么SecuntyContextHolder到底是什么？它里边的数据又是从何而来的？接下来我们将进行一一解析。</p><h3 id="1-1-1-SecurityContextHolder"><a href="#1-1-1-SecurityContextHolder" class="headerlink" title="1.1.1 SecurityContextHolder"></a>1.1.1 SecurityContextHolder</h3><p>  SecurityContextHolder 中存储的是 SecurityContext，SecurityContext 中存储的则是 Authentication，三者的关系如图2-13所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%883%EF%BC%89.png"></p><center>图 2-13</center><p>  这幅图清晰地描述了 SecurityContextHolder、SecurityContext 以及 Authentication 三者之间 的关系。</p><p>  首先在 SecurityContextHolder 中存放的是 SecurityContext, SecurityContextHolder 中定义了三种不同的数据存储策略，这实际上是一种典型的策略模式：</p><ul><li>MODE_THREADLOCAL: 这种存放策略是将 SecurityContext 存放在 ThreadLocal 中，大家知道ThreadLocal的特点是在哪个线程中存储就要在哪个线程中读取，这其实非常适合Web应用，因为在默认情况下，一个请求无论经过多少Filter到达Servlet都是由一个线程来处理的，这也是SecurityContextHolder的默认存储策略，这种存储策略意味着如果在具体的业务处理代码中，开启了子线程，在子线程中去获取登录用户数据，就会获取不到。</li><li>MODE_INHERITABLETHREADLOCAL:这种存储模式适用于多线程环境，如果希望在子线程中也能够获取到登录用户数据，那么可以使用这种存储模式。</li><li>MODE_GLOBAL：这种存储模式实际上是将数据保存在一个静态变量中，在Java Web开发中，这种模式很少使用到。</li></ul><p>Spring Security中定义了 SecurityContextHolderStrategy接口用来规范存储策略中的方法， 我们来看一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityContextHolderStrategy</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span>;</span><br><span class="line">	SecurityContext <span class="title function_">getContext</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span>;</span><br><span class="line">	SecurityContext <span class="title function_">createEmptyContext</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  接口中一共定义了四个方法：</p><ul><li>clearContext：该方法用来清除存储的SecurityContext对象。</li><li>getContext：该方法用来获取存储的SecurityContext对象。</li><li>setContext：该方法用来设置存储的SecurityContext对象。</li><li>createEmptyContext: 该方法则用来创建一个空的 SecurityContext对象。</li></ul><p>  在 Spring Security 中，SecurityContextHolderStrategy接口一共有三个实现类，对应了三种不同的存储策略，如图2-14所示</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%884%EF%BC%89.png"></p><center>图 2-14</center>每一个实现类都对应了不同的实现策略，我们先来看一下ThreadLocalSecurityContextHolderStrategy：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalSecurityContextHolderStrategy</span> <span class="keyword">implements</span></span><br><span class="line">		<span class="title class_">SecurityContextHolderStrategy</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SecurityContext&gt; contextHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span> &#123;</span><br><span class="line">		contextHolder.remove();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> SecurityContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">SecurityContext</span> <span class="variable">ctx</span> <span class="operator">=</span> contextHolder.get();</span><br><span class="line">		<span class="keyword">if</span> (ctx == <span class="literal">null</span>) &#123;</span><br><span class="line">			ctx = createEmptyContext();</span><br><span class="line">			contextHolder.set(ctx);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ctx;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">		Assert.notNull(context, <span class="string">&quot;Only non-null SecurityContext instances are permitted&quot;</span>);</span><br><span class="line">		contextHolder.set(context);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> SecurityContext <span class="title function_">createEmptyContext</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecurityContextImpl</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  ThreadLocalSecurityContextHolderStrategy实现了 SecurityContextHolderStrategy接口，并实现了接口中的方法_，_存储数据的载体就是一个ThreadLocal，所以针对SecurityContext的清空、获取以及存储，都是在ThreadLocal中进行操作，例如清空就是调用ThreadLocal的remove 方法。SecurityContext是一个接口，它只有一个实现类SecurityContextImpl,所以创建就直接新建一个SecurityContextImpl对象即可。</p><p>  再来看 InheritableThreadLocalSecurityContextHolderStrategy：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocalSecurityContextHolderStrategy</span> <span class="keyword">implements</span></span><br><span class="line">		<span class="title class_">SecurityContextHolderStrategy</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SecurityContext&gt; contextHolder = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span> &#123;</span><br><span class="line">		contextHolder.remove();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> SecurityContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">SecurityContext</span> <span class="variable">ctx</span> <span class="operator">=</span> contextHolder.get();</span><br><span class="line">		<span class="keyword">if</span> (ctx == <span class="literal">null</span>) &#123;</span><br><span class="line">			ctx = createEmptyContext();</span><br><span class="line">			contextHolder.set(ctx);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ctx;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">		Assert.notNull(context, <span class="string">&quot;Only non-null SecurityContext instances are permitted&quot;</span>);</span><br><span class="line">		contextHolder.set(context);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> SecurityContext <span class="title function_">createEmptyContext</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecurityContextImpl</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InheritableThreadLocalSecurityContextHolderStrategy 和 ThreadLocalSecurityContextHolderStrategy的实现策略基本一致，不同的是存储数据的载体变了，在InheritableThreadLocalSecurityContextHolderStrategy 中存储数据的载体变成了 InheritableThreadLocal。InheritableThreadLocal继承自ThreadLocaL但是多了一个特性，就是在子线程创建的一瞬间，会自动将父线程中的数据复制到子线程中。该存储策略正是利用了这一特性，实现了在子线程中获取登录用户信息的功能，</p><p>  最后再来看一下 GlobalSecurityContextHolderStrategy：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">GlobalSecurityContextHolderStrategy</span> <span class="keyword">implements</span> <span class="title class_">SecurityContextHolderStrategy</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SecurityContext contextHolder;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span> &#123;</span><br><span class="line">		contextHolder = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> SecurityContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (contextHolder == <span class="literal">null</span>) &#123;</span><br><span class="line">			contextHolder = <span class="keyword">new</span> <span class="title class_">SecurityContextImpl</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> contextHolder;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">		Assert.notNull(context, <span class="string">&quot;Only non-null SecurityContext instances are permitted&quot;</span>);</span><br><span class="line">		contextHolder = context;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> SecurityContext <span class="title function_">createEmptyContext</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecurityContextImpl</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  GlobalSecurityContextHolderStrategy的实现就更简单了，用一个静态变量来保存 SecurityContext,所以它也可以在多线程环境下使用，但是一般在Web开发中，这种存储策略使用得较少。</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextHolder</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MODE_THREADLOCAL</span> <span class="operator">=</span> <span class="string">&quot;MODE_THREADLOCAL&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MODE_INHERITABLETHREADLOCAL</span> <span class="operator">=</span> <span class="string">&quot;MODE_INHERITABLETHREADLOCAL&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MODE_GLOBAL</span> <span class="operator">=</span> <span class="string">&quot;MODE_GLOBAL&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SYSTEM_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.security.strategy&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">strategyName</span> <span class="operator">=</span> System.getProperty(SYSTEM_PROPERTY);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SecurityContextHolderStrategy strategy;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">initializeCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		initialize();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span> &#123;</span><br><span class="line">		strategy.clearContext();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> SecurityContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> strategy.getContext();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getInitializeCount</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> initializeCount;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(strategyName)) &#123;</span><br><span class="line">			strategyName = MODE_THREADLOCAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (strategyName.equals(MODE_THREADLOCAL)) &#123;</span><br><span class="line">			strategy = <span class="keyword">new</span> <span class="title class_">ThreadLocalSecurityContextHolderStrategy</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (strategyName.equals(MODE_INHERITABLETHREADLOCAL)) &#123;</span><br><span class="line">			strategy = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocalSecurityContextHolderStrategy</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (strategyName.equals(MODE_GLOBAL)) &#123;</span><br><span class="line">			strategy = <span class="keyword">new</span> <span class="title class_">GlobalSecurityContextHolderStrategy</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Class&lt;?&gt; clazz = Class.forName(strategyName);</span><br><span class="line">				Constructor&lt;?&gt; customStrategy = clazz.getConstructor();</span><br><span class="line">				strategy = (SecurityContextHolderStrategy) customStrategy.newInstance();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				ReflectionUtils.handleReflectionException(ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		initializeCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">		strategy.setContext(context);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setStrategyName</span><span class="params">(String strategyName)</span> &#123;</span><br><span class="line">		SecurityContextHolder.strategyName = strategyName;</span><br><span class="line">		initialize();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> SecurityContextHolderStrategy <span class="title function_">getContextHolderStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> strategy;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> SecurityContext <span class="title function_">createEmptyContext</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> strategy.createEmptyContext();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;SecurityContextHolder[strategy=&#x27;&quot;</span> + strategyName + <span class="string">&quot;&#x27;; initializeCount=&quot;</span></span><br><span class="line">				+ initializeCount + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这段源码中可以看到，SecurityContextHolder定义了三个静态常量用来描述三种不同的存储策略；存储策略strategy会在静态代码块中进行初始化，根据不同的strategyName初始化不同的存储策略；strategyName变量表示目前正在使用的存储策略，开发者可以通过配置系统变量或者调用setStrategyName来修改SecurityContextHolder中的存储策略，调用 setStrategyName 后会重新初始化 strategy。</p><p>  默认情况下，如果开发者试图从子线程中获取当前登录用户数据，就会获取失败，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.intehel.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userinfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">        Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = authentication.getAuthorities();</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;authorities = &quot;</span>+authorities);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">                <span class="keyword">if</span> (authentication == <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取用户信息失败&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">                Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = authentication.getAuthorities();</span><br><span class="line">                <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                System.out.println(threadName+<span class="string">&quot;:name = &quot;</span>+name);</span><br><span class="line">                System.out.println(threadName+<span class="string">&quot;:authorities = &quot;</span> + authorities);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在子线程中尝试获取登录用户数据时，获取到的数据为null,如图2-15所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%885%EF%BC%89.png"></p><center>图 2-15</center><p>  子线程之所以获取不到登录用户信息，就是因为数据存储在ThreadLocal中，存储和读取不是同一个线程，所以获取不到。如果希望子线程中也能够获取到登录用户信息，可以将 SecurityContextHolder 中的存储策略改为 MODE INHERITABLETHREADLOCAL,这样就支持多线程环境下获取登录用户信息了。</p><p>  默认的存储策略是通过System.getProperty加载的，因此我们可以通过配置系统变量来修改默认的存储策略，以IntelliJ IDEA为例，首先单击启动按钮，选择Edit Configurations按钮, 如图2-16所示，然后在打开的选项中，配置VM options参数，添加如下一行，配置界面如图 2-17所示</p><p><code>  -Dspring.security.strategy=MODE_INHERITABLETHREADLOCAL</code></p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%886%EF%BC%89.png"></p><center>图 2-16</center><p><img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%887%EF%BC%89.png"></p><center>图 2-17</center><p>  这样，在SecurityContextHolder中通过System.getProperty加载到的默认存储策略就支持多线程环境了，</p><p>  配置完成之后，再次启动项目，此时访问&#x2F;user接口，即使在子线程中，也可以获取到登录用户信息了，如图2-18所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%888%EF%BC%89.png"></p><center>图 2-18</center><p>  那么既然SecurityContextHolder默认是将用户信息存储在 ThreadLocal中，在Spring Boot中不同的请求都是由不同的线程处理的，那为什么每一次请求都还能从SecurityContextHolder中获取到登录用户信息呢？这就不得不提到Spring Security过滤器链中重要—环 SecurityContextPersistenceFliter。</p><h3 id="1-1-2-SecurityContextPersistenceFilter"><a href="#1-1-2-SecurityContextPersistenceFilter" class="headerlink" title="1.1.2 SecurityContextPersistenceFilter"></a>1.1.2 SecurityContextPersistenceFilter</h3><p>  前面介绍了 Spring Security中的常见过滤器，在这些过滤器中，存在一个非常重要的过滤器就是 SecurityContextPersistenceFliter。</p><p>  默认情况下，在 Spring Security 过滤器链中，SecurityContextPersistenceFilter 是第一道防线，位于 WebAsyncManagerlntegrationFilter 之后。从 SecurityContextPersistenceFilter 这个过滤器的名字上就可以推断出来，它的作用是为了存储SecuntyContext而设计的。</p><p>  整体上来说，SecurityContextPersistenceFilter 主要做两件事情：</p><ul><li>当一个请求到来时，从 httpsSession 中获取 SecurityContext 并存入 SecurityContextHolder中，这样在同一个请求的后续处理过程中，开发者始终可以通过SeciuityContextHolder 获取到当前登录用户信息，</li><li>当一个请求处理完毕时，从SecurityContextHolder中获取SecuntyContext并存入 httpsSession中(主要针对异步Servlet),方便下一个请求到来时，再从httpsSession中拿出来使用，同时擦除SecurityContextHolder中的登录用户信息。</li></ul><p>  在SecurityContextPersistenceFilter 过滤器中，当一个请求处理完毕时，从SecurityContextHolder中获取SecurityContext 存入 httpsSession 中，这一步的操作主要是针对异步Servlet。如果不是异步Servlet,在响应提交时，就会将</p><p>SecurityContext 保存到httpsSession 中了，而不会等到在SecurityContextPersistenceFliter过滤器中再去存储。</p><p>  这就是SecurityContextPersistenceFliter大致上做的事情,在正式升始介绍SecurityContextPersistenceFilter 之前,需要先介绍另外接口，这就是 SecurityContextRepository接口，将 SecurityContext 存入 httpsSession,或者从 httpsSession 中加载数据并转为 SecurityContext对象，这些事情都是由SecurityContextRepositoiy接口的实现类完成的，因此这里我们 就先从 SecurityContextRepository 接口开始看起。首先我们来看一下SecurityContextRepository接口的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityContextRepository</span> &#123;</span><br><span class="line">	SecurityContext <span class="title function_">loadContext</span><span class="params">(httpsRequestResponseHolder requestResponseHolder)</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">saveContext</span><span class="params">(SecurityContext context, httpsServletRequest request,</span></span><br><span class="line"><span class="params">			httpsServletResponse response)</span>;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">containsContext</span><span class="params">(httpsServletRequest request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SecurityContextRepository接口 中一共定义了三个方法：</p><ul><li>loadContext：这个方法用来加载SecurityContext 对象出来，对于没有登录的用户，这里会返回一个空的SecurityContext对象，注意空的SecurityContext对象是指SecurityContext 中不存在Authentication对象，而不是该方法返回null。</li><li>saveContext：该方法用来保存一个 SecurityContext 对象</li><li>containsContext：该方法可以判断SecurityContext对象是否存在。</li></ul><p>  在Spring Security框架中，为SecurityContextRepository接口一共提供了三个实现类，如图2-19所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%889%EF%BC%89.png"></p><center>图 2-19</center><p>  在这三个实现类中，TestSecurityContextRepository为单元测试提供支持；NullSecurityContextRepository 实现类中，loadContext 方法总是返回一个空的 SecurityContext 对象, saveContext方法未做任何实现，containsContext方法总是返回false ,所以 NullSecurityContextRepository 实现类实际上未做 SecurityContext 的存储工作，</p><p>  在 Spring Security 中默认使用的实现类是 httpsSessionSecurityContextRepository,通过 httpsSessionSecurityContextRepository实现了将 SecurityContext 存储到 httpsSession 以及从 httpsSession 中加载 SecurityContext出来，这里我们来重点看一下 httpsSessionSecurityContextRepository 类。</p><p>  在正式开始介绍 httpsSessionSecurityContextRepository之前，首先来看一下 httpsSessionSecurityContextRepository中定义的关于请求和封装的两个内部类。</p><p>  首先是 httpsSessionSecurityContextRepository中定义的对于响应的封装类 SaveToSessionResponseWrapper,我们先来看一下 SaveToSessionResponseWrapper的继承关系图，如图 2-20 所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%8810%EF%BC%89.png"></p><center>图 2-20</center><p>  从这幅继承关系图中可以看到，SaveToSessionResponseWrapper实际上就是我们所熟知的 httpsServletResponse功能的扩展。这里有三个关键的实现类：</p><ul><li><p>httpsServletResponseWrapper： httpsServletResponseWrapper 实现了httpsServletResponse 接口，它是httpsServletResponse的装饰类，利用httpsServletResponseWrapper可以方便地操作参数和输出流等。</p></li><li><p>OnCommittedResponseWrapper： OnCommittedResponseWrapper继承自httpsServletResponseWrapper对其功能进行了增强，最重要的增强在于可以获取httpsServletResponse的提交行为。当httpsServletResponse的 sendRedirect.flushBuffer.flush 以及 close 等方法被调用时，onResponseCommitted方法会被触发，开发者可以在onResponseCommitted方法中做一些数据保存操作，例如保存SecurityContext 不过OnCommittedResponseWrapper中的onResponseCommitted方法只是一个抽象方法，并没有具体的实现，具体的实现则在它的实现类 SaveContextOnUpdateOrErrorResponseWrapper中心</p></li><li><p>SaveContextOnUpdateOrErrorResponseWrapper：该类继承自OnCommittedResponseWrapper并对 onResponseCommitted方法做了实现由在SaveContextOnUpdateOrErrorResponseWrapper类中声明了一个contextSaved变量，表示SecurityContext是否已经存储成功，当httpsServletResponse 提交时，会调用 onResponseCommitted 方法，任 onResponseCommitted方法中调用 saveContext 方法，将 SecurityContext保存到 httpsSession 中，同时将 contextSaved 变量标记为true。 saveContext方法在这里也是一个抽象方法，具体的实现则在SaveToSessionResponseWrapper 类中。</p></li></ul><p>  接下来看一下 httpsSessionSecurityContextRepositoiy 中 SaveToSessionResponseWrapper 的定义：</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SaveToSessionResponseWrapper</span> <span class="keyword">extends</span></span><br><span class="line">		<span class="title class_">SaveContextOnUpdateOrErrorResponseWrapper</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> httpsServletRequest request;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> httpsSessionExistedAtStartOfRequest;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> SecurityContext contextBeforeExecution;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Authentication authBeforeExecution;</span><br><span class="line">	SaveToSessionResponseWrapper(httpsServletResponse response,</span><br><span class="line">			httpsServletRequest request, <span class="type">boolean</span> httpsSessionExistedAtStartOfRequest,</span><br><span class="line">			SecurityContext context) &#123;</span><br><span class="line">		<span class="built_in">super</span>(response, disableUrlRewriting);</span><br><span class="line">		<span class="built_in">this</span>.request = request;</span><br><span class="line">		<span class="built_in">this</span>.httpsSessionExistedAtStartOfRequest = httpsSessionExistedAtStartOfRequest;</span><br><span class="line">		<span class="built_in">this</span>.contextBeforeExecution = context;</span><br><span class="line">		<span class="built_in">this</span>.authBeforeExecution = context.getAuthentication();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">saveContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> context.getAuthentication();</span><br><span class="line">		<span class="type">httpsSession</span> <span class="variable">httpsSession</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (authentication == <span class="literal">null</span> || trustResolver.isAnonymous(authentication)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;SecurityContext is empty or contents are anonymous - context will not be stored in httpsSession.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (httpsSession != <span class="literal">null</span> &amp;&amp; authBeforeExecution != <span class="literal">null</span>) &#123;</span><br><span class="line">				httpsSession.removeAttribute(springSecurityContextKey);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (httpsSession == <span class="literal">null</span>) &#123;</span><br><span class="line">			httpsSession = createNewSessionIfAllowed(context);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (httpsSession != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (contextChanged(context)</span><br><span class="line">					|| httpsSession.getAttribute(springSecurityContextKey) == <span class="literal">null</span>) &#123;</span><br><span class="line">				httpsSession.setAttribute(springSecurityContextKey, context);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;SecurityContext &#x27;&quot;</span> + context</span><br><span class="line">							+ <span class="string">&quot;&#x27; stored to httpsSession: &#x27;&quot;</span> + httpsSession);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">contextChanged</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> context != contextBeforeExecution</span><br><span class="line">				|| context.getAuthentication() != authBeforeExecution;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> httpsSession <span class="title function_">createNewSessionIfAllowed</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (httpsSessionExistedAtStartOfRequest) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;httpsSession is now null, but was not null at start of request; &quot;</span></span><br><span class="line">						+ <span class="string">&quot;session was invalidated, so do not create a new session&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!allowSessionCreation) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;The httpsSession is currently null, and the &quot;</span></span><br><span class="line">						+ httpsSessionSecurityContextRepository.class.getSimpleName()</span><br><span class="line">						+ <span class="string">&quot; is prohibited from creating an httpsSession &quot;</span></span><br><span class="line">						+ <span class="string">&quot;(because the allowSessionCreation property is false) - SecurityContext thus not &quot;</span></span><br><span class="line">						+ <span class="string">&quot;stored for next request&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (contextObject.equals(context)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;httpsSession is null, but SecurityContext has not changed from default empty context: &#x27; &quot;</span></span><br><span class="line">						+ context</span><br><span class="line">						+ <span class="string">&quot;&#x27;; not creating httpsSession or storing SecurityContext&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;httpsSession being created as SecurityContext is non-default&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> request.getSession(<span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">			logger.warn(<span class="string">&quot;Failed to create a session, as response has been committed. Unable to store&quot;</span></span><br><span class="line">					+ <span class="string">&quot; SecurityContext.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在 SaveToSessionResponseWrapper 中其实主要定义了三个方法：saveContext、contextChanged以及CreateNewSessionIfAllowed</p><ul><li>saveContext：该方法主要是用来保存 SecurityContext,如果 authentication 对象为 null 或者它是一个匿名对象，则不需要保存SecurityContext (参见SEC-776： <a href="httpss://github.com/%20spring-projects/spring-security/issues/1036">httpss:&#x2F;&#x2F;github.com&#x2F; spring-projects&#x2F;spring-security&#x2F;issues&#x2F;1036</a>)；同时，如果 httpsSession 不为 null 并且 authBeforeExecution也不为null,就从httpsSession中将保存的登录用户数据移除，这个主要是为了防止 开发者在注销成功的回调中继续调用doFilter方法，进而导致原始的登录信息无法清除的问题(参见 SEC-1587： <a href="httpss://github.com/spting-projects/spTing-secuTity/issues/1826">httpss:&#x2F;&#x2F;github.com&#x2F;spting-projects&#x2F;spTing-secuTity&#x2F;issues&#x2F;1826</a>)；如果 httpsSession为null,则去创建一个httpsSession对象；最后，如果SecurityContext发生了变化， 或者httpsSession中没有保存 SecurityContext,则调用 httpsSession 中的 setAttribute 方法将 SecurityContext保存起来。</li><li>contextChanged：该方法主要用来判断SecurityContext是否发生变化，因为在程序运行过程中_，_开者可能修改了 SecurityContext中的Authentication对象。</li><li>createNewSessionlfAllowed: 该方法用来创建一个 httpsSession 对象。</li></ul><p>  这就是 httpsSessionSecurityContextRepositoiy 中封装的 SaveToSessionResponseWrapper 对象，一个核心功能就是在httpsServletResponse提交的时候，将SecurityContext保存到httpsSession 中，</p><p>  接下来看—下 httpsSessionSecurityContextRepositoiy 中关于 SaveToSessionResponseWrapper 的定义，SaveToSessionResponseWrapper相对而言就要简单很多了:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Servlet3SaveToSessionRequestWrapper</span> <span class="keyword">extends</span></span><br><span class="line">		<span class="title class_">httpsServletRequestWrapper</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> SaveContextOnUpdateOrErrorResponseWrapper response;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Servlet3SaveToSessionRequestWrapper</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">			SaveContextOnUpdateOrErrorResponseWrapper response)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(request);</span><br><span class="line">		<span class="built_in">this</span>.response = response;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> AsyncContext <span class="title function_">startAsync</span><span class="params">()</span> &#123;</span><br><span class="line">		response.disableSaveOnResponseCommitted();</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>.startAsync();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> AsyncContext <span class="title function_">startAsync</span><span class="params">(ServletRequest servletRequest,</span></span><br><span class="line"><span class="params">			ServletResponse servletResponse)</span> <span class="keyword">throws</span> IllegalStateException &#123;</span><br><span class="line">		response.disableSaveOnResponseCommitted();</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>.startAsync(servletRequest, servletResponse);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  SaveToSessionRequestWrapper类实际上是在Spring Security 3.2之后出现的封装类，在 Spring Security 3.2 之前并不存在 SaveToSessionRequestWrapper 类。封装的 SaveToSessionRequestwrapper类主要作用是禁止在异步Servlet提交时，自动保存SecurityContext</p><p>  为什么要禁止呢？我们来看如下一段简单的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userinfo</span><span class="params">(httpsServletRequest req, httpsServletResponse resp)</span>&#123;</span><br><span class="line">    <span class="type">AsyncContext</span> <span class="variable">asyncContext</span> <span class="operator">=</span> req.startAsync();</span><br><span class="line">    CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> asyncContext.getResponse().getWriter();</span><br><span class="line">            out.write(<span class="string">&quot;hello buretuzi&quot;</span>);</span><br><span class="line">            asyncContext.complete();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到，在异步Servlet中，当任务执行完毕之后，httpsServletResponse也会自动提交, 在提交的过程中会自动保存SecurityContext到httpsSession中，但是由于是在子线程中，因此无法获取到 SecurityContext 对象(SecurityContextHolder 默认将数据存储在 ThreadLocal 中)， 所以会保存失败。如果开发者使用了异步Servlet,则默认情况下会禁用httpsServletResponse 提交时自动保存SecurityContext这一功能，改为在SecurityContextPersistenceFilter过滤器中完成 SecurityContext 保存操作。</p><p>  看完了 httpsSessionSecurityContextRepositoiy中封装的两个请求&#x2F;响应对象之后，接下来我 们再来整体上看一下 httpsSessionSecurityContextRepositoiy 类的功能</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">httpsSessionSecurityContextRepository</span> <span class="keyword">implements</span> <span class="title class_">SecurityContextRepository</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPRING_SECURITY_CONTEXT_KEY</span> <span class="operator">=</span> <span class="string">&quot;SPRING_SECURITY_CONTEXT&quot;</span>;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(<span class="built_in">this</span>.getClass());</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">contextObject</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">allowSessionCreation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">disableUrlRewriting</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isServlet3</span> <span class="operator">=</span> ClassUtils.hasMethod(ServletRequest.class, <span class="string">&quot;startAsync&quot;</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">springSecurityContextKey</span> <span class="operator">=</span> SPRING_SECURITY_CONTEXT_KEY;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">AuthenticationTrustResolver</span> <span class="variable">trustResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthenticationTrustResolverImpl</span>();</span><br><span class="line">	<span class="keyword">public</span> SecurityContext <span class="title function_">loadContext</span><span class="params">(httpsRequestResponseHolder requestResponseHolder)</span> &#123;</span><br><span class="line">		<span class="type">httpsServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> requestResponseHolder.getRequest();</span><br><span class="line">		<span class="type">httpsServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> requestResponseHolder.getResponse();</span><br><span class="line">		<span class="type">httpsSession</span> <span class="variable">httpsSession</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">		<span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> readSecurityContextFromSession(httpsSession);</span><br><span class="line">		<span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;No SecurityContext was available from the httpsSession: &quot;</span></span><br><span class="line">						+ httpsSession + <span class="string">&quot;. &quot;</span> + <span class="string">&quot;A new one will be created.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			context = generateNewContext();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">SaveToSessionResponseWrapper</span> <span class="variable">wrappedResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SaveToSessionResponseWrapper</span>(</span><br><span class="line">				response, request, httpsSession != <span class="literal">null</span>, context);</span><br><span class="line">		requestResponseHolder.setResponse(wrappedResponse);</span><br><span class="line">		<span class="keyword">if</span> (isServlet3) &#123;</span><br><span class="line">			requestResponseHolder.setRequest(<span class="keyword">new</span> <span class="title class_">Servlet3SaveToSessionRequestWrapper</span>(</span><br><span class="line">					request, wrappedResponse));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> context;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveContext</span><span class="params">(SecurityContext context, httpsServletRequest request,</span></span><br><span class="line"><span class="params">			httpsServletResponse response)</span> &#123;</span><br><span class="line">		<span class="type">SaveContextOnUpdateOrErrorResponseWrapper</span> <span class="variable">responseWrapper</span> <span class="operator">=</span> WebUtils</span><br><span class="line">				.getNativeResponse(response,</span><br><span class="line">						SaveContextOnUpdateOrErrorResponseWrapper.class);</span><br><span class="line">		<span class="keyword">if</span> (responseWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">					<span class="string">&quot;Cannot invoke saveContext on response &quot;</span></span><br><span class="line">							+ response</span><br><span class="line">							+ <span class="string">&quot;. You must use the httpsRequestResponseHolder.response after invoking loadContext&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!responseWrapper.isContextSaved()) &#123;</span><br><span class="line">			responseWrapper.saveContext(context);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsContext</span><span class="params">(httpsServletRequest request)</span> &#123;</span><br><span class="line">		<span class="type">httpsSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (session == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> session.getAttribute(springSecurityContextKey) != <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> SecurityContext <span class="title function_">readSecurityContextFromSession</span><span class="params">(httpsSession httpsSession)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">debug</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (httpsSession == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (debug) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;No httpsSession currently exists&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">contextFromSession</span> <span class="operator">=</span> httpsSession.getAttribute(springSecurityContextKey);</span><br><span class="line">		<span class="keyword">if</span> (contextFromSession == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (debug) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;httpsSession returned null object for SPRING_SECURITY_CONTEXT&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!(contextFromSession <span class="keyword">instanceof</span> SecurityContext)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(springSecurityContextKey</span><br><span class="line">						+ <span class="string">&quot; did not contain a SecurityContext but contained: &#x27;&quot;</span></span><br><span class="line">						+ contextFromSession</span><br><span class="line">						+ <span class="string">&quot;&#x27;; are you improperly modifying the httpsSession directly &quot;</span></span><br><span class="line">						+ <span class="string">&quot;(you should always use SecurityContextHolder) or using the httpsSession attribute &quot;</span></span><br><span class="line">						+ <span class="string">&quot;reserved for this class?&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (debug) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Obtained a valid SecurityContext from &quot;</span></span><br><span class="line">					+ springSecurityContextKey + <span class="string">&quot;: &#x27;&quot;</span> + contextFromSession + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (SecurityContext) contextFromSession;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">protected</span> SecurityContext <span class="title function_">generateNewContext</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAllowSessionCreation</span><span class="params">(<span class="type">boolean</span> allowSessionCreation)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.allowSessionCreation = allowSessionCreation;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDisableUrlRewriting</span><span class="params">(<span class="type">boolean</span> disableUrlRewriting)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.disableUrlRewriting = disableUrlRewriting;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSpringSecurityContextKey</span><span class="params">(String springSecurityContextKey)</span> &#123;</span><br><span class="line">		Assert.hasText(springSecurityContextKey,</span><br><span class="line">				<span class="string">&quot;springSecurityContextKey cannot be empty&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.springSecurityContextKey = springSecurityContextKey;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Servlet3SaveToSessionRequestWrapper</span> <span class="keyword">extends</span></span><br><span class="line">			<span class="title class_">httpsServletRequestWrapper</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> SaveContextOnUpdateOrErrorResponseWrapper response;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Servlet3SaveToSessionRequestWrapper</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">				SaveContextOnUpdateOrErrorResponseWrapper response)</span> &#123;</span><br><span class="line">			<span class="built_in">super</span>(request);</span><br><span class="line">			<span class="built_in">this</span>.response = response;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> AsyncContext <span class="title function_">startAsync</span><span class="params">()</span> &#123;</span><br><span class="line">			response.disableSaveOnResponseCommitted();</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">super</span>.startAsync();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> AsyncContext <span class="title function_">startAsync</span><span class="params">(ServletRequest servletRequest,</span></span><br><span class="line"><span class="params">				ServletResponse servletResponse)</span> <span class="keyword">throws</span> IllegalStateException &#123;</span><br><span class="line">			response.disableSaveOnResponseCommitted();</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">super</span>.startAsync(servletRequest, servletResponse);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SaveToSessionResponseWrapper</span> <span class="keyword">extends</span></span><br><span class="line">			<span class="title class_">SaveContextOnUpdateOrErrorResponseWrapper</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> httpsServletRequest request;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> httpsSessionExistedAtStartOfRequest;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> SecurityContext contextBeforeExecution;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Authentication authBeforeExecution;</span><br><span class="line">		SaveToSessionResponseWrapper(httpsServletResponse response,</span><br><span class="line">				httpsServletRequest request, <span class="type">boolean</span> httpsSessionExistedAtStartOfRequest,</span><br><span class="line">				SecurityContext context) &#123;</span><br><span class="line">			<span class="built_in">super</span>(response, disableUrlRewriting);</span><br><span class="line">			<span class="built_in">this</span>.request = request;</span><br><span class="line">			<span class="built_in">this</span>.httpsSessionExistedAtStartOfRequest = httpsSessionExistedAtStartOfRequest;</span><br><span class="line">			<span class="built_in">this</span>.contextBeforeExecution = context;</span><br><span class="line">			<span class="built_in">this</span>.authBeforeExecution = context.getAuthentication();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">saveContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> context.getAuthentication();</span><br><span class="line">			<span class="type">httpsSession</span> <span class="variable">httpsSession</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (authentication == <span class="literal">null</span> || trustResolver.isAnonymous(authentication)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;SecurityContext is empty or contents are anonymous - context will not be stored in httpsSession.&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (httpsSession != <span class="literal">null</span> &amp;&amp; authBeforeExecution != <span class="literal">null</span>) &#123;</span><br><span class="line">					httpsSession.removeAttribute(springSecurityContextKey);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (httpsSession == <span class="literal">null</span>) &#123;</span><br><span class="line">				httpsSession = createNewSessionIfAllowed(context);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (httpsSession != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (contextChanged(context)</span><br><span class="line">						|| httpsSession.getAttribute(springSecurityContextKey) == <span class="literal">null</span>) &#123;</span><br><span class="line">					httpsSession.setAttribute(springSecurityContextKey, context);</span><br><span class="line">	</span><br><span class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(<span class="string">&quot;SecurityContext &#x27;&quot;</span> + context</span><br><span class="line">								+ <span class="string">&quot;&#x27; stored to httpsSession: &#x27;&quot;</span> + httpsSession);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">contextChanged</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> context != contextBeforeExecution</span><br><span class="line">					|| context.getAuthentication() != authBeforeExecution;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">private</span> httpsSession <span class="title function_">createNewSessionIfAllowed</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (httpsSessionExistedAtStartOfRequest) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;httpsSession is now null, but was not null at start of request; &quot;</span></span><br><span class="line">							+ <span class="string">&quot;session was invalidated, so do not create a new session&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!allowSessionCreation) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;The httpsSession is currently null, and the &quot;</span></span><br><span class="line">							+ httpsSessionSecurityContextRepository.class.getSimpleName()</span><br><span class="line">							+ <span class="string">&quot; is prohibited from creating an httpsSession &quot;</span></span><br><span class="line">							+ <span class="string">&quot;(because the allowSessionCreation property is false) - SecurityContext thus not &quot;</span></span><br><span class="line">							+ <span class="string">&quot;stored for next request&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (contextObject.equals(context)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;httpsSession is null, but SecurityContext has not changed from default empty context: &#x27; &quot;</span></span><br><span class="line">							+ context</span><br><span class="line">							+ <span class="string">&quot;&#x27;; not creating httpsSession or storing SecurityContext&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;httpsSession being created as SecurityContext is non-default&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> request.getSession(<span class="literal">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Failed to create a session, as response has been committed. Unable to store&quot;</span></span><br><span class="line">						+ <span class="string">&quot; SecurityContext.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTrustResolver</span><span class="params">(AuthenticationTrustResolver trustResolver)</span> &#123;</span><br><span class="line">		Assert.notNull(trustResolver, <span class="string">&quot;trustResolver cannot be null&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.trustResolver = trustResolver;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先通过 SPRING_SECURITY_CONTEXT_KEY 变量定义了 SecurityContext 在 httpsSession中存储的key,如果开发者需要手动操作httpsSession中存储的SecurityContext,可以通过该key来操作。</li><li>trustResolver是一个用户身份评估器，用来判断当前用户是匿名用户还是通过 RememberMe登录的用户。</li><li>在 loadContext 方法中，通过调用 readSecurityContextFromSession 方法来获取 SecurityContext对象，如果获取到的对象为null,则调用generateNewContext方法去生成一个空的SecurityContext对象，最后构造请求和响应的装饰类并存入requestResponseHolder对象中。</li><li>saveContext方法用来保存SecurityContext,在保存之前，会先调用isContextSaved 方法判断是否已经保存了，如果已经保存了，则不再保存，正常情况下，在httpsServletResponse 提交时SecurityContext就已经保存到httpsSession中；如果是异步Servlet,则提交时不会自动将SecurityContext保存到httpsSession,此时会在这里进行保存操作。</li><li>containsContext方法用来判断请求中是否存在SecurityContext对象。</li><li>readSecurityContextFromSession 方法执行具体的 SecurityContext 读取逻辑，从 httpsSession 中获取 SecurityContext 并返回。</li><li>generateNewContext 方法用来生成一个不包含 Authentication 的空的 SecurityContext 对象。</li><li>setAllowSessionCreation方法用来设置是否允许创建httpsSession,默认是true。</li><li>setDisableUrlRewriting方法表示是否禁用URL重写，默认是false。</li><li>setSpringSecurityContextKey 方法可以用来配置 httpsSession 中存储 SecurityContext 的 key。</li><li>isTransientAuthentication 方法用来判断 Authentication 是否免于存储。</li><li>setTrustResolver方法用来配置身份评估器。</li></ol><p>  这就是httpsSessionSecurityContextRepositoiy所提供的所有功能，这些功能都将在 SecurityContextPersistenceFilter过滤器中进行调用，那么接下来我们就来看一下SecurityContextPersistenceFilter中的调用逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextPersistenceFilter</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILTER_APPLIED</span> <span class="operator">=</span> <span class="string">&quot;__spring_security_scpf_applied&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> SecurityContextRepository repo;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">forceEagerSessionCreation</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SecurityContextPersistenceFilter</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">httpsSessionSecurityContextRepository</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SecurityContextPersistenceFilter</span><span class="params">(SecurityContextRepository repo)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.repo = repo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">		<span class="type">httpsServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (httpsServletRequest) req;</span><br><span class="line">		<span class="type">httpsServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (httpsServletResponse) res;</span><br><span class="line">		<span class="keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="literal">null</span>) &#123;</span><br><span class="line">			chain.doFilter(request, response);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">debug</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line">		request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">		<span class="keyword">if</span> (forceEagerSessionCreation) &#123;</span><br><span class="line">			<span class="type">httpsSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">			<span class="keyword">if</span> (debug &amp;&amp; session.isNew()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Eagerly created session: &quot;</span> + session.getId());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">httpsRequestResponseHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">httpsRequestResponseHolder</span>(request,</span><br><span class="line">				response);</span><br><span class="line">		<span class="type">SecurityContext</span> <span class="variable">contextBeforeChainExecution</span> <span class="operator">=</span> repo.loadContext(holder);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">			chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="type">SecurityContext</span> <span class="variable">contextAfterChainExecution</span> <span class="operator">=</span> SecurityContextHolder</span><br><span class="line">					.getContext();</span><br><span class="line">			SecurityContextHolder.clearContext();</span><br><span class="line">			repo.saveContext(contextAfterChainExecution, holder.getRequest(),</span><br><span class="line">					holder.getResponse());</span><br><span class="line">			request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">			<span class="keyword">if</span> (debug) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;SecurityContextHolder now cleared, as request processing completed&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setForceEagerSessionCreation</span><span class="params">(<span class="type">boolean</span> forceEagerSessionCreation)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.forceEagerSessionCreation = forceEagerSessionCreation;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤器的核心方法当然是doFilter,我们就从doFilter方法开始介绍：</p><ol><li>首先从request中获取FILTER_APPLIED属性，如果该属性值不为null则直接执行doFilter方法，当前过滤器到此为止，这个判断主要是确保该请求只执行一次该过滤 器，如果确实是该request第一次经过该过滤器，则给其设置上FILTER_APPLIED属性。</li><li>forceEagerSessionCreation变量表示是否要在过滤器链执行之前确保会话有效，由于这是一个比较耗费资源的操作，因此默认为false,</li><li>构造 httpsRequestResponseHolder 对象，将 httpsServletRequest 和 httpsServletResponse 都存储进去。</li><li>调用loadContext方法去加载SecurityContext, repo实际上就是我们前面所说 httpsSessionSecurityContextRepository 的实例，所以 loadContext 方法这里就不再赘述了。</li><li>将读取到的SecurityContext存入SecurityContextHolder之中,这样，在接下来的处理逻辑中，开发者就可以直接通过SecurityContextHolder获取当前登录用户对象了。</li><li>调用doFilter方法使请求继续向下走，但是要注意，此时传递的request和 response 对象是在 httpsSessionSecurityContextRepositoiy 中封装后的对象，即 SaveToSessionResponseWrapper 和 SaveToSessionRequestWrapper 的实例。</li><li>当请求处理完毕后，在finally模块中，获取最新的SecurityContext对象(开发者可能在后续处理中修改了SecurityContext中的Authentication对象)，然后清空SecurityContextHolder中的数据；再调用saveContext方法保存SecurityContext,具体的保存逻辑前面已经说过，这里就不再赘述了。</li><li>最后，从 request 中移除 FILTER_APPLIED 属性。</li></ol><p>  这就是整个SecurityContextPersistenceFilter过滤器的工作逻辑。一言以蔽之，请求在到达 SecurityContextPersistenceFilter 过滤器之后，先从 httpsSession 中读取 SecurityContext 出来，并存入SecurityContextHolder之中以备后续使用；当请求离开 SecurityContextPersisteiiceFilter过滤器的时候，获取最新的SecurityContext并存入httpsSession中，同时清空SecurityContextHolder中的登录用户信息。</p><p>  这就是第一种登录数据的获取方式，即从SecurityContextHolder中获取。</p><h2 id="1-2-从当前请求对象中获取"><a href="#1-2-从当前请求对象中获取" class="headerlink" title="1.2 从当前请求对象中获取"></a>1.2 从当前请求对象中获取</h2><p>  接下来我们来看一下第二种登录数据获取方式——从当前请求中获取。获取代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/authentication&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">authentication</span><span class="params">(Authentication authentication)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Authentication = &quot;</span>  + authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/principal&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">principal</span><span class="params">(Principal principal)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Principal = &quot;</span> + principal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  开发者可以直接在Controller的请求参数中放入Authentication对象来获取登录用户信息。 通过前面的讲解，大家已经知道Authentication是Principal的子类，所以也可以直接在请求参数中放入Principal来接收当前登录用户信息，需要注意的是，即使参数是Principal，真正的实例依然是Authentication的实例。</p><p>  用过Spring MVC的读者都知道，Controller中方法的参数都是当前请求httpsServletRequest 带来的。毫无疑问，前面的Authentication和Principal参数也都是httpsServletRequest带来的， 那么这些数据到底是何时放入httpsServletRequest的呢？又是以何种形式存在的呢？接下来我 们一起分析一下，</p><p>  在Servlet规范中，最早有三个和安全管理相关的方法：</p><p><code>public String getRemoteUser();</code></p><p><code>public boolean isUserlnRole(String role);</code></p><p><code>public java.security.Principal getUserPrincipal();</code></p><ol><li>getRemoteUser方法用来获取登录用户名_。_</li><li>isUserlnRole方法用来判断当前登录用户是否具备某一个指定的角色。</li><li>getUserPrincipal方法用来获取当前认证主体。</li></ol><p>  从Servlet 3.0开始，在这三个方法的基础之上，又增加了三个和安全管理相关的方法：</p><p><code>public boolean authenticate(httpsServletRespouse response)</code></p><p><code>throws lOException, ServletException;</code></p><p><code>public void login(String username, String password) throws ServletException;</code></p><p><code>public void logout() throws ServletException</code></p><ol><li>authenticate方法可以判断当前请求是否认证成功。</li><li>login方法可以执行登录操作。</li><li>logout方法可以执行注销操作。</li></ol><p>  不过httpsServletRequest只是一个接口，这些安全认证相关的方法，在不同环境下会有不同的实现。</p><p>  如果是一个普通的Web项目 ,不使用任何框架,httpsServletRequest的默认实现类是Tomcat 中的RequestFacade,从这个类的名字上就可以看出来，这是一个使用了 Facade模式(外观模式)的类，真正提供底层服务的是Tomcat中的Request对象，只不过这个Request对象在实现 Servlet规范的同时，还定义了很多Tomcat内部的方法，为了避免开发者直接调用到这些内部方法，这里使用了外观模式。</p><p>  在Tomcat的Request类中，对上面这些方法都做了实现，基本上都是基于Tomcat提供的 Realm来实现的，这种认证方式非常冷门，项目中很少使用，因此这里不做过多介绍，感兴趣 的读者可以查看 <a href="httpss://github.com/lenve/javaboy-code-samples">httpss:&#x2F;&#x2F;github.com&#x2F;lenve&#x2F;javaboy-code-samples</a> 仓库中的 basiclogin 案例来了解 其用法。</p><p>如果使用了 Spring Security框架，那么我们在Controller参数中拿到的httpsServletRequest 实例将是 Servlet3SecurityContextHolderAwareRequestWrapper,很明显，这是被 Spring Security 封装过的请求，</p><p>我们来看一下 Servlet3SecurityContextHolderAwareRequestWrapper 的继承关系，如图 2-21 所示。</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%8811%EF%BC%89.png"></p><center>图 2-21</center><p>  httpsServletRequestWrapper 就不用过多介绍了 , SecurityContextHolderAwareRequestWrapper类主要实现了 Servlet 3.0之前和安全管理相关的三个方法，也就是getRemoteUser()、isUserlnRole(String)以及getUserPrincipal，Servlet 3.0中新增的三个安全管理相关的方法， 则在Servlet3SecurityContextHolderAwareRequestWrapper类中实现心获取用户登录信息主要和前面三个方法有关，因此这里我们主要来看一下SecurityContextHolderAwareRequestWrapper 类中相关方法的实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextHolderAwareRequestWrapper</span> <span class="keyword">extends</span> <span class="title class_">httpsServletRequestWrapper</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AuthenticationTrustResolver trustResolver;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String rolePrefix;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SecurityContextHolderAwareRequestWrapper</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">			String rolePrefix)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(request, <span class="keyword">new</span> <span class="title class_">AuthenticationTrustResolverImpl</span>(), rolePrefix);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SecurityContextHolderAwareRequestWrapper</span><span class="params">(httpsServletRequest request,</span></span><br><span class="line"><span class="params">			AuthenticationTrustResolver trustResolver, String rolePrefix)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(request);</span><br><span class="line">		Assert.notNull(trustResolver, <span class="string">&quot;trustResolver cannot be null&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.rolePrefix = rolePrefix;</span><br><span class="line">		<span class="built_in">this</span>.trustResolver = trustResolver;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> Authentication <span class="title function_">getAuthentication</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">		<span class="keyword">if</span> (!trustResolver.isAnonymous(auth)) &#123;</span><br><span class="line">			<span class="keyword">return</span> auth;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getRemoteUser</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> getAuthentication();</span><br><span class="line">		<span class="keyword">if</span> ((auth == <span class="literal">null</span>) || (auth.getPrincipal() == <span class="literal">null</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (auth.getPrincipal() <span class="keyword">instanceof</span> UserDetails) &#123;</span><br><span class="line">			<span class="keyword">return</span> ((UserDetails) auth.getPrincipal()).getUsername();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> auth.getPrincipal().toString();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Principal <span class="title function_">getUserPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> getAuthentication();</span><br><span class="line">		<span class="keyword">if</span> ((auth == <span class="literal">null</span>) || (auth.getPrincipal() == <span class="literal">null</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> auth;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGranted</span><span class="params">(String role)</span> &#123;</span><br><span class="line">		<span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> getAuthentication();</span><br><span class="line">		<span class="keyword">if</span> (rolePrefix != <span class="literal">null</span> &amp;&amp; role != <span class="literal">null</span> &amp;&amp; !role.startsWith(rolePrefix)) &#123;</span><br><span class="line">			role = rolePrefix + role;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((auth == <span class="literal">null</span>) || (auth.getPrincipal() == <span class="literal">null</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = auth.getAuthorities();</span><br><span class="line">		<span class="keyword">if</span> (authorities == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (GrantedAuthority grantedAuthority : authorities) &#123;</span><br><span class="line">			<span class="keyword">if</span> (role.equals(grantedAuthority.getAuthority())) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUserInRole</span><span class="params">(String role)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> isGranted(role);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;SecurityContextHolderAwareRequestWrapper[ &quot;</span> + getRequest() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SecurityContextHolderAwareRequestWrapper 类其实非常好理解:</p><ol><li>getAuthentication：该方法用来获取当前登录对象Authentication,获取方式就是我们前面所讲的从SecurityContextHolder中获取。如果不是匿名对象就返回，否则就返回null。</li><li>getRemoteUser：该方法返回了当前登录用户的用户名，如果Authentication对象中存储的Principal是当前登录用户对象，则返回用户名；如果Authentication对象中存储的 Principal是当前登录用户名(字符串)，则直接返回即可。</li><li>getUserPrincipaL该方法返回当前登录用户对象，其实就是Authentication的实例。</li><li>isGranted：该方法是一个私有方法，作用是判断当前登录用户是否具备某一个指定的角色。判断逻辑也很简单，先对传入进来的角色进行预处理，有的情况下可能需要添加ROLE_前缀，角色前缀的问题在后面的章节中会做详细介绍，这里先不做过多的展开。 然后调用Authentication#getAuthorities方法，获取当前登录用户所具备的所有角色，最后再和 传入进来的参数进行比较，</li><li>isUserlnRole：该方法调用isGranted方法，进而实现判断当前用户是否具备某一个 指定角色的功能。</li></ol><p>看到这里，相信你己经明白了，在使用了 Spring Security之后，我们通过 httpsServletRequest就可以获取到很多当前登录用户信息了，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(httpsServletRequest req)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">remoteUser</span> <span class="operator">=</span> req.getRemoteUser();</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> (Authentication) req.getUserPrincipal();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">admin</span> <span class="operator">=</span> req.isUserInRole(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;remoteUser = &quot;</span>+remoteUser);</span><br><span class="line">    System.out.println(<span class="string">&quot;auth.getName() = &quot;</span>+auth.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;admin = &quot;</span> +admin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  执行该方法，打印结果如下：</p><p>  <img src="https://image.buretuzi.online/blog/article/springSecurity/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89%EF%BC%8812%EF%BC%89.png"></p><p>  前面我们直接将Authentication或者Principal写到Controller参数中，实际上就是Spring MVC 框架从 Seivlet3SecurityContextHolderAwareRequestWrapper 中提取的用户信息。</p><p>  那么Spring Security是如何将默认的请求对象转化为Servlet3SecurityContextHolderAwareRequestwrapper的呢？这就涉及Spring Security过滤器链中另外一个重要的过滤器———————————————SecurityContextHolderAwareRequestFilter。</p><p>  前面我们提到 Spring Security 过滤器中，有一个 SecurityContextHolderAwareRequestFilter 过滤器，该过滤器的主要作用就是对httpsServletRequest请求进行再包装，重写 httpsServletRequest中和安全管理相关的方法心httpsSeivletRequest在整个请求过程中会被包装 多次，每一次的包装都会给它增添新的功能，例如在经过SecurityContextPersistenceFilter请求 时就会对它进行包装。</p><p>  我们来看一下 SecurityContextHolderAwareRequestFilter 过滤器的源码(部分):</p><p>查看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextHolderAwareRequestFilter</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">rolePrefix</span> <span class="operator">=</span> <span class="string">&quot;ROLE_&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> httpsServletRequestFactory requestFactory;</span><br><span class="line">	<span class="keyword">private</span> AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line">	<span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">	<span class="keyword">private</span> List&lt;LogoutHandler&gt; logoutHandlers;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">AuthenticationTrustResolver</span> <span class="variable">trustResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthenticationTrustResolverImpl</span>();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRolePrefix</span><span class="params">(String rolePrefix)</span> &#123;</span><br><span class="line">		Assert.notNull(rolePrefix, <span class="string">&quot;Role prefix must not be null&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.rolePrefix = rolePrefix;</span><br><span class="line">		updateFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthenticationEntryPoint</span><span class="params">(</span></span><br><span class="line"><span class="params">			AuthenticationEntryPoint authenticationEntryPoint)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.authenticationEntryPoint = authenticationEntryPoint;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthenticationManager</span><span class="params">(AuthenticationManager authenticationManager)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.authenticationManager = authenticationManager;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLogoutHandlers</span><span class="params">(List&lt;LogoutHandler&gt; logoutHandlers)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.logoutHandlers = logoutHandlers;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">		chain.doFilter(<span class="built_in">this</span>.requestFactory.create((httpsServletRequest) req,</span><br><span class="line">				(httpsServletResponse) res), res);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">		<span class="built_in">super</span>.afterPropertiesSet();</span><br><span class="line">		updateFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateFactory</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">rolePrefix</span> <span class="operator">=</span> <span class="built_in">this</span>.rolePrefix;</span><br><span class="line">		<span class="built_in">this</span>.requestFactory = isServlet3() ? createServlet3Factory(rolePrefix)</span><br><span class="line">				: <span class="keyword">new</span> <span class="title class_">httpsServlet25RequestFactory</span>(<span class="built_in">this</span>.trustResolver, rolePrefix);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTrustResolver</span><span class="params">(AuthenticationTrustResolver trustResolver)</span> &#123;</span><br><span class="line">		Assert.notNull(trustResolver, <span class="string">&quot;trustResolver cannot be null&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.trustResolver = trustResolver;</span><br><span class="line">		updateFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> httpsServletRequestFactory <span class="title function_">createServlet3Factory</span><span class="params">(String rolePrefix)</span> &#123;</span><br><span class="line">		<span class="type">httpsServlet3RequestFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">httpsServlet3RequestFactory</span>(rolePrefix);</span><br><span class="line">		factory.setTrustResolver(<span class="built_in">this</span>.trustResolver);</span><br><span class="line">		factory.setAuthenticationEntryPoint(<span class="built_in">this</span>.authenticationEntryPoint);</span><br><span class="line">		factory.setAuthenticationManager(<span class="built_in">this</span>.authenticationManager);</span><br><span class="line">		factory.setLogoutHandlers(<span class="built_in">this</span>.logoutHandlers);</span><br><span class="line">		<span class="keyword">return</span> factory;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isServlet3</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ClassUtils.hasMethod(ServletRequest.class, <span class="string">&quot;startAsync&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从这段源码中可以看到，在 SecurityCoutextHolderAwareRequestFilter#doFilter 方法中，会 调用 requestFactory.create 方法对请求重新进行包装，requestFactory 就是 httpsServletRequestFactoiry 类的实例，它的 create 方法里边就直接创建 了一个 Servlet3SecurityContextHolderAwareRequestwrapper 实例。</p><p>对请求的httpsServletRequest包装之后，接下来在过滤器链中传递的httpsServletRequest对 象，它的 getRemoteUser()、isUserlnRole(String)以及 getUserPrincipal()方法就可以直接使用 了，</p><p>httpsServletRequest 中 getUserPrincipal()方法有了返回值之后，最终在 Spring MVC 的 ServletRequestMethodArgumentResolvei#resolveArgument(Class&lt;?&gt;, httpsServletRequest)方法中进行默认参数解析，自动解析出Principal对象，开发者在Controller中既可以通过Principal 来接收参数，也可以通过Authentication对象来接收。</p><p>经过前面的介绍，相信对于Spring Security中两种获取登录用户信息的方式，以及这两种获取方式的原理，都有一定的了解了，</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="http://blog.buretuzi.online">李文若</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="http://blog.buretuzi.online/2022/08/03/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89/">http://blog.buretuzi.online/2022/08/03/Spring%20Security%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%EF%BC%884%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.buretuzi.online" target="_blank">清河水温龙井茶</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring-Security/">Spring Security</a></div><div class="post_share"><div class="addtoany"><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_wechat"></a><a class="a2a_button_sina_weibo"></a><a class="a2a_button_facebook_messenger"></a><a class="a2a_button_email"></a><a class="a2a_button_copy_link"></a><a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a></div></div><script async src="https://static.addtoany.com/menu/page.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/03/Spring%20Security%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%885%EF%BC%89/"><img class="prev-cover" src="https://image.buretuzi.online/blog/article/article-background/wallhaven-9mwppd.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring Security自定义登录认证与数据持久化（5）</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/02/Spring%20Security%E7%99%BB%E5%BD%95%E8%A1%A8%E5%8D%95%E9%85%8D%E7%BD%AE%EF%BC%883%EF%BC%89/"><img class="next-cover" src="https://image.buretuzi.online/blog/article/article-background/wallhaven-j8wljy.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring Security登录表单配置（3）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/08/09/ObjectPostProcessor%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%A4%9A%E7%A7%8D%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%EF%BC%889%EF%BC%89/" title="ObjectPostProcessor使用与多种用户定义方式（9）"><img class="cover" src="https://image.buretuzi.online/blog/article/article-background/wallhaven-w8dv76.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-09</div><div class="title">ObjectPostProcessor使用与多种用户定义方式（9）</div></div></a></div><div><a href="/2022/08/02/Spring%20Security%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81%EF%BC%882%EF%BC%89/" title="Spring Security基本认证（2）"><img class="cover" src="https://image.buretuzi.online/blog/article/article-background/wallhaven-g8e18q.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-02</div><div class="title">Spring Security基本认证（2）</div></div></a></div><div><a href="/2022/08/10/Spring%20Security%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE%EF%BC%8810%EF%BC%89/" title="Spring Security定义多个过滤器链（10）"><img class="cover" src="https://image.buretuzi.online/blog/article/article-background/wallhaven-gpj1pl.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-10</div><div class="title">Spring Security定义多个过滤器链（10）</div></div></a></div><div><a href="/2022/08/02/Spring%20Security%E7%99%BB%E5%BD%95%E8%A1%A8%E5%8D%95%E9%85%8D%E7%BD%AE%EF%BC%883%EF%BC%89/" title="Spring Security登录表单配置（3）"><img class="cover" src="https://image.buretuzi.online/blog/article/article-background/wallhaven-j8wljy.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-02</div><div class="title">Spring Security登录表单配置（3）</div></div></a></div><div><a href="/2022/08/01/Spring%20Security%E7%9A%84%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%EF%BC%881%EF%BC%89/" title="Spring Security的认证和授权（1）"><img class="cover" src="https://image.buretuzi.online/blog/article/article-background/wallhaven-k7g9qq.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-01</div><div class="title">Spring Security的认证和授权（1）</div></div></a></div><div><a href="/2022/08/04/Spring%20Security%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%886%EF%BC%89/" title="Spring Security认证流程分析（6）"><img class="cover" src="https://image.buretuzi.online/blog/article/article-background/wallhaven-dg58wj.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-04</div><div class="title">Spring Security认证流程分析（6）</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">李文若</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/luaby"><i class="fab fa-github"></i><span>My GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/luaby" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:liwenruo87@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Doro喜欢吃 欧润吉</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96"><span class="toc-number">1.</span> <span class="toc-text">1. 登录用户数据获取</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BB%8E-SecurityContextHolder-%E4%B8%AD%E8%8E%B7%E5%8F%96"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 从 SecurityContextHolder 中获取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-SecurityContextHolder"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1 SecurityContextHolder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-SecurityContextPersistenceFilter"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2 SecurityContextPersistenceFilter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E4%BB%8E%E5%BD%93%E5%89%8D%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1%E4%B8%AD%E8%8E%B7%E5%8F%96"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 从当前请求对象中获取</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/13/exe%E6%B3%A8%E5%86%8C%E4%B8%BAwindows%E6%9C%8D%E5%8A%A1/" title="exe注册为windows服务"><img src="https://image.buretuzi.online/blog/article/article-background/wallhaven-2yed86.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="exe注册为windows服务"></a><div class="content"><a class="title" href="/2025/05/13/exe%E6%B3%A8%E5%86%8C%E4%B8%BAwindows%E6%9C%8D%E5%8A%A1/" title="exe注册为windows服务">exe注册为windows服务</a><time datetime="2025-05-13T17:06:18.000Z" title="发表于 2025-05-13 17:06:18">2025-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/13/UE4_2_operation/" title="2.UE4物体移动"><img src="https://image.buretuzi.online/ue4/095223-6245095744c07.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="2.UE4物体移动"></a><div class="content"><a class="title" href="/2025/04/13/UE4_2_operation/" title="2.UE4物体移动">2.UE4物体移动</a><time datetime="2025-04-13T10:16:00.000Z" title="发表于 2025-04-13 10:16:00">2025-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/11/UE4_1_operation/" title="1.UE4基础操作"><img src="https://image.buretuzi.online/ue4/095223-6245095744c07.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="1.UE4基础操作"></a><div class="content"><a class="title" href="/2025/04/11/UE4_1_operation/" title="1.UE4基础操作">1.UE4基础操作</a><time datetime="2025-04-11T22:16:00.000Z" title="发表于 2025-04-11 22:16:00">2025-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/10/Linux%20%E6%90%AD%E5%BB%BAKMS/" title="Linux 搭建KMS"><img src="https://image.buretuzi.online/blog/article/article-background/wallhaven-x61vml.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Linux 搭建KMS"></a><div class="content"><a class="title" href="/2023/11/10/Linux%20%E6%90%AD%E5%BB%BAKMS/" title="Linux 搭建KMS">Linux 搭建KMS</a><time datetime="2023-11-10T10:43:12.000Z" title="发表于 2023-11-10 10:43:12">2023-11-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/10/Linux%20%E6%90%AD%E5%BB%BAOpenVPN/" title="Linux 搭建OpenVPN"><img src="https://image.buretuzi.online/blog/article/article-background/wallhaven-x61vml.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Linux 搭建OpenVPN"></a><div class="content"><a class="title" href="/2023/11/10/Linux%20%E6%90%AD%E5%BB%BAOpenVPN/" title="Linux 搭建OpenVPN">Linux 搭建OpenVPN</a><time datetime="2023-11-10T10:43:12.000Z" title="发表于 2023-11-10 10:43:12">2023-11-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer_deal"><a class="deal_link" href="" title="mail"><i class="iconfont icon-17"></i></a><a class="deal_link" href="" title="qq" target="_blank"><i class="iconfont icon-qq"></i></a><a class="deal_link" href="" title="CSDN" target="_blank"><i class="iconfont icon-csdn"></i></a><a class="deal_link" href="https://github.com/luaby" title="github" target="_blank"><i class="iconfont icon-github"></i></a><img class="footer_mini_logo entered loading" style="border-radius:50%" src="/img/彩虹.png" onclick="btf.scrollToDest(0,500)" title="返回顶部"><a class="deal_link" href="" title="QQ空间"><i class="iconfont icon-qzone"></i></a><a class="deal_link" href="" title="微信" target="_blank"><i class="iconfont icon-wechat"></i></a><a class="deal_link" href="" title="Twitter" target="_blank"><i class="iconfont icon-twitter"></i></a><a class="deal_link" href="" title="Telegram" target="_blank"><i class="iconfont icon-fasong"></i></a></div><div id="Jay-footer"><div class="footer-group"><h3 class="footer-title">直达</h3><div class="footer-links"><a class="footer-item" href="" target="_blank">我的主页</a><a class="footer-item" href="">音乐欣赏</a><a class="footer-item" href="">心灵港湾</a><a class="footer-item" href="">随机文章</a></div></div><div class="footer-group"><h3 class="footer-title">分类</h3><div class="footer-links"><a class="footer-item" href="">学习笔记</a><a class="footer-item" href="">魔改教程</a><a class="footer-item" href="">算法笔记</a><a class="footer-item" href="">语法教程</a></div></div><div class="footer-group"><h3 class="footer-title">关于</h3><div class="footer-links"><a class="footer-item" href="/about/">关于我</a><a class="footer-item" href="">博客统计</a><a class="footer-item" href="/archives/">文章归档</a><a class="footer-item" href="">更新记录</a></div></div><div class="footer-group"><h3 class="footer-title">友链</h3><div class="footer-links" id="friend-links-in-footer"><a class="footer-item" target="_blank" rel="noopener" href="https://anzhiy.cn/">安知鱼</a><a class="footer-item" target="_blank" rel="noopener" href="https://www.chuckle.top">轻笑Chuckle</a><a class="footer-item" target="_blank" rel="noopener" href="https://akilar.top/">Akilarの糖果屋</a><a class="footer-item" target="_blank" rel="noopener" href="https://yisous.xyz">Ariasaka</a></div></div><div class="footer-group"><h3 class="footer-title">协议</h3><div class="footer-links"><a class="footer-item" href="">隐私协议</a><a class="footer-item" href="">Cookie</a><a class="footer-item" href="">版权协议</a></div></div></div><!--#footer-banner--><!--        #footer-banner-tips--><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()">播放音乐</div><meting-js id="8703296584" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="iconfont icon-baidu"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-music"><a class="rightMenu-item" id="menu-music-play" href="javascript:anzhiyu.musicToggle()"><i class="fas fa-play"></i><span>播放音乐</span></a><a class="rightMenu-item" id="menu-music-pause" href="javascript:anzhiyu.musicToggle()"><i class="fa-solid fa-pause"></i><span>暂停音乐</span></a><a class="rightMenu-item" href="javascript:anzhiyu.musicSkipBack()"><i class="fas fa-backward"></i><span>切换到上一首</span></a><a class="rightMenu-item" href="javascript:anzhiyu.musicSkipForward()"><i class="fas fa-forward"></i><span>切换到下一首</span></a><a class="rightMenu-item" target="_blank" rel="noopener" href="https://y.qq.com/n/ryqq/playlist/8703296584"><i class="fas fa-radio"></i><span>查看歌单</span></a><a class="rightMenu-item" href="javascript:anzhiyu.musicGetSingName()"><i class="fas fa-copy"></i><span>复制歌名</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="./#post-comment"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line" id="common"><a class="rightMenu-item" href="javascript:toRandomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.translate();"><i class="iconfont icon-fanti"></i><span>繁简转换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="javascript:window.location.href=&quot;/about/&quot;;"><i class="fa fa-info-circle"></i><span>版权声明</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/pluginsSrc/instant.page/instantpage.js" type="module"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.buretuzi.online/",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null))},t=()=>{"object"!=typeof twikoo?getScript("/pluginsSrc/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};t()})()</script><script>function loadValine(){function n(){new Valine(Object.assign({el:"#vcomment",appId:"0onZJ2E9cHeXWot3kJWDdrfM-gzGzoHsz",appKey:"ghd4PqqDJfdNbcH3JZEGwl4A",avatar:"mp",serverURLs:"",emojiMaps:"",path:window.location.pathname,visitor:!0}))}"function"==typeof Valine?n():getScript("/pluginsSrc/valine/dist/Valine.min.js").then(n)}{function loadOtherComment(){loadValine()}setTimeout(loadValine,0)}</script></div><div class="aplayer no-destroy" data-id="1708664797" data-server="tencent" data-type="playlist" data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true"></div><script src="/js/cursor.js"></script><script src="/js/sakura.js"></script><script src="/js/Progressbar.js"></script><script async data-pjax src="/js/navigation.js"></script><script src="/js/jquery.min.js"></script><script src="/js/rightmenu.js"></script><script src="/js/title.js"></script><script src="/js/player/anzhiyu.js"></script><script src="/js/player/anzhiyufunction.js"></script><script src="/js/winbox.bundle.min.js"></script><canvas class="fireworks" mobile="true"></canvas><script src="/pluginsSrc/butterfly-extsrc/dist/fireworks.min.js"></script><script defer id="fluttering_ribbon" mobile="true" src="/pluginsSrc/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="/pluginsSrc/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!0,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="/css/player/APlayer.min.css" media="print" onload='this.media="all"'><script src="/js/player/APlayer.min.js"></script><script src="/js/player/Meting2.min.js"></script><script src="/pluginsSrc/pjax/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script></div><div class="contact-info"><div class="option"><i class="fas fa-heart"></i><div class="bloktop"></div><div class="text">或许不该心动<div class="strip"></div></div></div><div class="option"><i class="fas fa-commenting"></i><div class="blok"></div><div class="text">要和我说悄悄话吗？<div class="strip"></div></div></div><div class="option"><i class="fas fa-hourglass-2"></i><div class="blokbottom"></div><div class="text">人生匆匆，何必拘泥过往<div class="strip"></div></div></div></div><script data-pjax>function butterfly_categories_card_injector_config(){var a=document.getElementById("recent-posts");console.log("已挂载butterfly_categories_card"),a.insertAdjacentHTML("afterbegin",'<style>li.categoryBar-list-item{width:24%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(/img/1.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/java/&quot;);" href="javascript:void(0);">java</a><span class="categoryBar-list-count">41</span><span class="categoryBar-list-descr">技术</span></li><li class="categoryBar-list-item" style="background:url(/img/2.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/windows/&quot;);" href="javascript:void(0);">windows</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(/img/3.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Linux/&quot;);" href="javascript:void(0);">Linux</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(/img/4.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/UE4/&quot;);" href="javascript:void(0);">UE4</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li></ul></div></div>')}document.getElementById("recent-posts")&&"/"===location.pathname&&butterfly_categories_card_injector_config()</script><script data-pjax>function butterfly_clock_anzhiyu_injector_config(){var e=document.getElementById("card-widget");console.log("已挂载butterfly_clock_anzhiyu"),e&&e.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="/img/clock.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",qweather_key="077e8d0195484e3a81fdbc5082aab008",gaud_map_key="af81a9f393f79a52e1deb75a2109d705",baidu_ak_key="undefined",flag=0,clock_rectangle="112.982279,28.19409",clock_default_rectangle_enable="false",i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_clock_anzhiyu_injector_config()</script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="/js/clock.min.js"></script><script data-pjax>function butterfly_footer_beautify_injector_config(){var t=document.getElementById("footer-wrap");console.log("已挂载butterfly_footer_beautify"),t.insertAdjacentHTML("beforeend",'<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="/img/footer/frame.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src="/img/footer/theme.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com" style="margin-inline:5px" data-title="本站使用Vercel作为静态托管平台" title=""><img src="/img/footer/host.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20229936" style="margin-inline:5px" data-title="本站已在萌进行备案" title=""><img src="/img/footer/萌备案.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn" style="margin-inline:5px" data-title="本站已在豫进行备案" title=""><img src="/img/footer/豫备案.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.upyun.com/" style="margin-inline:5px" data-title="本站使用又拍云为静态资源提供CDN加速" title=""><img src="/img/footer/cdn.svg" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="/img/footer/copyright.svg" alt=""/></a></p>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_footer_beautify_injector_config()</script><script data-pjax>function butterfly_swiper_injector_config(){var i=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),i.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/07/17/异常处理- SpringBoot（11）/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://image.buretuzi.online/blog/article/article-background/wallhaven-3zj6l9.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-07-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/07/17/异常处理- SpringBoot（11）/&quot;);" href="javascript:void(0);" alt="">异常处理- SpringBoot（11）</a><div class="blog-slider__text">你会爱我吗？</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/07/17/异常处理- SpringBoot（11）/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/08/18/java垃圾收集器与内存分配策略(2)/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/img/1.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/08/18/java垃圾收集器与内存分配策略(2)/&quot;);" href="javascript:void(0);" alt="">java垃圾收集器与内存分配策略(2)</a><div class="blog-slider__text">好吧就这样吧</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/08/18/java垃圾收集器与内存分配策略(2)/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="/js/swiper/swiper.min.js"></script><script defer data-pjax src="/js/swiper/swiper_init.js"></script></body></html>